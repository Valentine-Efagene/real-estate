- Structure things into modules as much as possible.
- Don't worry about unit tests for now.
- Only focus on e2e tests, and give them clear user stories.
- We intend to break the application into microservices in the future, so design with that in mind.
- Use TypeScript features like interfaces, types, and generics effectively.
- The software should be production-ready, with proper error handling, logging, and security considerations.
- The application is a real estate management platform with user authentication, property listings, and mortgage management.
- The application is broken into services that will each be deployed as AWS Lambda functions behind an API Gateway.
- The common modules (database entities, utilities) should be in a shared library that each service can import. This shared library is called `qshelter-common`, and it is an npm package hosted on an npm registry.
- The event bus module serves as our communication and orchestration channel, and it is also an npm package.
- Never import code directly from one service to another. Always use the shared library or event bus for shared functionality.
- All uploads should use presigned S3 URLs generated by the backend, with uploads happening directly from the frontend to S3.
- All authorization should be handled by the API Gateway using a Lambda authorizer. Services should trust the authorizer and not implement their own authorization logic.
- There must be no entity duplication. All entities must come from the shared library.
- Use config service from @valentine-efagene/qshelter-common for configuration management in all services.
- We must always use the published npm packages for shared code. Never import directly from local paths or workspaces.
- Don't add .js extensions to import statements.
- Anything that recurs across services should go into the shared library.
- We use AWS SSM Parameter Store and Secrets Manager for configuration and secrets management.
- We use AWS for live development (staging) and production environments, and LocalStack for local development.
- Our architecture is serverless-first, so design with that in mind.
- Our main techs are Node.js, TypeScript, Express, AWS Lambda, API Gateway, DynamoDB, S3, prisma, zod and LocalStack for local emulation.
- Our framework for serverless apps is the Serverless Framework with serverless-localstack for local development.
- We use zod to generate our openapi/swagger documentation.
- The front end will also import the common package, so I need all the appropriate types and enums to be there, so they don't have to be redefined in the front end.

## Scenario-Based Business Flows

- We document features as **scenario flows**: concrete, real-life narratives with named actors, specific properties, and realistic terms (see `docs/LOS_STORY.md` as an example).
- Each scenario flow describes the end-to-end business logic without technical implementation details; services and e2e tests interpret the flow and implement to best practice.
- When asked to create a new feature or flow, produce a scenario document first (actors, context, numbered steps) before writing code.
- Scenario flows live in the `docs/` folder and serve as the authoritative requirements for e2e tests and service implementations.

## Tenant Scoping

- This is a multi-tenant platform. All data must be isolated by tenant.
- We use a tenant-aware Prisma wrapper (`createTenantPrisma`) that automatically filters queries and injects `tenantId` on creates for scoped models.
- The wrapper is defined in `shared/common/src/prisma/tenant.ts`.
- **When adding a new model with `tenantId` to the schema**, add its name (camelCase) to the `TENANT_SCOPED_MODELS` array in `tenant.ts`.
- If the model has nullable `tenantId` (e.g., global templates), also add it to `OPTIONAL_TENANT_MODELS`.
- The User model has optional `tenantId` and is NOT tenant-scoped (users can exist across tenants or without a tenant).
- In addition to the auto-generated swagger docs, make sure the postman documentation is also always up to date.

## Deployment Status Tracking

- After every deployment, update the `DEPLOYMENT_STATUS.md` file in the project root.
- The file tracks each service's package size, health status, and health check endpoint response.
- When deploying a service, record the new package size and verify the health check works.
- Include the deployment date in the "Last Updated" field.
