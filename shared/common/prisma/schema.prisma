// =============================================================================
// QSHELTER UNIFIED DATABASE SCHEMA
// =============================================================================
// This schema contains all database models for the QShelter platform
// Organized by domain for better readability
// =============================================================================

generator client {
  provider   = "prisma-client"
  output     = "../generated/client"
  engineType = "client"
}

datasource db {
  provider = "mysql"
}

// =============================================================================
// ENUMS - Database-enforced value constraints
// =============================================================================

enum PhaseCategory {
  DOCUMENTATION
  PAYMENT
}

enum PhaseType {
  KYC
  VERIFICATION
  DOWNPAYMENT
  MORTGAGE
  BALLOON
  CUSTOM
}

enum PaymentFrequency {
  MONTHLY
  BIWEEKLY
  WEEKLY
  ONE_TIME
  CUSTOM
}

enum ContractStatus {
  DRAFT
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
  TERMINATED
}

enum PhaseStatus {
  PENDING
  IN_PROGRESS
  AWAITING_APPROVAL
  ACTIVE
  COMPLETED
  SKIPPED
  FAILED
}

enum StepType {
  UPLOAD
  REVIEW
  SIGNATURE
  APPROVAL
  EXTERNAL_CHECK
  WAIT
}

enum StepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
}

enum InstallmentStatus {
  PENDING
  PAID
  OVERDUE
  PARTIALLY_PAID
  WAIVED
}

enum PaymentStatus {
  INITIATED
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ApprovalDecision {
  APPROVED
  REJECTED
  REQUEST_CHANGES
}

enum CompletionCriterion {
  DOCUMENT_APPROVALS
  PAYMENT_AMOUNT
  STEPS_COMPLETED
}

enum DocumentStatus {
  PENDING
  APPROVED
  REJECTED
}

// =============================================================================
// USER & AUTH DOMAIN
// =============================================================================

model User {
  id                     String            @id @default(cuid())
  email                  String            @unique
  password               String?
  phone                  String?           @unique
  firstName              String?
  lastName               String?
  isActive               Boolean           @default(true)
  isEmailVerified        Boolean           @default(false)
  googleId               String?
  avatar                 String?
  tenantId               String?
  tenant                 Tenant?           @relation(fields: [tenantId], references: [id], onDelete: SetNull)
  // Support multiple roles via explicit join table `UserRole`
  userRoles              UserRole[]
  walletId               String?           @unique
  wallet                 Wallet?           @relation(fields: [walletId], references: [id])
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  emailVerifiedAt        DateTime?
  emailVerificationToken String?
  lastLoginAt            DateTime?
  refreshTokens          RefreshToken[]
  passwordResets         PasswordReset[]
  suspensions            UserSuspension[]
  emailPreferences       EmailPreference[]
  deviceEndpoints        DeviceEndpoint[]
  socials                Social[]

  // Relations to other domains
  properties       Property[]
  contracts        Contract[]        @relation("ContractBuyer")
  soldContracts    Contract[]        @relation("ContractSeller")
  contractPayments ContractPayment[] @relation("ContractPayer")

  // Phase step assignments and approvals
  assignedSteps ContractPhaseStep[]         @relation("PhaseStepAssignee")
  stepApprovals ContractPhaseStepApproval[] @relation("PhaseStepApprover")
  uploadedDocs  ContractDocument[]          @relation("DocumentUploader")

  // Prequalification and payment method changes
  prequalifications           Prequalification[]
  paymentMethodChangeRequests PaymentMethodChangeRequest[] @relation("ChangeRequestor")
  reviewedChangeRequests      PaymentMethodChangeRequest[] @relation("ChangeReviewer")

  @@index([email])
  @@index([tenantId])
  @@map("users")
}

model Role {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  userRoles   UserRole[]
  permissions RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("roles")
}

model Permission {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  resource    String
  action      String
  roles       RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([resource, action])
  @@index([resource])
  @@map("permissions")
}

model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

model UserRole {
  userId    String
  roleId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([userId, roleId])
  @@map("user_roles")
}

model Tenant {
  id        String   @id @default(cuid())
  name      String
  subdomain String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relations for multitenancy
  users          User[]
  properties     Property[]
  paymentPlans   PaymentPlan[]
  paymentMethods PropertyPaymentMethod[]
  contracts      Contract[]

  // Prequalification and payment method changes
  prequalifications           Prequalification[]
  paymentMethodChangeRequests PaymentMethodChangeRequest[]
  documentRequirementRules    DocumentRequirementRule[]

  @@index([subdomain])
  @@map("tenants")
}

model RefreshToken {
  id        String   @id @default(cuid())
  // Use the JWT `jti` for indexed lookups and keep the raw JWT (optional)
  jti       String?  @unique @db.VarChar(255)
  token     String?  @db.LongText
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordReset {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

model UserSuspension {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason      String
  suspendedAt DateTime  @default(now())
  expiresAt   DateTime?
  liftedAt    DateTime?

  @@index([userId])
  @@map("user_suspensions")
}

model EmailPreference {
  id                  String   @id @default(cuid())
  userId              String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketingEmails     Boolean  @default(true)
  transactionalEmails Boolean  @default(true)
  propertyAlerts      Boolean  @default(true)
  paymentReminders    Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@map("email_preferences")
}

model DeviceEndpoint {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String // Push notification endpoint
  platform  String // ios, android, web
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("device_endpoints")
}

model Social {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider  String // google, facebook, twitter, etc
  socialId  String // ID from the social provider
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, socialId])
  @@index([userId])
  @@map("socials")
}

model OAuthState {
  id        String   @id @default(cuid())
  state     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
  @@map("oauth_states")
}

model Wallet {
  id           String        @id @default(cuid())
  balance      Float         @default(0)
  currency     String        @default("USD")
  user         User?
  transactions Transaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@map("wallets")
}

model Transaction {
  id          String   @id @default(cuid())
  walletId    String
  wallet      Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  amount      Float
  type        String // CREDIT, DEBIT
  status      String // PENDING, COMPLETED, FAILED
  reference   String?
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([walletId])
  @@map("transactions")
}

model Settings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String   @db.Text
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@map("settings")
}

// =============================================================================
// PROPERTY DOMAIN
// =============================================================================
// Property = listing/project (e.g., "Sunrise Estate")
// PropertyVariant = configuration with specs & price (e.g., "3-Bed Corner - Finished")
// PropertyUnit = individual sellable unit (e.g., "Unit A1")
// =============================================================================

model Property {
  id             String         @id @default(cuid())
  tenantId       String
  tenant         Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId         String
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  title          String
  category       String // SALE, RENT, LEASE
  propertyType   String // APARTMENT, HOUSE, LAND, COMMERCIAL, ESTATE, TOWNHOUSE
  country        String
  currency       String // USD, NGN, etc
  city           String
  district       String?
  zipCode        String?
  streetAddress  String?
  longitude      Float?
  latitude       Float?
  status         String         @default("DRAFT") // DRAFT, PUBLISHED, SOLD_OUT, ARCHIVED
  description    String?        @db.Text
  displayImageId String?
  displayImage   PropertyMedia? @relation("DisplayImage", fields: [displayImageId], references: [id], onDelete: SetNull)
  isPublished    Boolean        @default(false)
  publishedAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Relations
  documents         PropertyDocument[]
  media             PropertyMedia[]             @relation("PropertyMedia")
  amenities         PropertyAmenity[] // Shared amenities (gym, pool, security)
  paymentMethods    PropertyPaymentMethodLink[]
  variants          PropertyVariant[]
  prequalifications Prequalification[]

  @@index([tenantId])
  @@index([userId])
  @@index([category])
  @@index([propertyType])
  @@index([city])
  @@index([status])
  @@map("properties")
}

model PropertyMedia {
  id         String   @id @default(cuid())
  propertyId String
  property   Property @relation("PropertyMedia", fields: [propertyId], references: [id], onDelete: Cascade)
  url        String
  type       String // IMAGE, VIDEO
  caption    String?
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  displayForProperties Property[] @relation("DisplayImage")

  @@index([propertyId])
  @@map("property_media")
}

model PropertyDocument {
  id         String   @id @default(cuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  name       String
  url        String
  type       String // TITLE_DEED, SURVEY_PLAN, etc
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([propertyId])
  @@map("property_documents")
}

model Amenity {
  id         String                   @id @default(cuid())
  name       String                   @unique
  category   String? // PROPERTY, VARIANT, BOTH - helps filter which amenities to show
  icon       String? // Icon name/URL for UI
  createdAt  DateTime                 @default(now())
  updatedAt  DateTime                 @updatedAt
  properties PropertyAmenity[]
  variants   PropertyVariantAmenity[]

  @@index([category])
  @@map("amenities")
}

// =============================================================================
// PROPERTY VARIANT & UNIT MODELS
// =============================================================================

// PropertyVariant = specific configuration with its own price and amenities
// e.g., "3-Bedroom Corner Piece - Fully Finished", "2-Bedroom Standard - Carcass"
model PropertyVariant {
  id         String   @id @default(cuid())
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  name        String // "Corner Piece - Finished", "Standard - Carcass"
  description String? @db.Text

  // Specifications
  nBedrooms     Int?
  nBathrooms    Int?
  nParkingSpots Int?
  area          Float? // Square meters/feet

  // Pricing
  price       Float
  pricePerSqm Float? // Computed or set manually

  // Inventory counters (denormalized for performance, updated via triggers/service)
  totalUnits     Int @default(1)
  availableUnits Int @default(1)
  reservedUnits  Int @default(0)
  soldUnits      Int @default(0)

  // Status
  status    String   @default("AVAILABLE") // AVAILABLE, LOW_STOCK, SOLD_OUT, ARCHIVED
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  amenities PropertyVariantAmenity[]
  units     PropertyUnit[]
  media     PropertyVariantMedia[]

  @@index([propertyId])
  @@index([status])
  @@index([price])
  @@map("property_variants")
}

// PropertyVariantAmenity = amenities specific to a variant
// e.g., "Finished Kitchen", "Smart Home System", "Private Garden"
model PropertyVariantAmenity {
  variantId String
  amenityId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  amenity   Amenity         @relation(fields: [amenityId], references: [id], onDelete: Cascade)
  createdAt DateTime        @default(now())

  @@id([variantId, amenityId])
  @@map("property_variant_amenities")
}

// PropertyVariantMedia = images/videos specific to a variant
model PropertyVariantMedia {
  id        String          @id @default(cuid())
  variantId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  url       String
  type      String // IMAGE, VIDEO, FLOOR_PLAN, 3D_TOUR
  caption   String?
  order     Int             @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([variantId])
  @@map("property_variant_media")
}

// PropertyUnit = individual sellable/rentable unit within a variant
// e.g., "Unit A1", "Block B - Flat 3", "Plot 15"
model PropertyUnit {
  id        String          @id @default(cuid())
  variantId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  unitNumber  String // "A1", "B-3", "Plot 15"
  floorNumber Int? // For apartments
  blockName   String? // "Block A", "Tower 1"

  // Unit-specific overrides (if different from variant)
  priceOverride Float? // If this specific unit has a different price
  areaOverride  Float? // If this specific unit has a different area
  notes         String? @db.Text // Internal notes about this unit

  // Status tracking
  status String @default("AVAILABLE") // AVAILABLE, RESERVED, SOLD, RENTED, UNAVAILABLE

  // Reservation/hold
  reservedAt    DateTime?
  reservedUntil DateTime?
  reservedById  String?

  // Ownership tracking (once sold)
  ownerId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  contracts Contract[]

  @@unique([variantId, unitNumber])
  @@index([variantId])
  @@index([status])
  @@map("property_units")
}

model PropertyAmenity {
  propertyId String
  amenityId  String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  amenity    Amenity  @relation(fields: [amenityId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@id([propertyId, amenityId])
  @@map("property_amenities")
}

// =============================================================================
// PAYMENT PLAN DOMAIN - Reusable installment structure templates
// =============================================================================

// PaymentPlan = reusable structure for how payments are scheduled
// Examples: "Monthly360" (360 monthly payments), "Weekly52", "OneTime"
model PaymentPlan {
  id          String  @id @default(cuid())
  tenantId    String? // NULL = global template available to all tenants
  tenant      Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)

  // Structure configuration
  paymentFrequency       PaymentFrequency
  customFrequencyDays    Int?
  numberOfInstallments   Int // 1 for one-time, 360 for 30yr monthly, etc
  calculateInterestDaily Boolean          @default(false)
  gracePeriodDays        Int              @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Used by property payment method phases (templates)
  methodPhases   PropertyPaymentMethodPhase[]
  // Used by instantiated contract phases
  contractPhases ContractPhase[]

  @@unique([tenantId, name]) // Unique per tenant, or globally if tenantId is null
  @@index([tenantId])
  @@map("payment_plans")
}

// =============================================================================
// PROPERTY PAYMENT METHOD DOMAIN - Product offerings per property
// =============================================================================

// PropertyPaymentMethod = how a property can be purchased (e.g., "Standard Mortgage", "Cash", "Rent-to-Own")
model PropertyPaymentMethod {
  id          String  @id @default(cuid())
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String // "Standard Mortgage", "Flexible Payment", "Cash Purchase"
  description String? @db.Text
  isActive    Boolean @default(true)

  // Global method configuration
  allowEarlyPayoff       Boolean @default(true)
  earlyPayoffPenaltyRate Float?
  autoActivatePhases     Boolean @default(true)
  requiresManualApproval Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Many-to-many with properties
  properties PropertyPaymentMethodLink[]
  // Phases that make up this method (templates)
  phases     PropertyPaymentMethodPhase[]
  // Contracts using this method
  contracts  Contract[]

  // Prequalifications for this payment method
  prequalifications Prequalification[]

  // Payment method change tracking
  changeRequestsFrom PaymentMethodChangeRequest[] @relation("ChangeFromMethod")
  changeRequestsTo   PaymentMethodChangeRequest[] @relation("ChangeToMethod")

  // Document requirement rules
  documentRules   DocumentRequirementRule[] @relation("RulePaymentMethod")
  changeRulesFrom DocumentRequirementRule[] @relation("RuleFromMethod")
  changeRulesTo   DocumentRequirementRule[] @relation("RuleToMethod")

  @@unique([tenantId, name]) // Unique per tenant
  @@index([tenantId])
  @@map("property_payment_methods")
}

// Many-to-many link between Property and PaymentMethod
model PropertyPaymentMethodLink {
  propertyId      String
  property        Property              @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  paymentMethodId String
  paymentMethod   PropertyPaymentMethod @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)

  // Method-specific overrides for this property
  isDefault Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  @@id([propertyId, paymentMethodId])
  @@map("property_payment_method_links")
}

// Phase template within a PropertyPaymentMethod (e.g., documentation, downpayment, mortgage)
// phaseCategory determines the FSM type: DOCUMENTATION or PAYMENT
model PropertyPaymentMethodPhase {
  id              String                @id @default(cuid())
  paymentMethodId String
  paymentMethod   PropertyPaymentMethod @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)
  paymentPlanId   String? // Only for PAYMENT phases
  paymentPlan     PaymentPlan?          @relation(fields: [paymentPlanId], references: [id])

  name        String
  description String? @db.Text

  // Phase classification (DB-enforced enums)
  phaseCategory PhaseCategory
  phaseType     PhaseType
  order         Int

  // Financial configuration (for PAYMENT phases)
  interestRate   Float?
  percentOfPrice Float? // e.g., 10.0 for 10% downpayment

  // Activation rules
  requiresPreviousPhaseCompletion Boolean              @default(true)
  minimumCompletionPercentage     Float?
  completionCriterion             CompletionCriterion?

  // Snapshots for audit (original config at creation time)
  stepDefinitionsSnapshot  Json?
  requiredDocumentSnapshot Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Normalized child tables (for DOCUMENTATION phases)
  steps             PaymentMethodPhaseStep[]
  requiredDocuments PaymentMethodPhaseDocument[]

  @@index([paymentMethodId])
  @@index([paymentPlanId])
  @@index([phaseCategory])
  @@map("property_payment_method_phases")
}

// Step template within a DOCUMENTATION phase
model PaymentMethodPhaseStep {
  id      String                     @id @default(cuid())
  phaseId String
  phase   PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  name     String
  stepType StepType
  order    Int

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([phaseId])
  @@map("payment_method_phase_steps")
}

// Required document within a DOCUMENTATION phase
model PaymentMethodPhaseDocument {
  id      String                     @id @default(cuid())
  phaseId String
  phase   PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  documentType     String
  isRequired       Boolean @default(true)
  description      String? @db.Text
  allowedMimeTypes String? // CSV: application/pdf,image/jpeg
  maxSizeBytes     Int?

  metadata  Json?
  createdAt DateTime @default(now())

  @@index([phaseId, documentType])
  @@map("payment_method_phase_documents")
}

// =============================================================================
// CONTRACT DOMAIN - Unified agreement model (replaces Mortgage, PurchasePlan, etc.)
// =============================================================================
// Contract is the canonical agreement. "Mortgage" is just a product configuration
// that creates a Contract with specific phases (documentation, downpayment, long-term payment).
// Phases can be DOCUMENTATION (FSM for approvals) or PAYMENT (PaymentPlan-driven installments).
// =============================================================================

model Contract {
  id              String                 @id @default(cuid())
  tenantId        String
  tenant          Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // Link to specific unit being purchased/rented
  propertyUnitId  String
  propertyUnit    PropertyUnit           @relation(fields: [propertyUnitId], references: [id], onDelete: Cascade)
  buyerId         String
  buyer           User                   @relation("ContractBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  sellerId        String?
  seller          User?                  @relation("ContractSeller", fields: [sellerId], references: [id])
  paymentMethodId String? // PropertyPaymentMethod used to create this contract
  paymentMethod   PropertyPaymentMethod? @relation(fields: [paymentMethodId], references: [id])

  // Contract identification
  contractNumber String  @unique
  title          String
  description    String? @db.Text
  contractType   String // Admin-defined: MORTGAGE, INSTALLMENT, RENT_TO_OWN, CASH, LEASE, etc.

  // Financial summary (computed from phases)
  totalAmount       Float // Total contract value (from unit price or negotiated)
  downPayment       Float  @default(0)
  downPaymentPaid   Float  @default(0)
  principal         Float? // Financed amount (if applicable)
  interestRate      Float? // Overall interest rate (if applicable)
  termMonths        Int? // Total term (if applicable)
  periodicPayment   Float? // Computed periodic payment (if applicable)
  totalPaidToDate   Float  @default(0)
  totalInterestPaid Float  @default(0)

  // FSM state (DB-enforced enums)
  status         ContractStatus @default(DRAFT)
  state          ContractStatus @default(DRAFT) // FSM state for workflow
  currentPhaseId String?

  // Timing
  nextPaymentDueDate DateTime?
  lastReminderSentAt DateTime?
  startDate          DateTime?
  endDate            DateTime?
  signedAt           DateTime?
  terminatedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  phases      ContractPhase[]
  documents   ContractDocument[]
  payments    ContractPayment[]
  transitions ContractTransition[]
  events      ContractEvent[]

  // Prequalification that led to this contract (optional)
  prequalification            Prequalification?
  // Payment method change requests for this contract
  paymentMethodChangeRequests PaymentMethodChangeRequest[]

  @@index([tenantId])
  @@index([propertyUnitId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([paymentMethodId])
  @@index([status])
  @@index([state])
  @@map("contracts")
}

// Phase within a contract - can be DOCUMENTATION or PAYMENT type
// Admin names phases freely (e.g., "KYC Documents", "Downpayment", "Monthly Mortgage")
model ContractPhase {
  id            String       @id @default(cuid())
  contractId    String
  contract      Contract     @relation(fields: [contractId], references: [id], onDelete: Cascade)
  paymentPlanId String? // Only for PAYMENT phases
  paymentPlan   PaymentPlan? @relation(fields: [paymentPlanId], references: [id])

  // Admin-defined naming
  name        String
  description String? @db.Text

  // Phase classification (DB-enforced enums)
  phaseCategory PhaseCategory
  phaseType     PhaseType
  order         Int

  // FSM state for this phase (DB-enforced enum)
  status PhaseStatus @default(PENDING)

  // Financial details (for PAYMENT phases)
  totalAmount     Float?
  paidAmount      Float  @default(0)
  remainingAmount Float?
  interestRate    Float?

  // Progress counters (for efficient activation checks)
  approvedDocumentsCount Int @default(0)
  requiredDocumentsCount Int @default(0)
  completedStepsCount    Int @default(0)
  totalStepsCount        Int @default(0)

  // Timing
  dueDate     DateTime?
  startDate   DateTime?
  endDate     DateTime?
  activatedAt DateTime?
  completedAt DateTime?

  // Activation rules
  requiresPreviousPhaseCompletion Boolean              @default(true)
  minimumCompletionPercentage     Float?
  completionCriterion             CompletionCriterion?

  // Snapshots for audit (effective config at contract creation)
  paymentPlanSnapshot      Json?
  stepDefinitionsSnapshot  Json?
  requiredDocumentSnapshot Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  installments ContractInstallment[]
  payments     ContractPayment[]
  steps        ContractPhaseStep[] // For DOCUMENTATION phases (FSM steps)

  @@index([contractId])
  @@index([paymentPlanId])
  @@index([phaseCategory])
  @@index([status])
  @@index([order])
  @@map("contract_phases")
}

// Steps within a DOCUMENTATION phase (FSM for document collection/approval)
model ContractPhaseStep {
  id      String        @id @default(cuid())
  phaseId String
  phase   ContractPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  name        String
  description String?  @db.Text
  stepType    StepType
  order       Int

  status StepStatus @default(PENDING)

  // Assignment
  assigneeId String?
  assignee   User?   @relation("PhaseStepAssignee", fields: [assigneeId], references: [id])

  // Required document types for UPLOAD steps (normalized)
  requiredDocuments ContractPhaseStepDocument[]

  // Timing
  dueDate     DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  approvals ContractPhaseStepApproval[]

  @@index([phaseId])
  @@index([status])
  @@index([order])
  @@map("contract_phase_steps")
}

// Required documents for a step (normalized from CSV)
model ContractPhaseStepDocument {
  id     String            @id @default(cuid())
  stepId String
  step   ContractPhaseStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  documentType String
  isRequired   Boolean @default(true)

  createdAt DateTime @default(now())

  @@index([stepId, documentType])
  @@map("contract_phase_step_documents")
}

// Approvals for documentation steps
model ContractPhaseStepApproval {
  id         String            @id @default(cuid())
  stepId     String
  step       ContractPhaseStep @relation(fields: [stepId], references: [id], onDelete: Cascade)
  approverId String?
  approver   User?             @relation("PhaseStepApprover", fields: [approverId], references: [id])

  decision  ApprovalDecision
  comment   String?          @db.Text
  decidedAt DateTime         @default(now())

  createdAt DateTime @default(now())

  @@index([stepId])
  @@map("contract_phase_step_approvals")
}

// Installments within a PAYMENT phase
model ContractInstallment {
  id      String        @id @default(cuid())
  phaseId String
  phase   ContractPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  installmentNumber Int

  amount          Float
  principalAmount Float @default(0)
  interestAmount  Float @default(0)

  dueDate DateTime
  status  InstallmentStatus @default(PENDING)

  paidAmount Float     @default(0)
  paidDate   DateTime?

  lateFee            Float     @default(0)
  lateFeeWaived      Boolean   @default(false)
  gracePeriodDays    Int       @default(0)
  gracePeriodEndDate DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments ContractPayment[]

  @@index([phaseId])
  @@index([dueDate])
  @@index([status])
  @@map("contract_installments")
}

// Unified payment record for contracts
model ContractPayment {
  id            String               @id @default(cuid())
  contractId    String
  contract      Contract             @relation(fields: [contractId], references: [id], onDelete: Cascade)
  phaseId       String?
  phase         ContractPhase?       @relation(fields: [phaseId], references: [id])
  installmentId String?
  installment   ContractInstallment? @relation(fields: [installmentId], references: [id])
  payerId       String?
  payer         User?                @relation("ContractPayer", fields: [payerId], references: [id])

  amount          Float
  principalAmount Float @default(0)
  interestAmount  Float @default(0)
  lateFeeAmount   Float @default(0)

  paymentMethod String // BANK_TRANSFER, CREDIT_CARD, WALLET, CASH, CHECK
  status        PaymentStatus @default(INITIATED)

  reference       String? @unique
  gatewayResponse String? @db.Text // JSON

  processedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([contractId])
  @@index([phaseId])
  @@index([installmentId])
  @@index([payerId])
  @@index([status])
  @@index([reference])
  @@map("contract_payments")
}

// Contract documents (owned by contract, linked to phases/steps as needed)
model ContractDocument {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  phaseId    String? // Optional link to specific phase
  stepId     String? // Optional link to specific step

  name         String
  url          String
  type         String // ID, BANK_STATEMENT, INCOME_PROOF, TITLE_DEED, SIGNATURE, etc.
  uploadedById String?
  uploadedBy   User?   @relation("DocumentUploader", fields: [uploadedById], references: [id])

  status DocumentStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contractId])
  @@index([phaseId])
  @@index([stepId])
  @@index([type])
  @@index([status])
  @@map("contract_documents")
}

// FSM transitions for audit
model ContractTransition {
  id             String   @id @default(cuid())
  contractId     String
  contract       Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  fromState      String
  toState        String
  trigger        String
  metadata       String?  @db.Text // JSON
  transitionedAt DateTime @default(now())

  @@index([contractId])
  @@map("contract_transitions")
}

// Domain events for audit and integration
model ContractEvent {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  event      String
  data       String?  @db.Text // JSON
  createdAt  DateTime @default(now())

  @@index([contractId])
  @@map("contract_events")
}

// =============================================================================
// PREQUALIFICATION - Eligibility assessment before contract creation
// =============================================================================
// Prequalification is a separate aggregate that evaluates a user's eligibility
// for a specific product (property + payment method). It captures their answers
// to eligibility questions and calculates a score. Once approved, it can be
// linked to a Contract to provide context about how the buyer qualified.
// =============================================================================

enum PrequalificationStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  EXPIRED
}

model Prequalification {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // What they're applying for
  propertyId      String
  property        Property              @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  paymentMethodId String
  paymentMethod   PropertyPaymentMethod @relation(fields: [paymentMethodId], references: [id])

  // Questionnaire responses and scoring
  answers Json // Array of {questionId, answer, weight, score}
  score   Float? // Computed eligibility score (0-100)

  // Financial assessment
  requestedAmount     Float? // How much they want to finance
  monthlyIncome       Float? // Self-reported monthly income
  monthlyExpenses     Float? // Self-reported monthly expenses
  debtToIncomeRatio   Float? // Computed DTI
  suggestedTermMonths Int? // System-suggested term based on affordability

  // Status tracking
  status     PrequalificationStatus @default(DRAFT)
  notes      String?                @db.Text // Admin notes
  reviewedBy String? // Admin who reviewed
  reviewedAt DateTime?
  expiresAt  DateTime? // Prequalification validity period

  // If approved, may be linked to eventual contract
  contractId String?   @unique
  contract   Contract? @relation(fields: [contractId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([userId])
  @@index([propertyId])
  @@index([status])
  @@map("prequalifications")
}

// =============================================================================
// PAYMENT METHOD CHANGE REQUEST - Mid-contract payment method changes
// =============================================================================
// When a user wants to change their payment method after contract creation,
// this aggregate tracks the request, required documentation, approvals, and
// final execution. Different from-to combinations may require different docs.
// =============================================================================

enum PaymentMethodChangeStatus {
  PENDING_DOCUMENTS
  DOCUMENTS_SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  EXECUTED
  CANCELLED
}

model PaymentMethodChangeRequest {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  // The change being requested
  fromPaymentMethodId String
  fromPaymentMethod   PropertyPaymentMethod @relation("ChangeFromMethod", fields: [fromPaymentMethodId], references: [id])
  toPaymentMethodId   String
  toPaymentMethod     PropertyPaymentMethod @relation("ChangeToMethod", fields: [toPaymentMethodId], references: [id])

  // Who requested and why
  requestorId String
  requestor   User    @relation("ChangeRequestor", fields: [requestorId], references: [id])
  reason      String? @db.Text

  // Documentation requirements (determined by DocumentRequirementRule)
  requiredDocumentTypes String? // CSV: BANK_STATEMENT,INCOME_PROOF,NEW_EMPLOYER_LETTER
  submittedDocuments    Json? // [{type, s3Key, uploadedAt, status}]

  // Financial impact assessment
  currentOutstanding   Float? // Outstanding balance at time of request
  newTermMonths        Int? // New term if applicable
  newInterestRate      Float? // New rate if applicable
  newMonthlyPayment    Float? // Projected new payment
  penaltyAmount        Float? // Early change penalty if applicable
  financialImpactNotes String? @db.Text

  // Status and workflow
  status      PaymentMethodChangeStatus @default(PENDING_DOCUMENTS)
  reviewerId  String?
  reviewer    User?                     @relation("ChangeReviewer", fields: [reviewerId], references: [id])
  reviewNotes String?                   @db.Text
  reviewedAt  DateTime?

  // Execution details
  executedAt        DateTime?
  previousPhaseData Json? // Snapshot of phases before change
  newPhaseData      Json? // New phases created after change

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([contractId])
  @@index([status])
  @@index([requestorId])
  @@map("payment_method_change_requests")
}

// =============================================================================
// DOCUMENT REQUIREMENT RULES - Configurable document requirements
// =============================================================================
// Admins can configure which documents are required for specific scenarios:
// - Prequalification for a payment method type
// - Contract phases
// - Payment method changes (from-to combinations)
// This allows tenants to customize documentation workflows per product.
// =============================================================================

enum DocumentRequirementContext {
  PREQUALIFICATION // During prequalification
  CONTRACT_PHASE // During a contract phase
  PAYMENT_METHOD_CHANGE // When changing payment method mid-contract
}

model DocumentRequirementRule {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Rule context
  context DocumentRequirementContext

  // Scoping (which situations this rule applies to)
  // For PREQUALIFICATION: paymentMethodId
  // For CONTRACT_PHASE: phaseType
  // For PAYMENT_METHOD_CHANGE: fromMethodId + toMethodId
  paymentMethodId     String?
  paymentMethod       PropertyPaymentMethod? @relation("RulePaymentMethod", fields: [paymentMethodId], references: [id])
  phaseType           String? // KYC, VERIFICATION, DOWNPAYMENT, etc.
  fromPaymentMethodId String?
  fromPaymentMethod   PropertyPaymentMethod? @relation("RuleFromMethod", fields: [fromPaymentMethodId], references: [id])
  toPaymentMethodId   String?
  toPaymentMethod     PropertyPaymentMethod? @relation("RuleToMethod", fields: [toPaymentMethodId], references: [id])

  // Document requirements
  documentType     String // ID_CARD, PASSPORT, BANK_STATEMENT, INCOME_PROOF, etc.
  isRequired       Boolean @default(true)
  description      String? // Instructions for the user
  maxSizeBytes     Int? // Max file size allowed
  allowedMimeTypes String? // CSV: application/pdf,image/jpeg,image/png

  // Validation rules
  expiryDays           Int? // Document must not be older than X days
  requiresManualReview Boolean @default(false)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([context])
  @@index([paymentMethodId])
  @@index([phaseType])
  @@index([fromPaymentMethodId, toPaymentMethodId])
  @@map("document_requirement_rules")
}

// =============================================================================
// EVENT OUTBOX - For guaranteed event delivery to SQS queues
// =============================================================================

model DomainEvent {
  id String @id @default(cuid())

  // Event identification
  eventType     String // MORTGAGE.CREATED, PHASE.ACTIVATED, PAYMENT.COMPLETED, etc
  aggregateType String // Mortgage, MortgagePhase, MortgagePayment, Property, etc
  aggregateId   String

  // Routing - which queue(s) should receive this
  queueName String // notifications, payments, mortgage-steps, accounting, etc

  // Event payload (all data needed by consumers)
  payload String @db.Text // JSON

  // Metadata
  occurredAt DateTime @default(now())
  actorId    String? // User who triggered the event
  actorRole  String? // Role of the actor

  // Processing status
  status       String    @default("PENDING") // PENDING, PROCESSING, SENT, FAILED
  processedAt  DateTime?
  sentAt       DateTime?
  failureCount Int       @default(0)
  lastError    String?   @db.Text
  nextRetryAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, nextRetryAt])
  @@index([eventType])
  @@index([aggregateType, aggregateId])
  @@index([queueName])
  @@index([occurredAt])
  @@map("domain_events")
}
