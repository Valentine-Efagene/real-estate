// =============================================================================
// QSHELTER UNIFIED DATABASE SCHEMA
// =============================================================================
// This schema contains all database models for the QShelter platform
// Organized by domain for better readability
// =============================================================================

generator client {
  provider   = "prisma-client"
  output     = "../generated/client"
  engineType = "client"
}

datasource db {
  provider = "mysql"
}

// =============================================================================
// ENUMS - Database-enforced value constraints
// =============================================================================

enum PhaseCategory {
  QUESTIONNAIRE // Configurable form fields with validation
  DOCUMENTATION // Document upload and approval workflow
  PAYMENT // Installment-based payment collection
}

enum PhaseType {
  // QUESTIONNAIRE phases
  PRE_APPROVAL // Eligibility questionnaire (income, employment, etc.)
  UNDERWRITING // System evaluation of eligibility

  // DOCUMENTATION phases
  KYC
  VERIFICATION

  // PAYMENT phases
  DOWNPAYMENT
  MORTGAGE
  BALLOON

  // Generic
  CUSTOM
}

enum PaymentFrequency {
  MONTHLY
  BIWEEKLY
  WEEKLY
  ONE_TIME
  CUSTOM
}

enum PropertyStatus {
  DRAFT
  PUBLISHED
  SOLD_OUT
  ARCHIVED
}

enum ApplicationStatus {
  DRAFT
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
  TERMINATED
  TRANSFERRED // Application was transferred to a different property
  SUPERSEDED // Another buyer locked the unit - this application was outbid
}

/// Triggers that cause application state transitions
enum ApplicationTrigger {
  SUBMIT // Submit application for review (DRAFT -> PENDING)
  APPROVE // Approve pending application (PENDING -> ACTIVE)
  REJECT // Reject pending application (PENDING -> CANCELLED)
  CANCEL // Cancel application
  COMPLETE // Complete application (all phases done)
  TERMINATE // Terminate active application
  TRANSFER // Transfer to different unit
  SUPERSEDE // Another buyer locked the unit
}

enum TransferRequestStatus {
  PENDING
  APPROVED
  REJECTED
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum PhaseStatus {
  PENDING
  IN_PROGRESS
  AWAITING_APPROVAL
  ACTIVE
  COMPLETED
  SKIPPED
  FAILED
  SUPERSEDED // Phase replaced by payment method change
}

enum StepType {
  UPLOAD
  REVIEW
  SIGNATURE
  APPROVAL
  EXTERNAL_CHECK
  WAIT
  GENERATE_DOCUMENT // Triggers document generation (offer letters, contracts, etc.)
  PRE_APPROVAL // Customer answers eligibility questionnaire
  UNDERWRITING // System evaluates DTI, score, eligibility
  GATE // Explicit human gate requiring action (approve, acknowledge, consent)
}

/// Who must perform a GATE step action
enum GateActor {
  ADMIN // Any tenant admin
  CUSTOMER // The application buyer
  SPECIFIC_ROLE // Requires gateRoleId to be set
}

/// What action is required for a GATE step
enum GateAction {
  APPROVE // Approve/Reject decision (default)
  ACKNOWLEDGE // Just acknowledge, no reject option
  CONFIRM // Confirm details are correct
  CONSENT // Legal consent (e.g., terms & conditions)
}

/// What happens when a GATE step is rejected
enum GateRejectBehavior {
  BLOCK // Block progression, admin must resolve
  RESTART_STEP // Reset this step to pending
  RESTART_PHASE // Reset entire phase
  TERMINATE // Terminate the application
}

enum StepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  SKIPPED
  NEEDS_RESUBMISSION // User must re-upload or correct something (after rejection)
  ACTION_REQUIRED // User action needed (generic - check actionReason)
  AWAITING_REVIEW // Submitted, waiting for admin/system review
}

/// Operators for conditional step evaluation
enum ConditionOperator {
  EQUALS // Field value equals expected value
  NOT_EQUALS // Field value does not equal expected value
  IN // Field value is in a list of values
  NOT_IN // Field value is not in a list of values
  GREATER_THAN // Numeric comparison
  LESS_THAN // Numeric comparison
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
  EXISTS // Field has any value (not null/undefined)
  NOT_EXISTS // Field is null/undefined
}

/// When a step event attachment should trigger
enum StepTrigger {
  ON_COMPLETE // When step is approved/completed
  ON_REJECT // When step is rejected
  ON_SUBMIT // When step is submitted for review
  ON_RESUBMIT // When step is resubmitted after rejection
  ON_START // When step transitions to IN_PROGRESS
}

/// When a phase event attachment should trigger
enum PhaseTrigger {
  ON_ACTIVATE // When phase is activated (becomes current)
  ON_COMPLETE // When phase is completed (all steps/payments done)
  ON_CANCEL // When phase is cancelled
  ON_PAYMENT_RECEIVED // When any payment is received (for PAYMENT phases)
  ON_ALL_PAYMENTS_RECEIVED // When all payments in phase are complete
}

enum InstallmentStatus {
  PENDING
  PAID
  OVERDUE
  PARTIALLY_PAID
  WAIVED
}

enum PaymentStatus {
  INITIATED
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ApprovalDecision {
  APPROVED
  REJECTED
  REQUEST_CHANGES
}

// =============================================================================
// ORGANIZATION TYPE - Lookup table for organization types (replaces enum)
// =============================================================================
// Organizations can have multiple types via OrganizationTypeAssignment.
// Example: QShelter can be both PLATFORM and DEVELOPER.
// System types are seeded during tenant bootstrap and cannot be deleted.
// =============================================================================

model OrganizationType {
  id          String  @id @default(cuid())
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  code        String // "PLATFORM", "BANK", "DEVELOPER", "LEGAL", "INSURER", "GOVERNMENT"
  name        String // Human-readable: "Platform Operator", "Bank/Lender", etc.
  description String? @db.Text

  // System types are seeded during bootstrap and cannot be deleted
  isSystemType Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Organizations with this type
  organizations OrganizationTypeAssignment[]

  // Applications assigned to orgs acting as this type
  applicationOrganizations ApplicationOrganization[]

  // Approval stages that require this type of organization
  approvalStages ApprovalStage[]

  // Document reviews performed by orgs acting as this type (audit snapshot)
  documentReviews DocumentReview[]

  // Approval stage progress instances
  approvalStageProgress ApprovalStageProgress[]

  // Document approvals
  documentApprovals DocumentApproval[]

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([code])
  @@map("organization_types")
}

/// Links organizations to their types (many-to-many)
/// An organization can have multiple types (e.g., QShelter is PLATFORM + DEVELOPER)
model OrganizationTypeAssignment {
  id             String           @id @default(cuid())
  organizationId String
  organization   Organization     @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  typeId         String
  orgType        OrganizationType @relation(fields: [typeId], references: [id], onDelete: Cascade)

  // Which type is the primary one for display purposes
  isPrimary Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([organizationId, typeId])
  @@index([organizationId])
  @@index([typeId])
  @@map("organization_type_assignments")
}

/// Status of an organization
enum OrganizationStatus {
  PENDING // Awaiting approval to operate on platform
  ACTIVE // Fully operational
  SUSPENDED // Temporarily suspended
  INACTIVE // No longer active
}

// =============================================================================
// CONTRACT TERMINATION / CANCELLATION ENUMS
// =============================================================================

enum TerminationType {
  BUYER_WITHDRAWAL // Buyer wants to cancel (voluntary)
  SELLER_WITHDRAWAL // Seller/developer cancels
  MUTUAL_AGREEMENT // Both parties agree to terminate
  PAYMENT_DEFAULT // Buyer failed payment obligations
  DOCUMENT_FAILURE // Buyer failed to provide required documents
  FRAUD // Fraudulent activity detected
  FORCE_MAJEURE // External circumstances (disaster, etc.)
  PROPERTY_UNAVAILABLE // Property no longer available
  REGULATORY // Regulatory/legal requirement
  OTHER // Other reasons (with notes)
}

enum TerminationStatus {
  REQUESTED // Initial request submitted
  PENDING_REVIEW // Awaiting admin review
  PENDING_REFUND // Approved, awaiting refund processing
  REFUND_IN_PROGRESS // Refund being processed
  REFUND_COMPLETED // Refund completed
  COMPLETED // Termination fully executed (no refund or refund done)
  REJECTED // Termination request rejected
  CANCELLED // Termination request was cancelled
}

enum TerminationInitiator {
  BUYER
  SELLER
  ADMIN
  SYSTEM
}

enum CompletionCriterion {
  DOCUMENT_APPROVALS
  PAYMENT_AMOUNT
  STEPS_COMPLETED
}

// =============================================================================
// DOCUMENT REVIEW ENUMS
// =============================================================================

enum ReviewDecision {
  PENDING // Review not yet performed
  APPROVED // Document approved by this party
  REJECTED // Document rejected (permanent)
  CHANGES_REQUESTED // Document needs modifications
  WAIVED // Review not required by this party
}

enum DocumentStatus {
  DRAFT
  PENDING
  PENDING_SIGNATURE
  SENT
  VIEWED
  SIGNED
  APPROVED
  REJECTED
  EXPIRED
  CANCELLED
  NEEDS_REUPLOAD // Document rejected, customer must re-upload
}

// =============================================================================
// APPROVAL STAGE ENUMS (Multi-stage document workflow)
// =============================================================================

/// Status of an approval stage in a documentation phase
enum StageStatus {
  PENDING // Not yet activated
  IN_PROGRESS // Activated, documents being reviewed
  AWAITING_TRANSITION // All docs approved, waiting for explicit stage completion
  COMPLETED // Stage completed, next stage can activate
}

/// Who uploads a document
enum UploadedBy {
  CUSTOMER
  LENDER
  DEVELOPER
  LEGAL
  INSURER
  PLATFORM // QShelter staff
}

/// What happens when a later stage rejects a document
enum RejectionBehavior {
  CASCADE_BACK // Restart from Stage 1 (default - full re-vetting)
  RESTART_CURRENT // Only current stage re-reviews after re-upload
  RESTART_FROM_STAGE // Restart from specific stage (uses restartFromStageOrder)
}

enum OfferLetterType {
  PROVISIONAL
  FINAL
}

enum OfferLetterStatus {
  DRAFT
  GENERATED
  SENT
  VIEWED
  SIGNED
  EXPIRED
  CANCELLED
}

enum ApplicationEventType {
  APPLICATION_CREATED
  APPLICATION_STATE_CHANGED
  PHASE_ACTIVATED
  PHASE_COMPLETED
  STEP_COMPLETED
  STEP_REJECTED
  DOCUMENT_SUBMITTED
  DOCUMENT_APPROVED
  DOCUMENT_REJECTED
  PAYMENT_INITIATED
  PAYMENT_COMPLETED
  PAYMENT_FAILED
  INSTALLMENTS_GENERATED
  APPLICATION_SIGNED
  APPLICATION_TERMINATED
  APPLICATION_TRANSFERRED
  UNDERWRITING_COMPLETED
  OFFER_LETTER_GENERATED
  HANDLER_EXECUTED // Event handler was executed
}

enum ApplicationEventGroup {
  STATE_CHANGE
  PAYMENT
  DOCUMENT
  NOTIFICATION
  WORKFLOW
  AUTOMATION // Automated handler executions
}

enum EventActorType {
  USER
  SYSTEM
  WEBHOOK
  ADMIN
}

enum RefundStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

// =============================================================================
// EVENT-DRIVEN WORKFLOW ENUMS
// =============================================================================

/// Handler Type - What kind of action the handler performs
/// These are business-friendly names that admins can understand
enum EventHandlerType {
  SEND_EMAIL // Send an email notification to recipient(s)
  SEND_SMS // Send an SMS text message
  SEND_PUSH // Send a push notification
  CALL_WEBHOOK // Call an external API/webhook
  ADVANCE_WORKFLOW // Advance or complete a workflow step
  RUN_AUTOMATION // Execute internal business logic
  LOCK_UNIT // Lock the property unit for the applicant, supersede competing applications
}

/// Permission effect (Allow/Deny)
enum PermissionEffect {
  ALLOW
  DENY
}

// =============================================================================
// USER & AUTH DOMAIN
// =============================================================================

model User {
  id                     String             @id @default(cuid())
  email                  String             @unique
  password               String?
  phone                  String?            @unique
  firstName              String?
  lastName               String?
  isActive               Boolean            @default(true)
  isEmailVerified        Boolean            @default(false)
  googleId               String?
  avatar                 String?
  // Legacy: Optional direct tenant association (for backward compatibility)
  // New: Use tenantMemberships for multi-tenant federation
  tenantId               String?
  tenant                 Tenant?            @relation(fields: [tenantId], references: [id], onDelete: SetNull)
  // Federated: User can belong to multiple tenants with different roles
  tenantMemberships      TenantMembership[]
  // Legacy: Support multiple roles via explicit join table `UserRole`
  userRoles              UserRole[]
  walletId               String?            @unique
  wallet                 Wallet?            @relation(fields: [walletId], references: [id])
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  emailVerifiedAt        DateTime?
  emailVerificationToken String?
  lastLoginAt            DateTime?
  refreshTokens          RefreshToken[]
  passwordResets         PasswordReset[]
  suspensions            UserSuspension[]
  emailPreferences       EmailPreference[]
  deviceEndpoints        DeviceEndpoint[]
  socials                Social[]

  // Relations to other domains
  properties          Property[]
  applications        Application[]        @relation("ApplicationBuyer")
  soldApplications    Application[]        @relation("ApplicationSeller")
  applicationPayments ApplicationPayment[] @relation("ApplicationPayer")

  // Documentation (new model)
  uploadedDocs      ApplicationDocument[]   @relation("DocumentUploader")
  documentApprovals DocumentApproval[]      @relation("DocumentApprovalReviewer")
  completedStages   ApprovalStageProgress[] @relation("StageCompletedBy")

  // Payment method changes
  paymentMethodChangeRequests PaymentMethodChangeRequest[] @relation("ChangeRequestor")
  reviewedChangeRequests      PaymentMethodChangeRequest[] @relation("ChangeReviewer")

  // Contract terminations
  initiatedTerminations ApplicationTermination[] @relation("TerminationInitiator")
  reviewedTerminations  ApplicationTermination[] @relation("TerminationReviewer")

  // Offer letters
  offerLettersGenerated OfferLetter[] @relation("OfferLetterGenerator")
  offerLettersSent      OfferLetter[] @relation("OfferLetterSender")

  // Property transfer requests
  transferRequestsSubmitted PropertyTransferRequest[] @relation("TransferRequestor")
  transferRequestsReviewed  PropertyTransferRequest[] @relation("TransferReviewer")

  // Unified approval requests
  approvalRequestsSubmitted ApprovalRequest[] @relation("ApprovalRequestor")
  approvalRequestsAssigned  ApprovalRequest[] @relation("ApprovalAssignee")
  approvalRequestsReviewed  ApprovalRequest[] @relation("ApprovalReviewer")

  // Contract refunds
  requestedRefunds ApplicationRefund[] @relation("RefundRequester")
  approvedRefunds  ApplicationRefund[] @relation("RefundApprover")
  processedRefunds ApplicationRefund[] @relation("RefundProcessor")

  // Document reviews by this user
  documentReviews DocumentReview[] @relation("DocumentReviewer")

  // Questionnaire phase reviews by this user
  questionnaireReviews QuestionnairePhaseReview[] @relation("QuestionnaireReviewer")

  // Organization memberships (user can be employee of banks/developers)
  organizationMemberships OrganizationMember[]

  @@index([email])
  @@index([tenantId])
  @@map("users")
}

model Role {
  id          String             @id @default(cuid())
  name        String
  description String?
  // Tenant-scoping: NULL = global template, set = tenant-specific role
  tenantId    String?
  tenant      Tenant?            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // System roles cannot be deleted (admin, user, etc.)
  isSystem    Boolean            @default(false)
  isActive    Boolean            @default(true)
  // Legacy: UserRole for backward compatibility
  userRoles   UserRole[]
  // New: TenantMembership for federated users
  memberships TenantMembership[]
  permissions RolePermission[]
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@unique([name, tenantId]) // Unique name per tenant (null tenantId = global)
  @@index([tenantId])
  @@map("roles")
}

/// Permission defines a path pattern + HTTP methods + effect
/// Supports path-based authorization matching the authorizer's policy structure
model Permission {
  id          String           @id @default(cuid())
  name        String // Descriptive name: "Read Users", "Manage Properties"
  description String?
  // Path pattern: /users, /users/:id, /properties/*, etc.
  path        String
  // HTTP methods: ["GET"], ["GET", "POST"], ["*"] - stored as JSON
  methods     Json             @default("[]")
  // Allow or Deny this path/methods
  effect      PermissionEffect @default(ALLOW)
  // Tenant-scoping: NULL = global template, set = tenant-specific
  tenantId    String?
  tenant      Tenant?          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // System permissions cannot be deleted
  isSystem    Boolean          @default(false)
  roles       RolePermission[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@unique([path, tenantId]) // Unique path per tenant
  @@index([tenantId])
  @@map("permissions")
}

model RolePermission {
  roleId       String
  permissionId String
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  createdAt    DateTime   @default(now())

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

/// Legacy: Direct user-role assignment (global, not tenant-scoped)
/// @deprecated Use TenantMembership for tenant-scoped role assignments
model UserRole {
  userId    String
  roleId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@id([userId, roleId])
  @@map("user_roles")
}

/// Tenant Membership: Links users to tenants with specific roles
/// Enables federated users across multiple tenants with different roles per tenant
model TenantMembership {
  id        String   @id @default(cuid())
  userId    String
  tenantId  String
  roleId    String
  // Whether this membership is active
  isActive  Boolean  @default(true)
  // Whether this is the user's default tenant (for login without specifying tenant)
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Restrict)

  @@unique([userId, tenantId]) // User can only have one membership per tenant
  @@index([tenantId])
  @@index([userId])
  @@map("tenant_memberships")
}

// =============================================================================
// ORGANIZATIONS (Banks, Developers, etc.)
// =============================================================================
// Organizations represent external entities that participate in the platform.
// Banks provide mortgage financing; Developers build and sell properties.
// Users can be employees (members) of organizations with specific roles.
// =============================================================================

/// Organization: Banks, Developers, and other partner entities
model Organization {
  id       String             @id @default(cuid())
  tenantId String
  name     String // e.g., "Access Bank PLC", "Lekki Gardens Ltd"
  status   OrganizationStatus @default(PENDING)

  // Organization types (many-to-many via OrganizationTypeAssignment)
  // An org can have multiple types (e.g., QShelter is PLATFORM + DEVELOPER)
  types OrganizationTypeAssignment[]

  // Platform organization flag - marks the tenant's own organization
  isPlatformOrg Boolean @default(false)

  // Common fields
  email       String? // Primary contact email
  phone       String? // Primary contact phone
  address     String?
  city        String?
  state       String?
  country     String? @default("Nigeria")
  website     String?
  logoUrl     String?
  description String? @db.Text

  // Bank-specific fields
  bankCode      String? // CBN bank code (e.g., "044" for Access Bank)
  bankLicenseNo String? // Banking license number
  swiftCode     String? // SWIFT/BIC code for international transfers
  sortCode      String? // Sort code for local transfers

  // Developer-specific fields
  cacNumber         String? // CAC registration number
  cacCertificateUrl String? // URL to CAC certificate document
  taxId             String? // Tax Identification Number

  // Approval workflow
  approvedAt   DateTime?
  approvedById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members OrganizationMember[]

  // Applications where this organization is involved
  applicationAssignments ApplicationOrganization[]

  // Bank-specific document requirements (for BANK type organizations)
  documentRequirements BankDocumentRequirement[]

  // Document reviews performed by this organization
  documentReviews DocumentReview[]

  // Properties owned/developed by this organization
  properties Property[]

  @@unique([tenantId, bankCode]) // Bank codes unique within tenant
  @@unique([tenantId, cacNumber]) // CAC numbers unique within tenant
  @@index([tenantId])
  @@index([status])
  @@map("organizations")
}

/// OrganizationMember: Links users to organizations
/// User's own roles (via UserRole) determine their abilities within the org
model OrganizationMember {
  id             String @id @default(cuid())
  organizationId String
  userId         String

  // Employee details
  title      String? // Job title (e.g., "Loan Officer", "Mortgage Operations Officer")
  department String? // Department within organization
  employeeId String? // Internal employee ID

  // Status
  isActive Boolean @default(true)

  // Invitation/onboarding tracking
  invitedAt  DateTime?
  acceptedAt DateTime?
  invitedBy  String? // User ID who invited this member
  joinedAt   DateTime  @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId]) // User can only be member once per org
  @@index([userId])
  @@index([organizationId])
  @@map("organization_members")
}

// =============================================================================
// BANK DOCUMENT REQUIREMENTS - Bank-specific document overlays per phase
// =============================================================================
// Banks have different risk appetites and compliance requirements.
// Requirements are scoped to a specific PHASE within a PAYMENT METHOD.
//
// Example: UBA's MREIF preapproval phase may have stricter requirements
// than UBA's NHF preapproval phase - even though both are "preapproval".
//
// This model defines OVERLAY rules:
// - Base documents come from the phase's DocumentationPlan
// - Bank adds/modifies requirements via BankDocumentRequirement
// - Scoped to: Bank + Phase (which belongs to a specific PaymentMethod)
//
// When switching banks mid-application:
// 1. Keep all existing approved documents
// 2. Query new bank's requirements for the same phase
// 3. Calculate delta (what's missing)
// 4. Customer uploads only the delta
// =============================================================================

/// How the bank's requirement modifies the base requirement
enum BankDocumentModifier {
  REQUIRED // Bank requires this document (add if not in base)
  OPTIONAL // Bank makes this optional (override base if required)
  NOT_REQUIRED // Bank doesn't need this (skip even if in base)
  STRICTER // Bank has stricter version (e.g., 12 months instead of 6)
}

/// Bank Document Requirement - Bank-specific document rules per phase
model BankDocumentRequirement {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Which bank this applies to
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Which specific phase within a payment method this applies to
  // This allows different requirements per product (e.g., UBA's MREIF vs NHF)
  phaseId String
  phase   PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  // Document identification
  documentType String // ID_CARD, BANK_STATEMENT, EMPLOYMENT_LETTER, etc.
  documentName String // Human-readable override (e.g., "12 Months Bank Statement")

  // How this modifies the base requirement
  modifier BankDocumentModifier @default(REQUIRED)

  // Bank-specific rules
  description      String? @db.Text // Bank's specific instructions
  expiryDays       Int? // Bank's validity period (may be stricter than base)
  minFiles         Int? // Bank may require more files
  maxFiles         Int?
  allowedMimeTypes String? // Bank may restrict file types

  // Bank-specific validation (JSON schema)
  // Example: { "bankStatementMonths": 12, "minimumBalance": 500000 }
  validationRules Json?

  // Priority for conflict resolution (higher = takes precedence)
  priority Int @default(100)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, phaseId, documentType])
  @@index([tenantId])
  @@index([organizationId])
  @@index([phaseId])
  @@index([documentType])
  @@map("bank_document_requirements")
}

model Tenant {
  id        String   @id @default(cuid())
  name      String
  subdomain String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Back-relations for multitenancy
  users              User[]
  properties         Property[]
  paymentPlans       PaymentPlan[]
  documentationPlans DocumentationPlan[]
  paymentMethods     PropertyPaymentMethod[]
  applications       Application[]

  // RBAC: Tenant-scoped roles and permissions
  roles       Role[]
  permissions Permission[]
  // Federated user memberships
  memberships TenantMembership[]

  // Payment method changes
  paymentMethodChangeRequests PaymentMethodChangeRequest[]
  documentRequirementRules    DocumentRequirementRule[]

  // Contract terminations
  contractTerminations ApplicationTermination[]

  // Offer letters and templates
  documentTemplates DocumentTemplate[]
  offerLetters      OfferLetter[]

  // API keys for third-party integrations
  apiKeys ApiKey[]

  // Event-driven workflow
  eventChannels EventChannel[]
  eventTypes    EventType[]
  eventHandlers EventHandler[]

  // Property transfer requests
  propertyTransferRequests PropertyTransferRequest[]

  // Unified approval requests
  approvalRequests ApprovalRequest[]

  // Contract refunds
  contractRefunds             ApplicationRefund[]
  propertyPaymentMethodLinks  PropertyPaymentMethodLink[]
  propertyPaymentMethodPhases PropertyPaymentMethodPhase[]
  phaseEventAttachments       PhaseEventAttachment[]
  paymentMethodPhaseSteps     PaymentMethodPhaseStep[]
  stepEventAttachments        StepEventAttachment[]
  paymentMethodPhaseDocuments PaymentMethodPhaseDocument[]
  paymentMethodPhaseFields    PaymentMethodPhaseField[]
  applicationPhases           ApplicationPhase[]
  questionnairePhases         QuestionnairePhase[]
  documentationPhases         DocumentationPhase[]
  paymentPhases               PaymentPhase[]
  questionnaireFields         QuestionnaireField[]
  applicationEvents           ApplicationEvent[]
  paymentInstallments         PaymentInstallment[]
  applicationPayments         ApplicationPayment[]
  applicationDocuments        ApplicationDocument[]
  documentApprovals           DocumentApproval[]
  approvalStageProgress       ApprovalStageProgress[]
  propertyMedia               PropertyMedia[]
  propertyDocuments           PropertyDocument[]
  propertyVariants            PropertyVariant[]
  propertyVariantAmenities    PropertyVariantAmenity[]
  propertyVariantMedia        PropertyVariantMedia[]
  propertyUnits               PropertyUnit[]
  propertyAmenities           PropertyAmenity[]
  amenities                   Amenity[]
  socials                     Social[]
  wallets                     Wallet[]
  transactions                Transaction[]
  settings                    Settings[]
  domainEvents                DomainEvent[]
  workflowBlockers            WorkflowBlocker[]
  questionnairePlans          QuestionnairePlan[]
  questionnairePhaseReviews   QuestionnairePhaseReview[]
  documentReviews             DocumentReview[]

  // Bank-specific document requirements
  bankDocumentRequirements BankDocumentRequirement[]

  // Organizations (Banks, Developers) operating on this tenant
  organizations Organization[]

  // Application organization assignments
  applicationOrganizations ApplicationOrganization[]
  organizationTypes        OrganizationType[]

  @@index([subdomain])
  @@map("tenants")
}

// =============================================================================
// API KEYS - Third-party integration credentials
// =============================================================================
// ApiKey enables partners/integrations to authenticate via token exchange.
// 
// Flow:
// 1. Admin creates API key for a partner (POST /api-keys)
// 2. System generates secret, stores in Secrets Manager, returns id.secret ONCE
// 3. Partner calls token endpoint with id.secret (POST /api-keys/:id/token)
// 4. Token endpoint validates via Secrets Manager, returns short-lived JWT
// 5. Partner uses JWT for API requests; authorizer validates + resolves scopes
//
// Security:
// - Raw secret stored ONLY in AWS Secrets Manager (secretRef = ARN)
// - Secret returned only once at creation; admin must rotate if lost
// - Scopes define allowed operations (e.g., ["contract:read", "payment:read"])
// - Short-lived JWTs (5-15 min) minimize exposure on key compromise
// =============================================================================

model ApiKey {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Identification
  name        String // Human-readable name (e.g., "Paystack Integration")
  description String? @db.Text // Optional description
  provider    String // Partner/vendor name (e.g., "paystack", "flutterwave")

  // Secret management (NEVER store raw secret in DB)
  secretRef String // AWS Secrets Manager ARN or name

  // Permissions - scopes this API key is allowed to request
  // Examples: ["contract:read", "payment:*", "property:read"]
  scopes Json // JSON array of scope strings

  // Lifecycle
  enabled    Boolean   @default(true)
  expiresAt  DateTime? // Optional expiration date
  lastUsedAt DateTime? // Updated on each token exchange
  revokedAt  DateTime? // Set when key is revoked
  revokedBy  String? // User ID who revoked

  // Audit
  createdBy String? // User ID who created
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([provider])
  @@index([enabled])
  @@map("api_keys")
}

model RefreshToken {
  id        String   @id @default(cuid())
  // Use the JWT `jti` for indexed lookups and keep the raw JWT (optional)
  jti       String?  @unique @db.VarChar(255)
  token     String?  @db.LongText
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model PasswordReset {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

model UserSuspension {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  reason      String
  suspendedAt DateTime  @default(now())
  expiresAt   DateTime?
  liftedAt    DateTime?

  @@index([userId])
  @@map("user_suspensions")
}

model EmailPreference {
  id                  String   @id @default(cuid())
  userId              String
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  marketingEmails     Boolean  @default(true)
  transactionalEmails Boolean  @default(true)
  propertyAlerts      Boolean  @default(true)
  paymentReminders    Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@map("email_preferences")
}

model DeviceEndpoint {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  endpoint  String // Push notification endpoint
  platform  String // ios, android, web
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("device_endpoints")
}

model Social {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider  String // google, facebook, twitter, etc
  socialId  String // ID from the social provider
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, socialId])
  @@index([userId])
  @@index([tenantId])
  @@map("socials")
}

model OAuthState {
  id        String   @id @default(cuid())
  state     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
  @@map("oauth_states")
}

model Wallet {
  id           String        @id @default(cuid())
  tenantId     String
  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  balance      Float         @default(0)
  currency     String        @default("USD")
  user         User?
  transactions Transaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@index([tenantId])
  @@map("wallets")
}

model Transaction {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  walletId    String
  wallet      Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)
  amount      Float
  type        String // CREDIT, DEBIT
  status      String // PENDING, COMPLETED, FAILED
  reference   String?
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([walletId])
  @@index([tenantId])
  @@map("transactions")
}

model Settings {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  key       String
  value     String   @db.Text
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, key])
  @@index([category])
  @@index([tenantId])
  @@map("settings")
}

// =============================================================================
// PROPERTY DOMAIN
// =============================================================================
// Property = listing/project (e.g., "Sunrise Estate")
// PropertyVariant = configuration with specs & price (e.g., "3-Bed Corner - Finished")
// PropertyUnit = individual sellable unit (e.g., "Unit A1")
// =============================================================================

model Property {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional organization ownership
  // If set, any member of this organization with DEVELOPER role can manage the property
  // If null, only the userId owner can manage it (individual seller)
  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  title          String
  category       String // SALE, RENT, LEASE
  propertyType   String // APARTMENT, HOUSE, LAND, COMMERCIAL, ESTATE, TOWNHOUSE
  country        String
  currency       String // USD, NGN, etc
  city           String
  district       String?
  zipCode        String?
  streetAddress  String?
  longitude      Float?
  latitude       Float?
  status         PropertyStatus @default(DRAFT)
  description    String?        @db.Text
  displayImageId String?
  displayImage   PropertyMedia? @relation("DisplayImage", fields: [displayImageId], references: [id], onDelete: SetNull)
  publishedAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  // Relations
  documents      PropertyDocument[]
  media          PropertyMedia[]             @relation("PropertyMedia")
  amenities      PropertyAmenity[] // Shared amenities (gym, pool, security)
  paymentMethods PropertyPaymentMethodLink[]
  variants       PropertyVariant[]

  @@index([tenantId])
  @@index([userId])
  @@index([organizationId])
  @@index([category])
  @@index([propertyType])
  @@index([city])
  @@index([status])
  @@map("properties")
}

model PropertyMedia {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId String
  property   Property @relation("PropertyMedia", fields: [propertyId], references: [id], onDelete: Cascade)
  url        String
  type       String // IMAGE, VIDEO
  caption    String?
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  displayForProperties Property[] @relation("DisplayImage")

  @@index([tenantId])
  @@index([propertyId])
  @@map("property_media")
}

model PropertyDocument {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  name       String
  url        String
  type       String // TITLE_DEED, SURVEY_PLAN, etc
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([tenantId])
  @@index([propertyId])
  @@map("property_documents")
}

model Amenity {
  id         String                   @id @default(cuid())
  tenantId   String
  tenant     Tenant                   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name       String
  category   String? // PROPERTY, VARIANT, BOTH - helps filter which amenities to show
  icon       String? // Icon name/URL for UI
  createdAt  DateTime                 @default(now())
  updatedAt  DateTime                 @updatedAt
  properties PropertyAmenity[]
  variants   PropertyVariantAmenity[]

  @@unique([tenantId, name]) // Unique per tenant
  @@index([tenantId])
  @@index([category])
  @@map("amenities")
}

// =============================================================================
// PROPERTY VARIANT & UNIT MODELS
// =============================================================================

// PropertyVariant = specific configuration with its own price and amenities
// e.g., "3-Bedroom Corner Piece - Fully Finished", "2-Bedroom Standard - Carcass"
model PropertyVariant {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  name        String // "Corner Piece - Finished", "Standard - Carcass"
  description String? @db.Text

  // Specifications
  nBedrooms     Int?
  nBathrooms    Int?
  nParkingSpots Int?
  area          Float? // Square meters/feet

  // Pricing
  price       Float
  pricePerSqm Float? // Computed or set manually

  // Inventory counters (denormalized for performance, updated via triggers/service)
  totalUnits     Int @default(1)
  availableUnits Int @default(1)
  reservedUnits  Int @default(0)
  soldUnits      Int @default(0)

  // Status
  status    String   @default("AVAILABLE") // AVAILABLE, LOW_STOCK, SOLD_OUT, ARCHIVED
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  amenities PropertyVariantAmenity[]
  units     PropertyUnit[]
  media     PropertyVariantMedia[]

  @@index([tenantId])
  @@index([propertyId])
  @@index([status])
  @@index([price])
  @@map("property_variants")
}

// PropertyVariantAmenity = amenities specific to a variant
// e.g., "Finished Kitchen", "Smart Home System", "Private Garden"
model PropertyVariantAmenity {
  tenantId  String
  tenant    Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  variantId String
  amenityId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  amenity   Amenity         @relation(fields: [amenityId], references: [id], onDelete: Cascade)
  createdAt DateTime        @default(now())

  @@id([variantId, amenityId])
  @@index([tenantId])
  @@map("property_variant_amenities")
}

// PropertyVariantMedia = images/videos specific to a variant
model PropertyVariantMedia {
  id        String          @id @default(cuid())
  tenantId  String
  tenant    Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  variantId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)
  url       String
  type      String // IMAGE, VIDEO, FLOOR_PLAN, 3D_TOUR
  caption   String?
  order     Int             @default(0)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([tenantId])
  @@index([variantId])
  @@map("property_variant_media")
}

// PropertyUnit = individual sellable/rentable unit within a variant
// e.g., "Unit A1", "Block B - Flat 3", "Plot 15"
model PropertyUnit {
  id        String          @id @default(cuid())
  tenantId  String
  tenant    Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  variantId String
  variant   PropertyVariant @relation(fields: [variantId], references: [id], onDelete: Cascade)

  unitNumber  String // "A1", "B-3", "Plot 15"
  floorNumber Int? // For apartments
  blockName   String? // "Block A", "Tower 1"

  // Unit-specific overrides (if different from variant)
  priceOverride Float? // If this specific unit has a different price
  areaOverride  Float? // If this specific unit has a different area
  notes         String? @db.Text // Internal notes about this unit

  // Status tracking
  status String @default("AVAILABLE") // AVAILABLE, RESERVED, SOLD, RENTED, UNAVAILABLE

  // Reservation/hold
  reservedAt    DateTime?
  reservedUntil DateTime?
  reservedById  String?

  // Ownership tracking (once sold)
  ownerId String?

  // Optimistic locking for unit reservation race condition
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  applications Application[]

  // Transfer requests targeting this unit
  transferRequests PropertyTransferRequest[]

  @@unique([variantId, unitNumber])
  @@index([tenantId])
  @@index([variantId])
  @@index([status])
  @@map("property_units")
}

model PropertyAmenity {
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId String
  amenityId  String
  property   Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  amenity    Amenity  @relation(fields: [amenityId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@id([propertyId, amenityId])
  @@index([tenantId])
  @@map("property_amenities")
}

// =============================================================================
// DOCUMENTATION PLAN DOMAIN - Reusable step workflow templates
// =============================================================================

// DocumentationPlan = reusable structure for documentation workflows
// Examples: "Standard KYC", "Quick Verification", "Full Underwriting"
model DocumentationPlan {
  id          String  @id @default(cuid())
  tenantId    String? // NULL = global template available to all tenants
  tenant      Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Document definitions (what documents to collect)
  documentDefinitions DocumentDefinition[]

  // Approval stages (sequential workflow for reviewing documents)
  approvalStages ApprovalStage[]

  // Used by property payment method phases (templates)
  methodPhases        PropertyPaymentMethodPhase[]
  // Used by instantiated documentation phases
  documentationPhases DocumentationPhase[]

  @@unique([tenantId, name]) // Unique per tenant, or globally if tenantId is null
  @@index([tenantId])
  @@map("documentation_plans")
}

// =============================================================================
// DOCUMENT DEFINITION - What documents to collect (template)
// =============================================================================
// Defines a document requirement within a documentation plan.
// This is separate from approval workflow - just defines WHAT to collect.
// =============================================================================

model DocumentDefinition {
  id     String            @id @default(cuid())
  planId String
  plan   DocumentationPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  // Document identification
  documentType String // ID_CARD, BANK_STATEMENT, EMPLOYMENT_LETTER, etc.
  documentName String // Human-readable: "Valid ID Card", "6 Months Bank Statement"

  // Who uploads this document
  uploadedBy UploadedBy @default(CUSTOMER)

  // Display order
  order Int

  // Validation rules
  isRequired       Boolean @default(true)
  description      String? @db.Text // Instructions for the uploader
  maxSizeBytes     Int? // Max file size allowed (e.g., 5242880 for 5MB)
  allowedMimeTypes String? // CSV: application/pdf,image/jpeg,image/png
  expiryDays       Int? // Document must not be older than X days
  minFiles         Int     @default(1)
  maxFiles         Int     @default(1)

  // Conditional logic (based on questionnaire answers)
  // NULL = always required
  // Example: { "questionKey": "mortgage_type", "operator": "EQUALS", "value": "JOINT" }
  condition Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([planId])
  @@map("document_definitions")
}

// =============================================================================
// APPROVAL STAGE - Sequential workflow stages for document review (template)
// =============================================================================
// Defines a stage in the approval workflow. Documents flow through stages
// sequentially. Each stage requires a specific organization type to review.
// =============================================================================

model ApprovalStage {
  id     String            @id @default(cuid())
  planId String
  plan   DocumentationPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  name               String // "QShelter Review", "Bank Review"
  order              Int // 1, 2, 3 - sequential order
  organizationTypeId String // Which type of org should review at this stage
  organizationType   OrganizationType @relation(fields: [organizationTypeId], references: [id])

  // Stage behavior flags
  autoTransition       Boolean @default(false) // Auto-complete when all docs approved? Default: require explicit approval
  waitForAllDocuments  Boolean @default(true) // Wait for all docs approved before allowing transition
  allowEarlyVisibility Boolean @default(false) // Allow read-only view before stage activates

  // Rejection behavior - what happens when this stage rejects a document
  onRejection           RejectionBehavior @default(CASCADE_BACK)
  restartFromStageOrder Int? // If onRejection = RESTART_FROM_STAGE, which stage order to restart from

  // SLA (optional)
  slaHours Int? // Escalate if not completed within X hours

  description String? @db.Text // Instructions for reviewers at this stage

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Runtime instances
  stageProgress ApprovalStageProgress[]

  @@unique([planId, order])
  @@index([planId])
  @@index([organizationTypeId])
  @@map("approval_stages")
}

// =============================================================================
// QUESTIONNAIRE PLAN DOMAIN - Reusable form templates with scoring
// =============================================================================
// QuestionnairePlan = reusable structure for prequalification/screening forms
// Examples: "Mortgage Prequalification", "Affordability Assessment", "Risk Screening"
// =============================================================================

model QuestionnairePlan {
  id          String  @id @default(cuid())
  tenantId    String? // NULL = global template available to all tenants
  tenant      Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  description String? @db.Text
  version     Int     @default(1)
  isActive    Boolean @default(true)

  // Scoring configuration
  passingScore        Int? // Minimum score to pass (null = no auto-scoring)
  scoringStrategy     ScoringStrategy @default(SUM)
  autoDecisionEnabled Boolean         @default(false) // Auto-pass/fail based on score

  // Metadata
  estimatedMinutes Int? // Estimated time to complete
  category         QuestionnaireCategory @default(PREQUALIFICATION)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Questions that make up this plan
  questions QuestionnairePlanQuestion[]

  // Used by property payment method phases (templates)
  methodPhases PropertyPaymentMethodPhase[]

  // Used by instantiated questionnaire phases
  questionnairePhases QuestionnairePhase[]

  @@unique([tenantId, name, version])
  @@index([tenantId])
  @@index([category])
  @@map("questionnaire_plans")
}

// Question template within a QuestionnairePlan
model QuestionnairePlanQuestion {
  id                  String            @id @default(cuid())
  questionnairePlanId String
  questionnairePlan   QuestionnairePlan @relation(fields: [questionnairePlanId], references: [id], onDelete: Cascade)

  // Question identification
  questionKey  String // Unique key for this question (e.g., "annual_income")
  questionText String  @db.Text // The actual question text
  helpText     String? @db.Text // Optional help/tooltip text

  // Field configuration
  questionType QuestionType
  order        Int

  // Validation
  isRequired      Boolean @default(true)
  validationRules Json? // { min: 0, max: 1000000, pattern: "^[0-9]+$" }

  // Options for SELECT/MULTI_SELECT/RADIO
  // [{ value: "employed", label: "Employed", score: 10 }, ...]
  options Json?

  // Scoring
  scoreWeight  Int   @default(1) // Multiplier for this question's score
  // ScoringRules format: Array of { operator: ConditionOperator, value: number, score: number }
  // First matching rule wins. Example:
  // [{ operator: "GREATER_THAN_OR_EQUAL", value: 3000000, score: 100 },
  //  { operator: "GREATER_THAN_OR_EQUAL", value: 2000000, score: 80 }]
  scoringRules Json?

  // Conditional logic (branching)
  // { "questionKey": "employment_status", "equals": "employed" }
  showIf Json?

  // Metadata for grouping
  category QuestionCategory? // Group questions by topic

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([questionnairePlanId, questionKey])
  @@index([questionnairePlanId])
  @@map("questionnaire_plan_questions")
}

// =============================================================================
// PAYMENT PLAN DOMAIN - Reusable installment structure templates
// =============================================================================

// PaymentPlan = reusable structure for how payments are scheduled
// Examples: "Monthly360" (360 monthly payments), "Weekly52", "OneTime"
model PaymentPlan {
  id          String  @id @default(cuid())
  tenantId    String? // NULL = global template available to all tenants
  tenant      Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)

  // Structure configuration
  paymentFrequency       PaymentFrequency
  customFrequencyDays    Int?
  numberOfInstallments   Int? // Fixed number (1 for one-time, 360 for 30yr monthly) - NULL if flexible
  calculateInterestDaily Boolean          @default(false)
  gracePeriodDays        Int              @default(0)

  // Flexible term configuration (for user-selectable duration like mortgages)
  // If these are set, numberOfInstallments is ignored and user selects within range
  allowFlexibleTerm Boolean @default(false) // true = user can select term within range
  minTermMonths     Int? // e.g., 60 (5 years minimum)
  maxTermMonths     Int? // e.g., 360 (30 years maximum)
  termStepMonths    Int? // e.g., 12 (increments of 1 year) - NULL = any month allowed

  // Age-based constraints (for mortgage eligibility)
  maxAgeAtMaturity Int? // e.g., 65 - user's age + term cannot exceed this

  // Fund collection behavior
  // true = we collect funds via wallet/gateway (e.g., downpayment)
  // false = external payment, we only track/reconcile (e.g., bank mortgage)
  collectFunds Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Used by property payment method phases (templates)
  methodPhases  PropertyPaymentMethodPhase[]
  // Used by instantiated payment phases
  paymentPhases PaymentPhase[]

  @@unique([tenantId, name]) // Unique per tenant, or globally if tenantId is null
  @@index([tenantId])
  @@map("payment_plans")
}

// =============================================================================
// PROPERTY PAYMENT METHOD DOMAIN - Product offerings per property
// =============================================================================

// PropertyPaymentMethod = how a property can be purchased (e.g., "Standard Mortgage", "Cash", "Rent-to-Own")
model PropertyPaymentMethod {
  id          String  @id @default(cuid())
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name        String // "Standard Mortgage", "Flexible Payment", "Cash Purchase"
  description String? @db.Text
  isActive    Boolean @default(true)

  // Global method configuration
  allowEarlyPayoff       Boolean @default(true)
  earlyPayoffPenaltyRate Float?
  autoActivatePhases     Boolean @default(true)
  requiresManualApproval Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Many-to-many with properties
  properties   PropertyPaymentMethodLink[]
  // Phases that make up this method (templates)
  phases       PropertyPaymentMethodPhase[]
  // Contracts using this method
  applications Application[]

  // Payment method change tracking
  changeRequestsFrom PaymentMethodChangeRequest[] @relation("ChangeFromMethod")
  changeRequestsTo   PaymentMethodChangeRequest[] @relation("ChangeToMethod")

  // Document requirement rules
  documentRules   DocumentRequirementRule[] @relation("RulePaymentMethod")
  changeRulesFrom DocumentRequirementRule[] @relation("RuleFromMethod")
  changeRulesTo   DocumentRequirementRule[] @relation("RuleToMethod")

  @@unique([tenantId, name]) // Unique per tenant
  @@index([tenantId])
  @@map("property_payment_methods")
}

// Many-to-many link between Property and PaymentMethod
model PropertyPaymentMethodLink {
  tenantId        String
  tenant          Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  propertyId      String
  property        Property              @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  paymentMethodId String
  paymentMethod   PropertyPaymentMethod @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)

  // Method-specific overrides for this property
  isDefault Boolean  @default(false)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  @@id([propertyId, paymentMethodId])
  @@index([tenantId])
  @@map("property_payment_method_links")
}

// Phase template within a PropertyPaymentMethod (e.g., documentation, downpayment, mortgage)
// phaseCategory determines the FSM type: DOCUMENTATION or PAYMENT
model PropertyPaymentMethodPhase {
  id              String                @id @default(cuid())
  tenantId        String
  tenant          Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  paymentMethodId String
  paymentMethod   PropertyPaymentMethod @relation(fields: [paymentMethodId], references: [id], onDelete: Cascade)

  // Plan references (only one should be set based on phaseCategory)
  paymentPlanId       String? // Only for PAYMENT phases
  paymentPlan         PaymentPlan?       @relation(fields: [paymentPlanId], references: [id])
  documentationPlanId String? // Only for DOCUMENTATION phases
  documentationPlan   DocumentationPlan? @relation(fields: [documentationPlanId], references: [id])
  questionnairePlanId String? // Only for QUESTIONNAIRE phases
  questionnairePlan   QuestionnairePlan? @relation(fields: [questionnairePlanId], references: [id])

  name        String
  description String? @db.Text

  // Phase classification (DB-enforced enums)
  phaseCategory PhaseCategory
  phaseType     PhaseType
  order         Int

  // Financial configuration (for PAYMENT phases)
  interestRate   Float?
  percentOfPrice Float? // e.g., 10.0 for 10% downpayment

  // Fund collection behavior (inherited from PaymentPlan if not set)
  // true = we collect funds via wallet/gateway (e.g., downpayment)
  // false = external payment, we only track/reconcile (e.g., bank mortgage)
  collectFunds Boolean? // null = inherit from PaymentPlan

  // Activation rules
  requiresPreviousPhaseCompletion Boolean              @default(true)
  minimumCompletionPercentage     Float?
  completionCriterion             CompletionCriterion?

  // Unit locking configuration
  // If true, completing this phase locks the unit for the applicant
  // Only one phase per payment method should have this enabled
  lockUnitOnComplete Boolean @default(false)

  // Snapshots for audit (original config at creation time)
  // These are still needed for inline definitions (backward compatibility)
  stepDefinitionsSnapshot  Json?
  requiredDocumentSnapshot Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Normalized child tables (for DOCUMENTATION phases - inline definitions)
  steps               PaymentMethodPhaseStep[]
  requiredDocuments   PaymentMethodPhaseDocument[]
  // Normalized child tables (for QUESTIONNAIRE phases)
  questionnaireFields PaymentMethodPhaseField[]
  // Event attachments - handlers that fire on phase transitions
  eventAttachments    PhaseEventAttachment[]
  // Application phases created from this template
  applicationPhases   ApplicationPhase[]
  // Bank-specific document requirements for this phase
  bankDocumentRequirements BankDocumentRequirement[]

  @@unique([paymentMethodId, order]) // Enforce unique, sequential ordering
  @@index([tenantId])
  @@index([paymentMethodId])
  @@index([paymentPlanId])
  @@index([documentationPlanId])
  @@index([questionnairePlanId])
  @@index([phaseCategory])
  @@map("property_payment_method_phases")
}

/// Phase Event Attachment - Links event handlers to phase template triggers
/// When a phase transitions (complete, payment received, etc.), attached handlers fire
model PhaseEventAttachment {
  id       String                     @id @default(cuid())
  tenantId String
  tenant   Tenant                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String
  phase    PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  /// When this handler should fire
  trigger PhaseTrigger

  /// The event handler to execute
  handlerId String
  handler   EventHandler @relation(fields: [handlerId], references: [id], onDelete: Cascade)

  /// Order of execution (lower = first)
  priority Int @default(100)

  /// Whether this attachment is active
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([phaseId, handlerId, trigger])
  @@index([tenantId])
  @@index([phaseId])
  @@index([handlerId])
  @@map("phase_event_attachments")
}

// Step template within a DOCUMENTATION phase
model PaymentMethodPhaseStep {
  id       String                     @id @default(cuid())
  tenantId String
  tenant   Tenant                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String
  phase    PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  name     String
  stepType StepType
  order    Int

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Event attachments - handlers that fire on step transitions
  eventAttachments StepEventAttachment[]

  @@unique([phaseId, order]) // Enforce unique, sequential ordering within phase
  @@index([tenantId])
  @@index([phaseId])
  @@map("payment_method_phase_steps")
}

/// Step Event Attachment - Links event handlers to step template triggers
/// When a step transitions (complete, reject, etc.), attached handlers fire
model StepEventAttachment {
  id       String                 @id @default(cuid())
  tenantId String
  tenant   Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  stepId   String
  step     PaymentMethodPhaseStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  /// When this handler should fire
  trigger StepTrigger

  /// The event handler to execute
  handlerId String
  handler   EventHandler @relation(fields: [handlerId], references: [id], onDelete: Cascade)

  /// Order of execution (lower = first)
  priority Int @default(100)

  /// Whether this attachment is active
  enabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([stepId, handlerId, trigger])
  @@index([tenantId])
  @@index([stepId])
  @@index([handlerId])
  @@map("step_event_attachments")
}

// Required document within a DOCUMENTATION phase
model PaymentMethodPhaseDocument {
  id       String                     @id @default(cuid())
  tenantId String
  tenant   Tenant                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String
  phase    PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  documentType     String
  isRequired       Boolean @default(true)
  description      String? @db.Text
  allowedMimeTypes String? // CSV: application/pdf,image/jpeg
  maxSizeBytes     Int?

  metadata  Json?
  createdAt DateTime @default(now())

  @@index([tenantId])
  @@index([phaseId, documentType])
  @@map("payment_method_phase_documents")
}

// =============================================================================
// QUESTIONNAIRE FIELD TYPES - For QUESTIONNAIRE phases
// =============================================================================

enum FieldType {
  TEXT // Short text input
  TEXTAREA // Long text input
  NUMBER // Numeric input (with optional min/max)
  CURRENCY // Currency input (validated as money)
  EMAIL // Email validation
  PHONE // Phone number validation
  DATE // Date picker
  SELECT // Dropdown/single select
  MULTI_SELECT // Multiple selection
  CHECKBOX // Boolean yes/no
  RADIO // Radio button group
  FILE // File upload (single)
}

// =============================================================================
// QUESTIONNAIRE PLAN ENUMS - For scoring and categorization
// =============================================================================

enum QuestionType {
  TEXT
  NUMBER
  CURRENCY
  DATE
  SELECT
  MULTI_SELECT
  RADIO
  CHECKBOX
  FILE_UPLOAD
  PHONE
  EMAIL
  ADDRESS
  PERCENTAGE
  YEARS_MONTHS
}

enum ScoringStrategy {
  SUM // Add up all scores
  AVERAGE // Average of all scores
  WEIGHTED_SUM // Sum with weights (score * weight)
  MIN_ALL // Must meet minimum on all questions
  CUSTOM // Use custom scoring function
}

enum QuestionnaireCategory {
  PREQUALIFICATION // Initial eligibility screening
  AFFORDABILITY // Income/expense assessment
  PROPERTY_INTENT // What property are they looking for
  RISK_ASSESSMENT // Credit/risk questions
  COMPLIANCE // KYC/AML questions
  CUSTOM
}

/// Category for individual questions within a questionnaire
/// Used to group questions by topic for UI/UX and scoring
enum QuestionCategory {
  ELIGIBILITY // Age, citizenship, legal status
  EMPLOYMENT // Employment status, employer details
  INCOME // Salary, bonuses, other income
  AFFORDABILITY // Income vs expenses, debt-to-income
  EXPENSES // Monthly expenses, existing debts
  APPLICATION_TYPE // Type of mortgage/purchase (single, joint)
  PERSONAL // Marital status, dependents, contact info
  PREFERENCES // Preferred terms, property type preferences
  PROPERTY // Property-related questions
  CREDIT // Credit history, existing loans
  ASSETS // Savings, investments, other assets
  CUSTOM // Custom/uncategorized questions
}

// Questionnaire field template within a QUESTIONNAIRE phase
model PaymentMethodPhaseField {
  id       String                     @id @default(cuid())
  tenantId String
  tenant   Tenant                     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String
  phase    PropertyPaymentMethodPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  // Field identification
  name        String // Internal field name (e.g., "monthly_income")
  label       String // Display label (e.g., "Monthly Income")
  description String? @db.Text // Help text for the field
  placeholder String? // Placeholder text

  // Field configuration
  fieldType  FieldType
  isRequired Boolean   @default(true)
  order      Int

  // Validation rules (JSON schema-like)
  // Examples:
  // NUMBER: { "min": 0, "max": 1000000 }
  // TEXT: { "minLength": 2, "maxLength": 100, "pattern": "^[A-Za-z]+$" }
  // SELECT: { "options": [{"value": "employed", "label": "Employed"}, ...] }
  // DATE: { "minDate": "now", "maxDate": "+30d" }
  validation Json?

  // For conditional display (e.g., show if another field has a certain value)
  // { "field": "employment_status", "operator": "equals", "value": "employed" }
  displayCondition Json?

  // Default value (JSON to support any type)
  defaultValue Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([phaseId, name])
  @@index([tenantId])
  @@index([phaseId])
  @@map("payment_method_phase_fields")
}

// =============================================================================
// CONTRACT DOMAIN - Unified agreement model (replaces Mortgage, PurchasePlan, etc.)
// =============================================================================
// Application is the canonical agreement. "Mortgage" is just a product configuration
// that creates an Application with specific phases (documentation, downpayment, long-term payment).
// Phases can be QUESTIONNAIRE, DOCUMENTATION, or PAYMENT.
// =============================================================================

model Application {
  id              String                 @id @default(cuid())
  tenantId        String
  tenant          Tenant                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  // Link to specific unit being purchased/rented
  propertyUnitId  String
  propertyUnit    PropertyUnit           @relation(fields: [propertyUnitId], references: [id], onDelete: Restrict)
  buyerId         String
  buyer           User                   @relation("ApplicationBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  sellerId        String?
  seller          User?                  @relation("ApplicationSeller", fields: [sellerId], references: [id])
  paymentMethodId String? // PropertyPaymentMethod used to create this contract
  paymentMethod   PropertyPaymentMethod? @relation(fields: [paymentMethodId], references: [id])

  // =========================================================================
  // PAYMENT METHOD VERSION SNAPSHOT
  // =========================================================================
  // Captures the payment method configuration at application creation time.
  // This ensures existing applications continue with original terms even if
  // the payment method template is later modified.
  // =========================================================================
  paymentMethodSnapshot     Json? // Full snapshot of PropertyPaymentMethod + phases at creation
  paymentMethodSnapshotAt   DateTime? // When the snapshot was taken
  paymentMethodSnapshotHash String? // Hash to detect if template changed since snapshot

  // Contract identification
  applicationNumber String  @unique
  title             String
  description       String? @db.Text
  applicationType   String // Admin-defined: MORTGAGE, INSTALLMENT, RENT_TO_OWN, CASH, LEASE, etc.

  // Contract value (negotiated from unit price)
  totalAmount Float

  // FSM state (DB-enforced enum)
  status         ApplicationStatus @default(DRAFT)
  currentPhaseId String?
  currentPhase   ApplicationPhase? @relation("CurrentPhase", fields: [currentPhaseId], references: [id])

  // Timing
  nextPaymentDueDate DateTime?
  lastReminderSentAt DateTime?
  startDate          DateTime?
  endDate            DateTime?
  signedAt           DateTime?
  terminatedAt       DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  phases       ApplicationPhase[]
  documents    ApplicationDocument[]
  payments     ApplicationPayment[]
  terminations ApplicationTermination[]
  offerLetters OfferLetter[]

  // Payment method change requests for this contract
  paymentMethodChangeRequests PaymentMethodChangeRequest[]

  // Transfer tracking - when a contract is transferred to a different property
  transferredFromId String?      @unique // Source contract if this was created via transfer
  transferredFrom   Application? @relation("ApplicationTransfer", fields: [transferredFromId], references: [id])
  transferredTo     Application? @relation("ApplicationTransfer")

  // Supersede tracking - when another buyer locks the unit
  // If status is SUPERSEDED, this references the application that took the unit
  supersededById         String?
  supersededBy           Application?  @relation("ApplicationSuperseded", fields: [supersededById], references: [id])
  supersededAt           DateTime?
  supersededApplications Application[] @relation("ApplicationSuperseded")

  // Transfer requests where this contract is the source
  outgoingTransferRequests PropertyTransferRequest[] @relation("SourceApplication")
  // Transfer requests where this contract is the target (created after approval)
  incomingTransferRequests PropertyTransferRequest[] @relation("TargetApplication")

  // Audit trail
  events ApplicationEvent[]

  // Refund requests
  refunds ApplicationRefund[]

  // Organization assignments - which orgs are involved in this application
  organizations ApplicationOrganization[]

  @@index([tenantId])
  @@index([propertyUnitId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([paymentMethodId])
  @@index([status])
  @@index([currentPhaseId])
  @@index([supersededById])
  @@map("applications")
}

// =============================================================================
// APPLICATION ORGANIZATION - Binds organizations to specific applications
// =============================================================================
// Tracks which organizations (banks, developers, legal firms) are involved
// in a specific application. This enables:
// 1. Validation that only assigned developers can upload sales offers
// 2. Only assigned banks can upload preapproval/mortgage offer letters
// 3. Flexible type-based assignment (org assigned acting as specific type)
// =============================================================================

/// Status of organization's involvement in the application
enum ApplicationOrganizationStatus {
  PENDING // Awaiting organization's response/engagement
  ACTIVE // Organization is actively participating
  COMPLETED // Organization's role is complete
  DECLINED // Organization declined to participate
  WITHDRAWN // Organization withdrew from the application
}

model ApplicationOrganization {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // Which organization is involved
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // Which type the org is acting as on this application
  // (org must have this type in their OrganizationTypeAssignment)
  assignedAsTypeId String
  assignedAsType   OrganizationType @relation(fields: [assignedAsTypeId], references: [id])

  status ApplicationOrganizationStatus @default(PENDING)

  // Who assigned this organization (admin or system)
  assignedById String?
  assignedAt   DateTime @default(now())

  // For multi-bank applications: track if this is the selected lender
  // Multiple banks can be PENDING, but only one should be ACTIVE for LENDER role
  isPrimary Boolean @default(false)

  // Organization-specific terms (e.g., bank's offered interest rate)
  offeredTerms    Json? // { interestRate, termMonths, conditions, etc. }
  termsOfferedAt  DateTime?
  termsAcceptedAt DateTime?
  termsDeclinedAt DateTime?
  declineReason   String?   @db.Text

  // Tracking
  activatedAt DateTime?
  completedAt DateTime?
  withdrawnAt DateTime?

  // =========================================================================
  // SLA TRACKING - Monitor bank responsiveness
  // =========================================================================
  // When documentation is complete, clock starts for bank to respond.
  // If they're slow, admin can reassign to another bank.
  // =========================================================================
  slaHours          Int? // Expected response time (e.g., 48 hours)
  slaStartedAt      DateTime? // When clock started (e.g., when docs were complete)
  slaBreachedAt     DateTime? // When SLA was breached (set by cron job)
  slaBreachNotified Boolean   @default(false) // Was admin notified of breach?

  // Reminder tracking
  reminderCount      Int       @default(0)
  lastReminderSentAt DateTime?
  nextReminderAt     DateTime?

  // Escalation
  escalatedAt       DateTime?
  escalatedToUserId String? // Admin handling the escalation
  escalationNotes   String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([applicationId, assignedAsTypeId]) // One org per type per application
  @@index([tenantId])
  @@index([applicationId])
  @@index([organizationId])
  @@index([assignedAsTypeId])
  @@index([status])
  @@index([isPrimary])
  @@index([slaBreachedAt])
  @@map("application_organizations")
}

// =============================================================================
// CONTRACT REFUNDS - Track refund requests for overpayments or cancellations
// =============================================================================
model ApplicationRefund {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  amount Float
  reason String       @db.Text
  status RefundStatus @default(PENDING)

  // Who requested the refund
  requestedById String
  requestedBy   User   @relation("RefundRequester", fields: [requestedById], references: [id])

  // Who approved/rejected the refund
  approvedById String?
  approvedBy   User?   @relation("RefundApprover", fields: [approvedById], references: [id])

  // Who processed the refund (finance team)
  processedById String?
  processedBy   User?   @relation("RefundProcessor", fields: [processedById], references: [id])

  // Refund payment details
  paymentMethod    String? // BANK_TRANSFER, CHEQUE, MOBILE_MONEY, etc.
  referenceNumber  String? // Bank/payment reference
  recipientName    String?
  recipientAccount String?
  recipientBank    String?

  // Timestamps
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  rejectedAt  DateTime?
  processedAt DateTime?

  // Additional notes
  approvalNotes   String? @db.Text
  rejectionNotes  String? @db.Text
  processingNotes String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
  @@index([status])
  @@index([tenantId])
  @@index([requestedById])
  @@map("application_refunds")
}

// Phase within a contract - can be DOCUMENTATION or PAYMENT type
// Admin names phases freely (e.g., "KYC Documents", "Downpayment", "Monthly Mortgage")
// =============================================================================
// CONTRACT PHASE - Base model with polymorphic extensions
// =============================================================================
// ApplicationPhase is the base table with shared fields only.
// Each phase has exactly ONE extension table based on phaseCategory:
// - QUESTIONNAIRE  QuestionnairePhase
// - DOCUMENTATION  DocumentationPhase
// - PAYMENT  PaymentPhase
// This eliminates nullable field pollution and makes the schema self-documenting.
// =============================================================================

model ApplicationPhase {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // Reference to the phase template this was instantiated from
  phaseTemplateId String?
  phaseTemplate   PropertyPaymentMethodPhase? @relation(fields: [phaseTemplateId], references: [id], onDelete: SetNull)

  // Admin-defined naming
  name        String
  description String? @db.Text

  // Phase classification (DB-enforced enums)
  phaseCategory PhaseCategory
  phaseType     PhaseType
  order         Int

  // FSM state for this phase (DB-enforced enum)
  status PhaseStatus @default(PENDING)

  // Timing (shared across all phase types)
  dueDate     DateTime?
  startDate   DateTime?
  endDate     DateTime?
  activatedAt DateTime?
  completedAt DateTime?

  // Activation rules (shared)
  requiresPreviousPhaseCompletion Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Polymorphic extensions (exactly one will be populated based on phaseCategory)
  questionnairePhase QuestionnairePhase?
  documentationPhase DocumentationPhase?
  paymentPhase       PaymentPhase?

  // Payments can be linked to any phase type (for tracking)
  payments ApplicationPayment[]

  // Back-relation for applications where this is the current phase
  currentForApplications Application[] @relation("CurrentPhase")

  @@index([tenantId])
  @@index([applicationId])
  @@index([phaseTemplateId])
  @@index([phaseCategory])
  @@index([status])
  @@index([order])
  @@map("application_phases")
}

// =============================================================================
// QUESTIONNAIRE PHASE DATA - Extension for QUESTIONNAIRE phases
// =============================================================================
// Collects form data from users (eligibility, pre-approval, underwriting inputs)
// =============================================================================

model QuestionnairePhase {
  id       String           @id @default(cuid())
  tenantId String
  tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String           @unique
  phase    ApplicationPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  // Questionnaire plan reference (if created from a plan)
  questionnairePlanId String?
  questionnairePlan   QuestionnairePlan? @relation(fields: [questionnairePlanId], references: [id])

  // Progress tracking
  completedFieldsCount Int @default(0)
  totalFieldsCount     Int @default(0)

  // Scoring results (from QuestionnairePlan scoring)
  totalScore   Int?
  passingScore Int? // Copied from plan at creation
  passed       Boolean?
  scoredAt     DateTime?

  // Computed results (for UNDERWRITING phases)
  underwritingScore    Float?
  debtToIncomeRatio    Float?
  underwritingDecision String? // APPROVED, CONDITIONAL, DECLINED
  underwritingNotes    String? @db.Text

  // Snapshot of field definitions at creation
  fieldsSnapshot Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Child records
  fields QuestionnaireField[]

  // Review audit trail
  reviews QuestionnairePhaseReview[]

  // Back-relation: Documentation phases that use this questionnaire's answers for conditions
  dependentDocumentationPhases DocumentationPhase[] @relation("SourceQuestionnaire")

  @@index([tenantId])
  @@index([phaseId])
  @@index([questionnairePlanId])
  @@map("questionnaire_phases")
}

// =============================================================================
// QUESTIONNAIRE PHASE REVIEW - Audit trail for questionnaire reviews
// =============================================================================
// Captures every review decision made on a questionnaire phase.
// Supports workflows where questionnaire may be rejected  resubmitted  approved.
// The scoring serves as guidance; reviewer makes the final decision.
// =============================================================================

model QuestionnairePhaseReview {
  id                   String             @id @default(cuid())
  tenantId             String
  tenant               Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  questionnairePhaseId String
  questionnairePhase   QuestionnairePhase @relation(fields: [questionnairePhaseId], references: [id], onDelete: Cascade)

  // Review details
  reviewerId String
  reviewer   User           @relation("QuestionnaireReviewer", fields: [reviewerId], references: [id])
  decision   ReviewDecision
  notes      String?        @db.Text

  // Snapshot of scores at time of review (for audit)
  scoreAtReview  Int? // The totalScore when this review was made
  passedAtReview Boolean? // The passed flag when this review was made

  createdAt DateTime @default(now())

  @@index([tenantId])
  @@index([questionnairePhaseId])
  @@index([reviewerId])
  @@map("questionnaire_phase_reviews")
}

// =============================================================================
// DOCUMENTATION PHASE DATA - Extension for DOCUMENTATION phases
// =============================================================================
// Manages document upload/approval workflow with sequential approval stages
// =============================================================================

model DocumentationPhase {
  id       String           @id @default(cuid())
  tenantId String
  tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String           @unique
  phase    ApplicationPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  // Documentation plan reference (if created from a plan)
  documentationPlanId String?
  documentationPlan   DocumentationPlan? @relation(fields: [documentationPlanId], references: [id])

  // Source questionnaire for conditional document evaluation
  // Links to the questionnaire phase whose answers determine which documents are required
  sourceQuestionnairePhaseId String?
  sourceQuestionnairePhase   QuestionnairePhase? @relation("SourceQuestionnaire", fields: [sourceQuestionnairePhaseId], references: [id])

  // Current approval stage pointer for UX and orchestration
  currentStageOrder Int @default(1)

  // Progress counters
  approvedDocumentsCount Int @default(0)
  requiredDocumentsCount Int @default(0)

  // Snapshots for audit
  documentDefinitionsSnapshot Json?
  approvalStagesSnapshot      Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Approval stage progress (tracks which stages are completed)
  stageProgress ApprovalStageProgress[]

  @@index([tenantId])
  @@index([phaseId])
  @@index([sourceQuestionnairePhaseId])
  @@map("documentation_phases")
}

// =============================================================================
// PAYMENT PHASE DATA - Extension for PAYMENT phases
// =============================================================================
// Manages installment-based payment collection
// =============================================================================

model PaymentPhase {
  id       String           @id @default(cuid())
  tenantId String
  tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  phaseId  String           @unique
  phase    ApplicationPhase @relation(fields: [phaseId], references: [id], onDelete: Cascade)

  // Payment plan reference
  paymentPlanId String?
  paymentPlan   PaymentPlan? @relation(fields: [paymentPlanId], references: [id])

  // Financial details
  totalAmount  Float
  paidAmount   Float @default(0)
  interestRate Float @default(0)

  // User-selected term (for flexible-term plans like mortgages)
  // These are set when user selects their preferred term at application time
  selectedTermMonths   Int? // User's chosen term (e.g., 240 for 20 years)
  numberOfInstallments Int? // Calculated from selectedTermMonths and frequency

  // Fund collection behavior
  // true = we collect funds via wallet/gateway (e.g., downpayment)
  // false = external payment, we only track/reconcile (e.g., bank mortgage)
  collectFunds Boolean @default(true)

  // Completion criteria
  minimumCompletionPercentage Float?

  // Snapshot for audit
  paymentPlanSnapshot Json?

  // Optimistic locking for concurrent payment protection
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Child records
  installments PaymentInstallment[]

  @@index([tenantId])
  @@index([phaseId])
  @@index([paymentPlanId])
  @@map("payment_phases")
}

// =============================================================================
// QUESTIONNAIRE FIELDS - Instantiated fields within QUESTIONNAIRE phases
// =============================================================================
// When a contract is created from a payment method template, questionnaire field
// templates are copied to QuestionnaireField records. Users submit answers here.
// =============================================================================

model QuestionnaireField {
  id                   String             @id @default(cuid())
  tenantId             String
  tenant               Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  questionnairePhaseId String
  questionnairePhase   QuestionnairePhase @relation(fields: [questionnairePhaseId], references: [id], onDelete: Cascade)

  // Field identification (copied from template)
  name        String // Internal field name (e.g., "monthly_income")
  label       String // Display label (e.g., "Monthly Income")
  description String? @db.Text
  placeholder String?

  // Field configuration (copied from template)
  fieldType  FieldType
  isRequired Boolean   @default(true)
  order      Int

  // Validation rules (copied from template)
  validation       Json?
  displayCondition Json?
  defaultValue     Json?

  // User's submitted answer (JSON to support any type)
  // TEXT: "John Doe"
  // NUMBER/CURRENCY: 500000
  // SELECT: "employed"
  // MULTI_SELECT: ["option1", "option2"]
  // CHECKBOX: true
  // DATE: "2024-01-15"
  answer Json?

  // Validation status
  isValid          Boolean @default(false)
  validationErrors Json? // Array of error messages if invalid

  // Timestamps
  submittedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([questionnairePhaseId, name])
  @@index([tenantId])
  @@index([questionnairePhaseId])
  @@map("questionnaire_fields")
}

// =============================================================================
// CONTRACT EVENTS - Audit trail for contract lifecycle
// =============================================================================
// Tracks all significant events in a contract's lifecycle for audit, compliance,
// and debugging. Unlike DomainEvent (which is for inter-service communication),
// ApplicationEvent is purely for historical tracking and state machine transitions.
// =============================================================================
model ApplicationEvent {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // Event classification
  eventType  ApplicationEventType
  eventGroup ApplicationEventGroup?

  // For state transitions (optional - only populated for APPLICATION_STATE_CHANGED events)
  fromState String?
  toState   String?
  trigger   String?

  // Event payload (all event-specific data)
  data Json?

  // Actor tracking
  actorId   String?
  actorType EventActorType?

  // Timing
  occurredAt DateTime @default(now())

  @@index([tenantId])
  @@index([applicationId])
  @@index([eventType])
  @@index([eventGroup])
  @@index([occurredAt])
  @@map("application_events")
}

// Installments within a PAYMENT phase
model PaymentInstallment {
  id             String       @id @default(cuid())
  tenantId       String
  tenant         Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  paymentPhaseId String
  paymentPhase   PaymentPhase @relation(fields: [paymentPhaseId], references: [id], onDelete: Cascade)

  installmentNumber Int

  amount          Float
  principalAmount Float @default(0)
  interestAmount  Float @default(0)

  dueDate DateTime
  status  InstallmentStatus @default(PENDING)

  paidAmount Float     @default(0)
  paidDate   DateTime?

  lateFee            Float     @default(0)
  lateFeeWaived      Boolean   @default(false)
  gracePeriodDays    Int       @default(0)
  gracePeriodEndDate DateTime?

  // Optimistic locking for concurrent payment protection
  version Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  payments ApplicationPayment[]

  @@index([tenantId])
  @@index([paymentPhaseId])
  @@index([dueDate])
  @@index([status])
  @@map("payment_installments")
}

// Unified payment record for contracts
model ApplicationPayment {
  id            String              @id @default(cuid())
  tenantId      String
  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application         @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  phaseId       String?
  phase         ApplicationPhase?   @relation(fields: [phaseId], references: [id])
  installmentId String?
  installment   PaymentInstallment? @relation(fields: [installmentId], references: [id])
  payerId       String?
  payer         User?               @relation("ApplicationPayer", fields: [payerId], references: [id])

  amount          Float
  principalAmount Float @default(0)
  interestAmount  Float @default(0)
  lateFeeAmount   Float @default(0)

  paymentMethod String // BANK_TRANSFER, CREDIT_CARD, WALLET, CASH, CHECK
  status        PaymentStatus @default(INITIATED)

  reference       String? @unique
  gatewayResponse String? @db.Text // JSON

  processedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([tenantId])
  @@index([applicationId])
  @@index([phaseId])
  @@index([installmentId])
  @@index([payerId])
  @@index([status])
  @@index([reference])
  @@map("application_payments")
}

// Contract documents (owned by contract, linked to phases/steps as needed)
model ApplicationDocument {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  phaseId       String? // Optional link to specific phase
  stepId        String? // Optional link to specific step

  // Document info
  documentType String? // ID_CARD, BANK_STATEMENT, etc. (matches DocumentDefinition.documentType)
  documentName String? // Human-readable name (copied from DocumentDefinition.documentName)
  name         String // File name
  url          String
  type         String // ID, BANK_STATEMENT, INCOME_PROOF, TITLE_DEED, SIGNATURE, etc. (legacy, use documentType)
  uploadedById String?
  uploadedBy   User?   @relation("DocumentUploader", fields: [uploadedById], references: [id])

  // =========================================================================
  // UPLOADER VALIDATION - Enforces who can upload this document
  // =========================================================================
  // expectedUploader is set from DocumentDefinition.uploadedBy at phase creation
  // Allows validation that correct party is uploading (e.g., developer uploads sales offer)
  expectedUploader       UploadedBy? // CUSTOMER, LENDER, DEVELOPER, LEGAL, PLATFORM, etc.
  // If expectedUploader is LENDER/DEVELOPER, track which org should upload
  expectedOrganizationId String?

  // =========================================================================
  // DOCUMENT EXPIRY - Time-sensitive document tracking
  // =========================================================================
  // Documents like bank statements have a shelf life. If application takes too long,
  // documents may need to be re-uploaded.
  // =========================================================================
  documentDate    DateTime? // When the document was issued/created (e.g., bank statement date)
  expiresAt       DateTime? // When this document expires (computed from documentDate + expiryDays)
  expiryDays      Int? // Number of days this document type is valid (copied from DocumentDefinition)
  isExpired       Boolean   @default(false) // Denormalized flag, updated by cron job
  expiredAt       DateTime? // When the document was marked expired
  expiryWarningAt DateTime? // When expiry warning was sent
  revalidatedAt   DateTime? // If document was re-uploaded after expiry

  status DocumentStatus @default(PENDING)

  // NO versioning - document is replaced on re-upload (url is updated)
  // Keep these fields for backward compatibility but don't use for new code
  version            Int                   @default(1)
  replacesDocumentId String? // If this is a revision, points to original
  replacesDocument   ApplicationDocument?  @relation("DocumentRevisions", fields: [replacesDocumentId], references: [id])
  revisions          ApplicationDocument[] @relation("DocumentRevisions")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // OLD: Multi-party reviews (deprecated, use approvalTrail)
  reviews DocumentReview[]

  // NEW: Full approval trail across all stages
  approvalTrail DocumentApproval[]

  @@index([tenantId])
  @@index([applicationId])
  @@index([phaseId])
  @@index([stepId])
  @@index([type])
  @@index([documentType])
  @@index([status])
  @@index([replacesDocumentId])
  @@index([isExpired])
  @@index([expiresAt])
  @@map("application_documents")
}

// =============================================================================
// DOCUMENT REVIEW - Multi-party review tracking
// =============================================================================
// Tracks reviews by different organizations for the same document.
// organizationId is NULL for customer self-attestations/signatures.
// For org reviews, organizationTypeId captures which type the org was acting as.
// =============================================================================

model DocumentReview {
  id         String              @id @default(cuid())
  tenantId   String
  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  documentId String
  document   ApplicationDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Who is reviewing - NULL organizationId means customer self-review
  organizationId     String? // Organization performing the review (null = customer)
  organization       Organization?     @relation(fields: [organizationId], references: [id])
  organizationTypeId String? // Which type the org was acting as (audit snapshot)
  organizationType   OrganizationType? @relation(fields: [organizationTypeId], references: [id])
  reviewerId         String? // User who performed the review
  reviewer           User?             @relation("DocumentReviewer", fields: [reviewerId], references: [id])
  reviewerName       String? // Denormalized for audit trail

  // Review state
  decision ReviewDecision @default(PENDING)
  comments String?        @db.Text // General comments

  // Structured concerns for change requests
  // Format: [{ field: "income_period", issue: "Missing months April-June" }]
  concerns Json?

  // Review timing
  requestedAt DateTime  @default(now())
  dueAt       DateTime? // Optional deadline for this party
  reviewedAt  DateTime? // When decision was made

  // Review sequence (which order should parties review?)
  reviewOrder Int @default(0) // 0 = parallel, 1/2/3 = sequential

  // For review chains (re-reviews after changes)
  parentReviewId String? // If this is a re-review after changes
  parentReview   DocumentReview?  @relation("ReviewChain", fields: [parentReviewId], references: [id])
  childReviews   DocumentReview[] @relation("ReviewChain")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique: one review per org per doc (null org = customer review)
  @@unique([documentId, organizationId])
  @@index([tenantId])
  @@index([documentId])
  @@index([organizationId])
  @@index([organizationTypeId])
  @@index([decision])
  @@index([reviewerId])
  @@index([parentReviewId])
  @@map("document_reviews")
}

// =============================================================================
// APPROVAL STAGE PROGRESS - Runtime tracking of stage completion per phase
// =============================================================================
// Tracks the progress of each approval stage within a documentation phase.
// Created when a documentation phase is instantiated from a plan.
// =============================================================================

model ApprovalStageProgress {
  id                   String             @id @default(cuid())
  tenantId             String
  tenant               Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  documentationPhaseId String
  documentationPhase   DocumentationPhase @relation(fields: [documentationPhaseId], references: [id], onDelete: Cascade)

  // Link to template
  approvalStageId String
  approvalStage   ApprovalStage @relation(fields: [approvalStageId], references: [id])

  // Stage info (denormalized for convenience)
  name               String
  order              Int
  organizationTypeId String // Which type of org should review at this stage
  organizationType   OrganizationType @relation(fields: [organizationTypeId], references: [id])

  // Behavior flags (copied from template)
  autoTransition       Boolean @default(false)
  waitForAllDocuments  Boolean @default(true)
  allowEarlyVisibility Boolean @default(false)

  // Rejection behavior (copied from template)
  onRejection           RejectionBehavior @default(CASCADE_BACK)
  restartFromStageOrder Int?

  // Status tracking
  status      StageStatus @default(PENDING)
  activatedAt DateTime?
  completedAt DateTime?

  // Who completed this stage (when autoTransition = false)
  completedById     String?
  completedBy       User?   @relation("StageCompletedBy", fields: [completedById], references: [id])
  transitionComment String? @db.Text // Optional comment when completing stage

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Document approvals made during this stage
  documentApprovals DocumentApproval[]

  @@unique([documentationPhaseId, order])
  @@index([tenantId])
  @@index([documentationPhaseId])
  @@index([approvalStageId])
  @@index([status])
  @@map("approval_stage_progress")
}

// =============================================================================
// DOCUMENT APPROVAL - Audit trail for document reviews per stage
// =============================================================================
// Records every review action taken on a document within a specific stage.
// Provides full audit trail: who reviewed, what decision, when, with comments.
// =============================================================================

model DocumentApproval {
  id         String              @id @default(cuid())
  tenantId   String
  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  documentId String
  document   ApplicationDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  // Which stage this approval belongs to
  stageProgressId String
  stageProgress   ApprovalStageProgress @relation(fields: [stageProgressId], references: [id], onDelete: Cascade)

  // Reviewer info
  reviewerId         String
  reviewer           User             @relation("DocumentApprovalReviewer", fields: [reviewerId], references: [id])
  organizationTypeId String // Which type the reviewer's org was acting as
  organizationType   OrganizationType @relation(fields: [organizationTypeId], references: [id])

  // Decision
  decision ReviewDecision // APPROVED, REJECTED, CHANGES_REQUESTED
  comment  String?        @db.Text // Required on rejection

  reviewedAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([tenantId])
  @@index([documentId])
  @@index([stageProgressId])
  @@index([reviewerId])
  @@index([organizationTypeId])
  @@index([decision])
  @@map("document_approvals")
}

// =============================================================================
// OFFER LETTERS - Provisional and Final offer documents
// =============================================================================

model DocumentTemplate {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String // "Provisional Offer Letter", "Final Offer Letter"
  code        String // PROVISIONAL_OFFER, FINAL_OFFER
  description String?
  version     Int     @default(1)

  // Template content (Handlebars)
  htmlTemplate String  @db.Text
  cssStyles    String? @db.Text

  // Merge field definitions for UI
  mergeFields Json? // [{name, type, required, description}]

  isActive  Boolean @default(true)
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  offerLetters OfferLetter[]

  @@unique([tenantId, code, version])
  @@index([tenantId])
  @@index([code])
  @@map("document_templates")
}

model OfferLetter {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // Template used (optional - documents-service may handle default selection)
  templateId String?
  template   DocumentTemplate? @relation(fields: [templateId], references: [id])

  // Letter details
  letterNumber String            @unique // OL-XXXXXX
  type         OfferLetterType
  status       OfferLetterStatus @default(DRAFT)

  // Generated document
  htmlContent String? @db.Text // Rendered HTML
  pdfUrl      String? // S3 URL of generated PDF
  pdfKey      String? // S3 key for deletion/access

  // Merge data used (snapshot for audit)
  mergeData Json? // All data merged into template

  // Signing workflow
  sentAt        DateTime?
  viewedAt      DateTime?
  signedAt      DateTime?
  signatureIp   String?
  signatureData Json? // {method, timestamp, metadata}

  // Validity
  expiresAt    DateTime?
  expiredAt    DateTime?
  cancelledAt  DateTime?
  cancelReason String?

  // Audit
  generatedById String?
  generatedBy   User?   @relation("OfferLetterGenerator", fields: [generatedById], references: [id])
  sentById      String?
  sentBy        User?   @relation("OfferLetterSender", fields: [sentById], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([applicationId])
  @@index([type])
  @@index([status])
  @@map("offer_letters")
}

// =============================================================================
// CONTRACT TERMINATION - Full lifecycle for cancellation/termination
// =============================================================================
// Tracks termination requests from initiation through refund completion.
// Industry-standard flow:
// 1. Request created (by buyer/seller/admin/system)
// 2. Admin reviews (if required by policy)
// 3. Financial settlement calculated (refunds, penalties, forfeitures)
// 4. Refund processed (if applicable)
// 5. Contract marked terminated, unit released
// =============================================================================

model ApplicationTermination {
  id            String      @id @default(cuid())
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Request identification
  requestNumber String @unique // TRM-XXXXXX

  // Who initiated and why
  initiatedBy    TerminationInitiator
  initiatorId    String? // userId if BUYER/SELLER/ADMIN
  initiator      User?                @relation("TerminationInitiator", fields: [initiatorId], references: [id])
  type           TerminationType
  reason         String?              @db.Text
  supportingDocs Json? // [{type, url, uploadedAt}]

  // Workflow status
  status              TerminationStatus @default(REQUESTED)
  requiresApproval    Boolean           @default(true)
  autoApproveEligible Boolean           @default(false) // Pre-signature, no payments

  // Admin review
  reviewedBy      String?
  reviewer        User?     @relation("TerminationReviewer", fields: [reviewedBy], references: [id])
  reviewedAt      DateTime?
  reviewNotes     String?   @db.Text
  rejectionReason String?   @db.Text

  // Financial snapshot at time of request
  applicationSnapshot    Json // Full contract state snapshot
  totalApplicationAmount Float
  totalPaidToDate        Float
  outstandingBalance     Float

  // Settlement calculation
  refundableAmount Float   @default(0) // Amount eligible for refund
  penaltyAmount    Float   @default(0) // Penalties/fees to deduct
  forfeitedAmount  Float   @default(0) // Amount forfeited (non-refundable deposits)
  adminFeeAmount   Float   @default(0) // Processing fees
  netRefundAmount  Float   @default(0) // refundableAmount - penaltyAmount - adminFeeAmount
  settlementNotes  String? @db.Text

  // Refund processing
  refundStatus         RefundStatus @default(PENDING)
  refundReference      String? // Payment gateway reference
  refundMethod         String? // ORIGINAL_METHOD, BANK_TRANSFER, CHECK, WALLET
  refundAccountDetails Json? // Encrypted bank details if needed
  refundInitiatedAt    DateTime?
  refundCompletedAt    DateTime?
  refundFailureReason  String?      @db.Text

  // Property unit handling
  unitReleasedAt    DateTime?
  unitReservedForId String? // If unit being held for another buyer

  // Timing
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  executedAt  DateTime?
  completedAt DateTime?
  cancelledAt DateTime?

  // Idempotency and audit
  idempotencyKey String? @unique
  metadata       Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([applicationId])
  @@index([tenantId])
  @@index([status])
  @@index([type])
  @@index([initiatorId])
  @@index([requestedAt])
  @@map("application_terminations")
}

// =============================================================================
// PAYMENT METHOD CHANGE REQUEST - Mid-contract payment method changes
// =============================================================================
// When a user wants to change their payment method after contract creation,
// this aggregate tracks the request, required documentation, approvals, and
// final execution. Different from-to combinations may require different docs.
// =============================================================================

enum PaymentMethodChangeStatus {
  PENDING_DOCUMENTS
  DOCUMENTS_SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  EXECUTED
  CANCELLED
}

model PaymentMethodChangeRequest {
  id            String      @id @default(cuid())
  tenantId      String
  tenant        Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  applicationId String
  application   Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  // The change being requested
  fromPaymentMethodId String
  fromPaymentMethod   PropertyPaymentMethod @relation("ChangeFromMethod", fields: [fromPaymentMethodId], references: [id])
  toPaymentMethodId   String
  toPaymentMethod     PropertyPaymentMethod @relation("ChangeToMethod", fields: [toPaymentMethodId], references: [id])

  // Who requested and why
  requestorId String
  requestor   User    @relation("ChangeRequestor", fields: [requestorId], references: [id])
  reason      String? @db.Text

  // Documentation requirements (determined by DocumentRequirementRule)
  requiredDocumentTypes String? // CSV: BANK_STATEMENT,INCOME_PROOF,NEW_EMPLOYER_LETTER
  submittedDocuments    Json? // [{type, s3Key, uploadedAt, status}]

  // Financial impact assessment
  currentOutstanding   Float? // Outstanding balance at time of request
  newTermMonths        Int? // New term if applicable
  newInterestRate      Float? // New rate if applicable
  newMonthlyPayment    Float? // Projected new payment
  penaltyAmount        Float? // Early change penalty if applicable
  financialImpactNotes String? @db.Text

  // Status and workflow
  status      PaymentMethodChangeStatus @default(PENDING_DOCUMENTS)
  reviewerId  String?
  reviewer    User?                     @relation("ChangeReviewer", fields: [reviewerId], references: [id])
  reviewNotes String?                   @db.Text
  reviewedAt  DateTime?

  // Execution details
  executedAt        DateTime?
  previousPhaseData Json? // Snapshot of phases before change
  newPhaseData      Json? // New phases created after change

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([applicationId])
  @@index([status])
  @@index([requestorId])
  @@map("payment_method_change_requests")
}

// =============================================================================
// DOCUMENT REQUIREMENT RULES - Configurable document requirements
// =============================================================================
// Admins can configure which documents are required for specific scenarios:
// - Prequalification for a payment method type
// - Contract phases
// - Payment method changes (from-to combinations)
// This allows tenants to customize documentation workflows per product.
// =============================================================================

enum DocumentRequirementContext {
  APPLICATION_PHASE // During a contract phase
  PAYMENT_METHOD_CHANGE // When changing payment method mid-contract
}

model DocumentRequirementRule {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Rule context
  context DocumentRequirementContext

  // Scoping (which situations this rule applies to)
  // For PREQUALIFICATION: paymentMethodId
  // For APPLICATION_PHASE: phaseType
  // For PAYMENT_METHOD_CHANGE: fromMethodId + toMethodId
  paymentMethodId     String?
  paymentMethod       PropertyPaymentMethod? @relation("RulePaymentMethod", fields: [paymentMethodId], references: [id])
  phaseType           String? // KYC, VERIFICATION, DOWNPAYMENT, etc.
  fromPaymentMethodId String?
  fromPaymentMethod   PropertyPaymentMethod? @relation("RuleFromMethod", fields: [fromPaymentMethodId], references: [id])
  toPaymentMethodId   String?
  toPaymentMethod     PropertyPaymentMethod? @relation("RuleToMethod", fields: [toPaymentMethodId], references: [id])

  // Document requirements
  documentType     String // ID_CARD, PASSPORT, BANK_STATEMENT, INCOME_PROOF, etc.
  isRequired       Boolean @default(true)
  description      String? // Instructions for the user
  maxSizeBytes     Int? // Max file size allowed
  allowedMimeTypes String? // CSV: application/pdf,image/jpeg,image/png

  // Validation rules
  expiryDays           Int? // Document must not be older than X days
  requiresManualReview Boolean @default(false)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([context])
  @@index([paymentMethodId])
  @@index([phaseType])
  @@index([fromPaymentMethodId, toPaymentMethodId])
  @@map("document_requirement_rules")
}

// =============================================================================
// EVENT-DRIVEN WORKFLOW CONFIGURATION
// =============================================================================
// This system allows admins to configure event channels, types, and handlers
// for a flexible, configurable event-driven workflow system.
//
// Architecture:
// 1. EventChannel - Logical grouping of events (e.g., "contracts", "payments")
// 2. EventType - Specific event types (e.g., "DOCUMENT_UPLOADED", "STEP_COMPLETED")
// 3. EventHandler - What to do when an event fires (webhook, internal call, etc.)
// 4. WorkflowEvent - Actual event instances (audit log)
// 5. EventHandlerExecution - Log of handler executions
// =============================================================================

/// Event Channel - A logical grouping of events
/// Channels help organize events and route them to appropriate handlers
model EventChannel {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  /// Unique code for the channel (e.g., "CONTRACTS", "PAYMENTS")
  code        String
  /// Human-readable name
  name        String
  /// Description of what this channel handles
  description String? @db.Text

  /// Whether this channel is active
  enabled Boolean @default(true)

  /// Event types that belong to this channel
  eventTypes EventType[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, code])
  @@index([tenantId])
  @@map("event_channels")
}

/// Event Type - Defines a type of event that can occur
/// Each event type belongs to a channel and can have multiple handlers
model EventType {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  /// The channel this event type belongs to
  channelId String
  channel   EventChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  /// Unique code for this event type (e.g., "DOCUMENT_UPLOADED")
  code        String
  /// Human-readable name
  name        String
  /// Description of when this event fires
  description String? @db.Text

  /// JSON schema for event payload validation (optional)
  payloadSchema Json?

  /// Whether this event type is active
  enabled Boolean @default(true)

  /// Handlers subscribed to this event type
  handlers EventHandler[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, code])
  @@unique([channelId, code])
  @@index([tenantId])
  @@index([channelId])
  @@map("event_types")
}

/// Event Handler - Defines what should happen when an event fires
/// Handlers can be internal (call a service), external (webhook), or workflow triggers
model EventHandler {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  /// The event type this handler responds to
  eventTypeId String
  eventType   EventType @relation(fields: [eventTypeId], references: [id], onDelete: Cascade)

  /// Human-readable name
  name        String
  /// Description of what this handler does
  description String? @db.Text

  /// Handler type determines how the event is processed
  handlerType EventHandlerType

  /// Configuration for the handler (JSON, depends on handlerType)
  /// INTERNAL: { "service": "contract", "method": "completeStep" }
  /// WEBHOOK: { "url": "https://...", "method": "POST", "headers": {...} }
  /// WORKFLOW: { "workflowId": "...", "action": "advance" }
  /// NOTIFICATION: { "template": "...", "channels": ["email", "sms"] }
  config Json

  /// Order of execution when multiple handlers exist (lower = first)
  priority Int @default(100)

  /// Whether this handler is active
  enabled Boolean @default(true)

  /// Retry configuration
  maxRetries   Int @default(3)
  retryDelayMs Int @default(1000)

  /// Filter condition (JSONPath expression) to conditionally run
  /// e.g., "$.payload.status == 'approved'"
  filterCondition String? @db.Text

  /// Step attachments - steps that have attached this handler
  stepAttachments StepEventAttachment[]

  /// Phase attachments - phases that have attached this handler
  phaseAttachments PhaseEventAttachment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([eventTypeId])
  @@index([handlerType])
  @@map("event_handlers")
}

// =============================================================================
// EVENT OUTBOX - For guaranteed event delivery to SQS queues
// =============================================================================

model DomainEvent {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Event identification
  eventType     String // MORTGAGE.CREATED, PHASE.ACTIVATED, PAYMENT.COMPLETED, etc
  aggregateType String // Mortgage, MortgagePhase, MortgagePayment, Property, etc
  aggregateId   String

  // Routing - which queue(s) should receive this
  queueName String // notifications, payments, mortgage-steps, accounting, etc

  // Event payload (all data needed by consumers)
  payload String @db.Text // JSON

  // Metadata
  occurredAt DateTime @default(now())
  actorId    String? // User who triggered the event
  actorRole  String? // Role of the actor

  // Processing status
  status       String    @default("PENDING") // PENDING, PROCESSING, SENT, FAILED
  processedAt  DateTime?
  sentAt       DateTime?
  failureCount Int       @default(0)
  lastError    String?   @db.Text
  nextRetryAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([status, nextRetryAt])
  @@index([eventType])
  @@index([aggregateType, aggregateId])
  @@index([queueName])
  @@index([occurredAt])
  @@map("domain_events")
}

// =============================================================================
// Property Transfer Request
// =============================================================================
// Allows a buyer to request transferring their contract to a different property.
// 
// TRANSFER PAYMENT FLOW:
// 1. All payments from source contract are refunded to buyer's wallet (single credit transaction)
// 2. Source contract marked TRANSFERRED, unit released
// 3. New contract created for target unit with zero payments
// 4. Buyer can optionally apply wallet balance as equity during new mortgage application
//
// This ensures clean accounting: each contract has isolated payment history,
// wallet serves as intermediary, and buyer retains full credit.
// =============================================================================

model PropertyTransferRequest {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Source contract being transferred
  sourceApplicationId String
  sourceApplication   Application @relation("SourceApplication", fields: [sourceApplicationId], references: [id], onDelete: Cascade)

  // Target property unit
  targetPropertyUnitId String
  targetPropertyUnit   PropertyUnit @relation(fields: [targetPropertyUnitId], references: [id])

  // Requestor (buyer) and reviewer (admin)
  requestedById String
  requestedBy   User    @relation("TransferRequestor", fields: [requestedById], references: [id])
  reviewedById  String?
  reviewedBy    User?   @relation("TransferReviewer", fields: [reviewedById], references: [id])

  // Status and workflow
  status TransferRequestStatus @default(PENDING)

  // Request details
  reason String? @db.Text // Buyer's reason for transfer

  // Review details
  reviewNotes             String? @db.Text // Admin notes on decision
  priceAdjustmentHandling String? // How to handle price difference: ADD_TO_MORTGAGE, REQUIRE_PAYMENT, CREDIT_BUYER

  // Computed values
  sourceTotalAmount Float? // Original contract total
  targetTotalAmount Float? // New contract total (based on target property)
  priceAdjustment   Float? // Difference (positive = buyer owes more)

  // Wallet refund tracking (payments refunded to wallet, NOT carried over)
  refundedAmount      Float? // Total amount refunded to wallet
  refundTransactionId String? // Reference to wallet Transaction record
  refundedAt          DateTime?

  // Result - new contract created after approval
  targetApplicationId String?
  targetApplication   Application? @relation("TargetApplication", fields: [targetApplicationId], references: [id])

  // Timestamps
  createdAt   DateTime  @default(now())
  reviewedAt  DateTime?
  completedAt DateTime?
  updatedAt   DateTime  @updatedAt

  @@index([tenantId])
  @@index([sourceApplicationId])
  @@index([targetPropertyUnitId])
  @@index([requestedById])
  @@index([status])
  @@map("property_transfer_requests")
}

// =============================================================================
// UNIFIED APPROVAL REQUESTS
// =============================================================================

enum ApprovalRequestType {
  PROPERTY_TRANSFER // Property unit transfer between contracts
  PROPERTY_UPDATE // Property/unit listing update requiring approval
  USER_WORKFLOW // User workflow step approval
  CREDIT_CHECK // Credit check result review
  APPLICATION_TERMINATION // Contract termination approval
  REFUND_APPROVAL // Refund request approval
}

enum ApprovalRequestStatus {
  PENDING // Awaiting review
  IN_REVIEW // Assigned to reviewer
  APPROVED // Approved by reviewer
  REJECTED // Rejected by reviewer
  CANCELLED // Cancelled by requestor
  EXPIRED // Auto-expired (if TTL configured)
}

enum ApprovalRequestPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Polymorphic approval request model for unified admin dashboard
model ApprovalRequest {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Request type and status
  type     ApprovalRequestType
  status   ApprovalRequestStatus   @default(PENDING)
  priority ApprovalRequestPriority @default(NORMAL)

  // Polymorphic reference to the entity requiring approval
  entityType String // e.g., "PropertyTransferRequest", "PropertyUnit", "User"
  entityId   String // ID of the referenced entity

  // Request metadata
  title       String  @db.VarChar(255) // Human-readable title for the request
  description String? @db.Text // Detailed description

  // Payload for any additional context (JSON)
  payload Json? // Flexible data storage for type-specific details

  // Requestor - who created the request
  requestedById String
  requestedBy   User   @relation("ApprovalRequestor", fields: [requestedById], references: [id])

  // Assignee - admin/reviewer assigned to handle this request
  assigneeId String?
  assignee   User?   @relation("ApprovalAssignee", fields: [assigneeId], references: [id])

  // Reviewer - who made the final decision (may differ from assignee)
  reviewedById String?
  reviewedBy   User?   @relation("ApprovalReviewer", fields: [reviewedById], references: [id])

  // Review details
  reviewNotes String?           @db.Text // Reviewer's notes/comments
  decision    ApprovalDecision? // APPROVED, REJECTED, REQUEST_CHANGES

  // Expiration
  expiresAt DateTime? // Optional TTL for auto-expiration

  // Timestamps
  createdAt   DateTime  @default(now())
  assignedAt  DateTime? // When assigned to reviewer
  reviewedAt  DateTime? // When decision was made
  completedAt DateTime? // When fully processed
  updatedAt   DateTime  @updatedAt

  @@index([tenantId])
  @@index([type])
  @@index([status])
  @@index([priority])
  @@index([entityType, entityId])
  @@index([requestedById])
  @@index([assigneeId])
  @@index([createdAt])
  @@index([type, status]) // Efficient queries for approval dashboard
  @@map("approval_requests")
}

// =============================================================================
// WORKFLOW BLOCKER TRACKING - Analytics for workflow delays
// =============================================================================
// Tracks who is blocking the workflow at any point, enabling analytics like:
// - Average time customers take to upload documents
// - Average time admins take to review/approve
// - Most common bottleneck steps
// - SLA compliance tracking
// - Customer service intervention triggers
// =============================================================================

/// Who is responsible for the current workflow block
enum BlockerActor {
  CUSTOMER // Customer action required (upload, sign, pay)
  ADMIN // Admin action required (review, approve, reject)
  SYSTEM // System processing (auto-generation, external checks)
  EXTERNAL // External party (bank, government, third-party verification)
}

/// Category of action that is blocking workflow
enum BlockerCategory {
  UPLOAD // Document upload needed
  RESUBMISSION // Document resubmission after rejection
  SIGNATURE // Signature required
  REVIEW // Admin review needed
  APPROVAL // Admin approval needed
  PAYMENT // Payment required
  PROCESSING // System processing
  EXTERNAL_CHECK // External verification
  QUESTIONNAIRE // Form/questionnaire completion
}

/// Urgency level for prioritization and SLA tracking
enum BlockerUrgency {
  LOW // No immediate deadline
  NORMAL // Standard processing
  HIGH // Approaching deadline or overdue
  CRITICAL // Significantly overdue or business-critical
}

/// Workflow Blocker - Records who is blocking workflow and for how long
model WorkflowBlocker {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Reference to the blocked entity
  applicationId String
  phaseId       String?
  stepId        String?

  // Actor and action details
  blockerActor    BlockerActor
  blockerCategory BlockerCategory
  urgency         BlockerUrgency  @default(NORMAL)

  // Human-readable descriptions
  actionRequired String  @db.VarChar(500) // What action is needed
  context        String? @db.Text // Additional context

  // SLA tracking
  expectedByDate DateTime? // When this action should be completed
  isOverdue      Boolean   @default(false)
  overdueAt      DateTime? // When it became overdue

  // Duration tracking
  startedAt  DateTime  @default(now()) // When this block started
  resolvedAt DateTime? // When it was resolved
  durationMs Int? // Calculated duration on resolution

  // Resolution details
  resolvedByActor   String? // Who resolved it (userId or "SYSTEM")
  resolutionTrigger String? // What action resolved it (e.g., "DOCUMENT_UPLOADED", "STEP_COMPLETED")

  // Reminder tracking (for customer service)
  reminderCount  Int       @default(0) // Number of reminders sent
  lastReminderAt DateTime? // Last reminder timestamp
  nextReminderAt DateTime? // Scheduled next reminder

  // Metadata for additional analytics
  metadata Json? // Flexible data: { documentType, stepType, phaseType, etc. }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([applicationId])
  @@index([phaseId])
  @@index([stepId])
  @@index([blockerActor])
  @@index([blockerCategory])
  @@index([urgency])
  @@index([isOverdue])
  @@index([startedAt])
  @@index([resolvedAt])
  @@index([tenantId, blockerActor, resolvedAt]) // For "open blockers by actor" queries
  @@index([tenantId, blockerCategory, resolvedAt]) // For "open blockers by category" queries
  @@index([tenantId, isOverdue, blockerActor]) // For SLA violation queries
  @@map("workflow_blockers")
}

// =============================================================================
// DOCUMENT EXPIRY JOB - Scheduled job tracking for document expiration checks
// =============================================================================
// Tracks scheduled jobs for checking document expiration across applications.
// This supports a cron-based approach where a Lambda runs periodically to:
// 1. Find documents nearing expiry (warning)
// 2. Mark expired documents
// 3. Notify customers to re-upload
// 4. Optionally block phase progression if critical documents expired
// =============================================================================

/// Job status for scheduled background jobs
enum ScheduledJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

/// Type of scheduled job
enum ScheduledJobType {
  DOCUMENT_EXPIRY_CHECK // Check for expired documents
  SLA_BREACH_CHECK // Check for SLA breaches
  PAYMENT_REMINDER // Send payment reminders
  DOCUMENT_EXPIRY_WARNING // Warn about documents nearing expiry
}

/// Scheduled Job - Tracks execution of background jobs
model ScheduledJob {
  id       String  @id @default(cuid())
  tenantId String? // NULL = system-wide job, set = tenant-specific

  jobType ScheduledJobType
  status  ScheduledJobStatus @default(PENDING)

  // Scheduling
  scheduledAt DateTime // When the job should run
  startedAt   DateTime? // When job started executing
  completedAt DateTime? // When job finished
  durationMs  Int? // Execution time

  // Job parameters
  parameters Json? // Job-specific configuration

  // Results
  itemsProcessed Int     @default(0)
  itemsAffected  Int     @default(0) // Documents expired, SLAs breached, etc.
  errorCount     Int     @default(0)
  errors         Json? // Array of error details
  summary        String? @db.Text // Human-readable summary

  // Retry handling
  attemptNumber Int       @default(1)
  maxAttempts   Int       @default(3)
  nextRetryAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([jobType])
  @@index([status])
  @@index([scheduledAt])
  @@index([jobType, status, scheduledAt])
  @@map("scheduled_jobs")
}

/// Document Expiry Warning - Track warnings sent for expiring documents
model DocumentExpiryWarning {
  id         String @id @default(cuid())
  tenantId   String
  documentId String

  // Warning details
  expiresAt   DateTime // When document will expire
  daysUntil   Int // Days until expiry at time of warning
  warningSent DateTime @default(now())

  // Customer notification tracking
  notificationSent Boolean @default(false)
  notificationId   String? // Reference to notification service

  // Resolution tracking
  resolved      Boolean   @default(false)
  resolvedAt    DateTime?
  resolvedBy    String? // User who resolved (re-uploaded document)
  newDocumentId String? // ID of the replacement document

  createdAt DateTime @default(now())

  @@unique([documentId, daysUntil]) // One warning per document per threshold
  @@index([tenantId])
  @@index([documentId])
  @@index([expiresAt])
  @@index([resolved])
  @@map("document_expiry_warnings")
}
