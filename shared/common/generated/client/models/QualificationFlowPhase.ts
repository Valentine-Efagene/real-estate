
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `QualificationFlowPhase` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model QualificationFlowPhase
 * Phase template within a QualificationFlow
 * Supports QUESTIONNAIRE, DOCUMENTATION, and GATE phases (no PAYMENT)
 */
export type QualificationFlowPhaseModel = runtime.Types.Result.DefaultSelection<Prisma.$QualificationFlowPhasePayload>

export type AggregateQualificationFlowPhase = {
  _count: QualificationFlowPhaseCountAggregateOutputType | null
  _avg: QualificationFlowPhaseAvgAggregateOutputType | null
  _sum: QualificationFlowPhaseSumAggregateOutputType | null
  _min: QualificationFlowPhaseMinAggregateOutputType | null
  _max: QualificationFlowPhaseMaxAggregateOutputType | null
}

export type QualificationFlowPhaseAvgAggregateOutputType = {
  order: number | null
}

export type QualificationFlowPhaseSumAggregateOutputType = {
  order: number | null
}

export type QualificationFlowPhaseMinAggregateOutputType = {
  id: string | null
  tenantId: string | null
  qualificationFlowId: string | null
  questionnairePlanId: string | null
  documentationPlanId: string | null
  gatePlanId: string | null
  name: string | null
  description: string | null
  phaseCategory: $Enums.PhaseCategory | null
  phaseType: $Enums.PhaseType | null
  order: number | null
  requiresPreviousPhaseCompletion: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type QualificationFlowPhaseMaxAggregateOutputType = {
  id: string | null
  tenantId: string | null
  qualificationFlowId: string | null
  questionnairePlanId: string | null
  documentationPlanId: string | null
  gatePlanId: string | null
  name: string | null
  description: string | null
  phaseCategory: $Enums.PhaseCategory | null
  phaseType: $Enums.PhaseType | null
  order: number | null
  requiresPreviousPhaseCompletion: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type QualificationFlowPhaseCountAggregateOutputType = {
  id: number
  tenantId: number
  qualificationFlowId: number
  questionnairePlanId: number
  documentationPlanId: number
  gatePlanId: number
  name: number
  description: number
  phaseCategory: number
  phaseType: number
  order: number
  requiresPreviousPhaseCompletion: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type QualificationFlowPhaseAvgAggregateInputType = {
  order?: true
}

export type QualificationFlowPhaseSumAggregateInputType = {
  order?: true
}

export type QualificationFlowPhaseMinAggregateInputType = {
  id?: true
  tenantId?: true
  qualificationFlowId?: true
  questionnairePlanId?: true
  documentationPlanId?: true
  gatePlanId?: true
  name?: true
  description?: true
  phaseCategory?: true
  phaseType?: true
  order?: true
  requiresPreviousPhaseCompletion?: true
  createdAt?: true
  updatedAt?: true
}

export type QualificationFlowPhaseMaxAggregateInputType = {
  id?: true
  tenantId?: true
  qualificationFlowId?: true
  questionnairePlanId?: true
  documentationPlanId?: true
  gatePlanId?: true
  name?: true
  description?: true
  phaseCategory?: true
  phaseType?: true
  order?: true
  requiresPreviousPhaseCompletion?: true
  createdAt?: true
  updatedAt?: true
}

export type QualificationFlowPhaseCountAggregateInputType = {
  id?: true
  tenantId?: true
  qualificationFlowId?: true
  questionnairePlanId?: true
  documentationPlanId?: true
  gatePlanId?: true
  name?: true
  description?: true
  phaseCategory?: true
  phaseType?: true
  order?: true
  requiresPreviousPhaseCompletion?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type QualificationFlowPhaseAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which QualificationFlowPhase to aggregate.
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QualificationFlowPhases to fetch.
   */
  orderBy?: Prisma.QualificationFlowPhaseOrderByWithRelationInput | Prisma.QualificationFlowPhaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.QualificationFlowPhaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QualificationFlowPhases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QualificationFlowPhases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned QualificationFlowPhases
  **/
  _count?: true | QualificationFlowPhaseCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: QualificationFlowPhaseAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: QualificationFlowPhaseSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: QualificationFlowPhaseMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: QualificationFlowPhaseMaxAggregateInputType
}

export type GetQualificationFlowPhaseAggregateType<T extends QualificationFlowPhaseAggregateArgs> = {
      [P in keyof T & keyof AggregateQualificationFlowPhase]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateQualificationFlowPhase[P]>
    : Prisma.GetScalarType<T[P], AggregateQualificationFlowPhase[P]>
}




export type QualificationFlowPhaseGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.QualificationFlowPhaseWhereInput
  orderBy?: Prisma.QualificationFlowPhaseOrderByWithAggregationInput | Prisma.QualificationFlowPhaseOrderByWithAggregationInput[]
  by: Prisma.QualificationFlowPhaseScalarFieldEnum[] | Prisma.QualificationFlowPhaseScalarFieldEnum
  having?: Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: QualificationFlowPhaseCountAggregateInputType | true
  _avg?: QualificationFlowPhaseAvgAggregateInputType
  _sum?: QualificationFlowPhaseSumAggregateInputType
  _min?: QualificationFlowPhaseMinAggregateInputType
  _max?: QualificationFlowPhaseMaxAggregateInputType
}

export type QualificationFlowPhaseGroupByOutputType = {
  id: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId: string | null
  documentationPlanId: string | null
  gatePlanId: string | null
  name: string
  description: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion: boolean
  createdAt: Date
  updatedAt: Date
  _count: QualificationFlowPhaseCountAggregateOutputType | null
  _avg: QualificationFlowPhaseAvgAggregateOutputType | null
  _sum: QualificationFlowPhaseSumAggregateOutputType | null
  _min: QualificationFlowPhaseMinAggregateOutputType | null
  _max: QualificationFlowPhaseMaxAggregateOutputType | null
}

type GetQualificationFlowPhaseGroupByPayload<T extends QualificationFlowPhaseGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<QualificationFlowPhaseGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof QualificationFlowPhaseGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], QualificationFlowPhaseGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], QualificationFlowPhaseGroupByOutputType[P]>
      }
    >
  >



export type QualificationFlowPhaseWhereInput = {
  AND?: Prisma.QualificationFlowPhaseWhereInput | Prisma.QualificationFlowPhaseWhereInput[]
  OR?: Prisma.QualificationFlowPhaseWhereInput[]
  NOT?: Prisma.QualificationFlowPhaseWhereInput | Prisma.QualificationFlowPhaseWhereInput[]
  id?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  tenantId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  qualificationFlowId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  questionnairePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  documentationPlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  gatePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  name?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  description?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFilter<"QualificationFlowPhase"> | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFilter<"QualificationFlowPhase"> | $Enums.PhaseType
  order?: Prisma.IntFilter<"QualificationFlowPhase"> | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFilter<"QualificationFlowPhase"> | boolean
  createdAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  qualificationFlow?: Prisma.XOR<Prisma.QualificationFlowScalarRelationFilter, Prisma.QualificationFlowWhereInput>
  questionnairePlan?: Prisma.XOR<Prisma.QuestionnairePlanNullableScalarRelationFilter, Prisma.QuestionnairePlanWhereInput> | null
  documentationPlan?: Prisma.XOR<Prisma.DocumentationPlanNullableScalarRelationFilter, Prisma.DocumentationPlanWhereInput> | null
  gatePlan?: Prisma.XOR<Prisma.GatePlanNullableScalarRelationFilter, Prisma.GatePlanWhereInput> | null
  qualificationPhases?: Prisma.QualificationPhaseListRelationFilter
}

export type QualificationFlowPhaseOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  qualificationFlowId?: Prisma.SortOrder
  questionnairePlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  documentationPlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  gatePlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  phaseCategory?: Prisma.SortOrder
  phaseType?: Prisma.SortOrder
  order?: Prisma.SortOrder
  requiresPreviousPhaseCompletion?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  tenant?: Prisma.TenantOrderByWithRelationInput
  qualificationFlow?: Prisma.QualificationFlowOrderByWithRelationInput
  questionnairePlan?: Prisma.QuestionnairePlanOrderByWithRelationInput
  documentationPlan?: Prisma.DocumentationPlanOrderByWithRelationInput
  gatePlan?: Prisma.GatePlanOrderByWithRelationInput
  qualificationPhases?: Prisma.QualificationPhaseOrderByRelationAggregateInput
  _relevance?: Prisma.QualificationFlowPhaseOrderByRelevanceInput
}

export type QualificationFlowPhaseWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  qualificationFlowId_order?: Prisma.QualificationFlowPhaseQualificationFlowIdOrderCompoundUniqueInput
  AND?: Prisma.QualificationFlowPhaseWhereInput | Prisma.QualificationFlowPhaseWhereInput[]
  OR?: Prisma.QualificationFlowPhaseWhereInput[]
  NOT?: Prisma.QualificationFlowPhaseWhereInput | Prisma.QualificationFlowPhaseWhereInput[]
  tenantId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  qualificationFlowId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  questionnairePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  documentationPlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  gatePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  name?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  description?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFilter<"QualificationFlowPhase"> | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFilter<"QualificationFlowPhase"> | $Enums.PhaseType
  order?: Prisma.IntFilter<"QualificationFlowPhase"> | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFilter<"QualificationFlowPhase"> | boolean
  createdAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  qualificationFlow?: Prisma.XOR<Prisma.QualificationFlowScalarRelationFilter, Prisma.QualificationFlowWhereInput>
  questionnairePlan?: Prisma.XOR<Prisma.QuestionnairePlanNullableScalarRelationFilter, Prisma.QuestionnairePlanWhereInput> | null
  documentationPlan?: Prisma.XOR<Prisma.DocumentationPlanNullableScalarRelationFilter, Prisma.DocumentationPlanWhereInput> | null
  gatePlan?: Prisma.XOR<Prisma.GatePlanNullableScalarRelationFilter, Prisma.GatePlanWhereInput> | null
  qualificationPhases?: Prisma.QualificationPhaseListRelationFilter
}, "id" | "qualificationFlowId_order">

export type QualificationFlowPhaseOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  qualificationFlowId?: Prisma.SortOrder
  questionnairePlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  documentationPlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  gatePlanId?: Prisma.SortOrderInput | Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrderInput | Prisma.SortOrder
  phaseCategory?: Prisma.SortOrder
  phaseType?: Prisma.SortOrder
  order?: Prisma.SortOrder
  requiresPreviousPhaseCompletion?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.QualificationFlowPhaseCountOrderByAggregateInput
  _avg?: Prisma.QualificationFlowPhaseAvgOrderByAggregateInput
  _max?: Prisma.QualificationFlowPhaseMaxOrderByAggregateInput
  _min?: Prisma.QualificationFlowPhaseMinOrderByAggregateInput
  _sum?: Prisma.QualificationFlowPhaseSumOrderByAggregateInput
}

export type QualificationFlowPhaseScalarWhereWithAggregatesInput = {
  AND?: Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput | Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput[]
  OR?: Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput[]
  NOT?: Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput | Prisma.QualificationFlowPhaseScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"QualificationFlowPhase"> | string
  tenantId?: Prisma.StringWithAggregatesFilter<"QualificationFlowPhase"> | string
  qualificationFlowId?: Prisma.StringWithAggregatesFilter<"QualificationFlowPhase"> | string
  questionnairePlanId?: Prisma.StringNullableWithAggregatesFilter<"QualificationFlowPhase"> | string | null
  documentationPlanId?: Prisma.StringNullableWithAggregatesFilter<"QualificationFlowPhase"> | string | null
  gatePlanId?: Prisma.StringNullableWithAggregatesFilter<"QualificationFlowPhase"> | string | null
  name?: Prisma.StringWithAggregatesFilter<"QualificationFlowPhase"> | string
  description?: Prisma.StringNullableWithAggregatesFilter<"QualificationFlowPhase"> | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryWithAggregatesFilter<"QualificationFlowPhase"> | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeWithAggregatesFilter<"QualificationFlowPhase"> | $Enums.PhaseType
  order?: Prisma.IntWithAggregatesFilter<"QualificationFlowPhase"> | number
  requiresPreviousPhaseCompletion?: Prisma.BoolWithAggregatesFilter<"QualificationFlowPhase"> | boolean
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"QualificationFlowPhase"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"QualificationFlowPhase"> | Date | string
}

export type QualificationFlowPhaseCreateInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseCreateManyInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseListRelationFilter = {
  every?: Prisma.QualificationFlowPhaseWhereInput
  some?: Prisma.QualificationFlowPhaseWhereInput
  none?: Prisma.QualificationFlowPhaseWhereInput
}

export type QualificationFlowPhaseOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type QualificationFlowPhaseOrderByRelevanceInput = {
  fields: Prisma.QualificationFlowPhaseOrderByRelevanceFieldEnum | Prisma.QualificationFlowPhaseOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type QualificationFlowPhaseQualificationFlowIdOrderCompoundUniqueInput = {
  qualificationFlowId: string
  order: number
}

export type QualificationFlowPhaseCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  qualificationFlowId?: Prisma.SortOrder
  questionnairePlanId?: Prisma.SortOrder
  documentationPlanId?: Prisma.SortOrder
  gatePlanId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  phaseCategory?: Prisma.SortOrder
  phaseType?: Prisma.SortOrder
  order?: Prisma.SortOrder
  requiresPreviousPhaseCompletion?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type QualificationFlowPhaseAvgOrderByAggregateInput = {
  order?: Prisma.SortOrder
}

export type QualificationFlowPhaseMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  qualificationFlowId?: Prisma.SortOrder
  questionnairePlanId?: Prisma.SortOrder
  documentationPlanId?: Prisma.SortOrder
  gatePlanId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  phaseCategory?: Prisma.SortOrder
  phaseType?: Prisma.SortOrder
  order?: Prisma.SortOrder
  requiresPreviousPhaseCompletion?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type QualificationFlowPhaseMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  qualificationFlowId?: Prisma.SortOrder
  questionnairePlanId?: Prisma.SortOrder
  documentationPlanId?: Prisma.SortOrder
  gatePlanId?: Prisma.SortOrder
  name?: Prisma.SortOrder
  description?: Prisma.SortOrder
  phaseCategory?: Prisma.SortOrder
  phaseType?: Prisma.SortOrder
  order?: Prisma.SortOrder
  requiresPreviousPhaseCompletion?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type QualificationFlowPhaseSumOrderByAggregateInput = {
  order?: Prisma.SortOrder
}

export type QualificationFlowPhaseNullableScalarRelationFilter = {
  is?: Prisma.QualificationFlowPhaseWhereInput | null
  isNot?: Prisma.QualificationFlowPhaseWhereInput | null
}

export type QualificationFlowPhaseCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput> | Prisma.QualificationFlowPhaseCreateWithoutTenantInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyTenantInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUncheckedCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput> | Prisma.QualificationFlowPhaseCreateWithoutTenantInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyTenantInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput> | Prisma.QualificationFlowPhaseCreateWithoutTenantInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutTenantInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyTenantInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutTenantInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutTenantInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput> | Prisma.QualificationFlowPhaseCreateWithoutTenantInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutTenantInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyTenantInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutTenantInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutTenantInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseCreateNestedManyWithoutDocumentationPlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput> | Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUncheckedCreateNestedManyWithoutDocumentationPlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput> | Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUpdateManyWithoutDocumentationPlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput> | Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutDocumentationPlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutDocumentationPlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutDocumentationPlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutDocumentationPlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput> | Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutDocumentationPlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutDocumentationPlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutDocumentationPlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutDocumentationPlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseCreateNestedManyWithoutQuestionnairePlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUncheckedCreateNestedManyWithoutQuestionnairePlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUpdateManyWithoutQuestionnairePlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQuestionnairePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQuestionnairePlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQuestionnairePlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutQuestionnairePlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQuestionnairePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQuestionnairePlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQuestionnairePlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQuestionnairePlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseCreateNestedManyWithoutGatePlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyGatePlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUncheckedCreateNestedManyWithoutGatePlanInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyGatePlanInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUpdateManyWithoutGatePlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutGatePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyGatePlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutGatePlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutGatePlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutGatePlanNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput> | Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutGatePlanInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyGatePlanInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutGatePlanInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutGatePlanInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutGatePlanInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseCreateNestedManyWithoutQualificationFlowInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput> | Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQualificationFlowInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUncheckedCreateNestedManyWithoutQualificationFlowInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput> | Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQualificationFlowInputEnvelope
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
}

export type QualificationFlowPhaseUpdateManyWithoutQualificationFlowNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput> | Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQualificationFlowInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQualificationFlowInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQualificationFlowInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQualificationFlowInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutQualificationFlowNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput> | Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput[] | Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput[]
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput[]
  upsert?: Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpsertWithWhereUniqueWithoutQualificationFlowInput[]
  createMany?: Prisma.QualificationFlowPhaseCreateManyQualificationFlowInputEnvelope
  set?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  disconnect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  delete?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput | Prisma.QualificationFlowPhaseWhereUniqueInput[]
  update?: Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpdateWithWhereUniqueWithoutQualificationFlowInput[]
  updateMany?: Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQualificationFlowInput | Prisma.QualificationFlowPhaseUpdateManyWithWhereWithoutQualificationFlowInput[]
  deleteMany?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
}

export type QualificationFlowPhaseCreateNestedOneWithoutQualificationPhasesInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationPhasesInput>
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationPhasesInput
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput
}

export type QualificationFlowPhaseUpdateOneWithoutQualificationPhasesNestedInput = {
  create?: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationPhasesInput>
  connectOrCreate?: Prisma.QualificationFlowPhaseCreateOrConnectWithoutQualificationPhasesInput
  upsert?: Prisma.QualificationFlowPhaseUpsertWithoutQualificationPhasesInput
  disconnect?: Prisma.QualificationFlowPhaseWhereInput | boolean
  delete?: Prisma.QualificationFlowPhaseWhereInput | boolean
  connect?: Prisma.QualificationFlowPhaseWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.QualificationFlowPhaseUpdateToOneWithWhereWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUpdateWithoutQualificationPhasesInput>, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQualificationPhasesInput>
}

export type QualificationFlowPhaseCreateWithoutTenantInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutTenantInput = {
  id?: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseCreateOrConnectWithoutTenantInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput>
}

export type QualificationFlowPhaseCreateManyTenantInputEnvelope = {
  data: Prisma.QualificationFlowPhaseCreateManyTenantInput | Prisma.QualificationFlowPhaseCreateManyTenantInput[]
  skipDuplicates?: boolean
}

export type QualificationFlowPhaseUpsertWithWhereUniqueWithoutTenantInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutTenantInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutTenantInput>
}

export type QualificationFlowPhaseUpdateWithWhereUniqueWithoutTenantInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutTenantInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutTenantInput>
}

export type QualificationFlowPhaseUpdateManyWithWhereWithoutTenantInput = {
  where: Prisma.QualificationFlowPhaseScalarWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyWithoutTenantInput>
}

export type QualificationFlowPhaseScalarWhereInput = {
  AND?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
  OR?: Prisma.QualificationFlowPhaseScalarWhereInput[]
  NOT?: Prisma.QualificationFlowPhaseScalarWhereInput | Prisma.QualificationFlowPhaseScalarWhereInput[]
  id?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  tenantId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  qualificationFlowId?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  questionnairePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  documentationPlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  gatePlanId?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  name?: Prisma.StringFilter<"QualificationFlowPhase"> | string
  description?: Prisma.StringNullableFilter<"QualificationFlowPhase"> | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFilter<"QualificationFlowPhase"> | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFilter<"QualificationFlowPhase"> | $Enums.PhaseType
  order?: Prisma.IntFilter<"QualificationFlowPhase"> | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFilter<"QualificationFlowPhase"> | boolean
  createdAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"QualificationFlowPhase"> | Date | string
}

export type QualificationFlowPhaseCreateWithoutDocumentationPlanInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseCreateOrConnectWithoutDocumentationPlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput>
}

export type QualificationFlowPhaseCreateManyDocumentationPlanInputEnvelope = {
  data: Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInput | Prisma.QualificationFlowPhaseCreateManyDocumentationPlanInput[]
  skipDuplicates?: boolean
}

export type QualificationFlowPhaseUpsertWithWhereUniqueWithoutDocumentationPlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutDocumentationPlanInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutDocumentationPlanInput>
}

export type QualificationFlowPhaseUpdateWithWhereUniqueWithoutDocumentationPlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutDocumentationPlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutDocumentationPlanInput>
}

export type QualificationFlowPhaseUpdateManyWithWhereWithoutDocumentationPlanInput = {
  where: Prisma.QualificationFlowPhaseScalarWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyWithoutDocumentationPlanInput>
}

export type QualificationFlowPhaseCreateWithoutQuestionnairePlanInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseCreateOrConnectWithoutQuestionnairePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput>
}

export type QualificationFlowPhaseCreateManyQuestionnairePlanInputEnvelope = {
  data: Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInput | Prisma.QualificationFlowPhaseCreateManyQuestionnairePlanInput[]
  skipDuplicates?: boolean
}

export type QualificationFlowPhaseUpsertWithWhereUniqueWithoutQuestionnairePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQuestionnairePlanInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQuestionnairePlanInput>
}

export type QualificationFlowPhaseUpdateWithWhereUniqueWithoutQuestionnairePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQuestionnairePlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQuestionnairePlanInput>
}

export type QualificationFlowPhaseUpdateManyWithWhereWithoutQuestionnairePlanInput = {
  where: Prisma.QualificationFlowPhaseScalarWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyWithoutQuestionnairePlanInput>
}

export type QualificationFlowPhaseCreateWithoutGatePlanInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseCreateOrConnectWithoutGatePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput>
}

export type QualificationFlowPhaseCreateManyGatePlanInputEnvelope = {
  data: Prisma.QualificationFlowPhaseCreateManyGatePlanInput | Prisma.QualificationFlowPhaseCreateManyGatePlanInput[]
  skipDuplicates?: boolean
}

export type QualificationFlowPhaseUpsertWithWhereUniqueWithoutGatePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutGatePlanInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutGatePlanInput>
}

export type QualificationFlowPhaseUpdateWithWhereUniqueWithoutGatePlanInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutGatePlanInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutGatePlanInput>
}

export type QualificationFlowPhaseUpdateManyWithWhereWithoutGatePlanInput = {
  where: Prisma.QualificationFlowPhaseScalarWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyWithoutGatePlanInput>
}

export type QualificationFlowPhaseCreateWithoutQualificationFlowInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationPhases?: Prisma.QualificationPhaseCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput = {
  id?: string
  tenantId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedCreateNestedManyWithoutPhaseTemplateInput
}

export type QualificationFlowPhaseCreateOrConnectWithoutQualificationFlowInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput>
}

export type QualificationFlowPhaseCreateManyQualificationFlowInputEnvelope = {
  data: Prisma.QualificationFlowPhaseCreateManyQualificationFlowInput | Prisma.QualificationFlowPhaseCreateManyQualificationFlowInput[]
  skipDuplicates?: boolean
}

export type QualificationFlowPhaseUpsertWithWhereUniqueWithoutQualificationFlowInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQualificationFlowInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationFlowInput>
}

export type QualificationFlowPhaseUpdateWithWhereUniqueWithoutQualificationFlowInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQualificationFlowInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQualificationFlowInput>
}

export type QualificationFlowPhaseUpdateManyWithWhereWithoutQualificationFlowInput = {
  where: Prisma.QualificationFlowPhaseScalarWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyWithoutQualificationFlowInput>
}

export type QualificationFlowPhaseCreateWithoutQualificationPhasesInput = {
  id?: string
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutQualificationFlowPhasesInput
  qualificationFlow: Prisma.QualificationFlowCreateNestedOneWithoutPhasesInput
  questionnairePlan?: Prisma.QuestionnairePlanCreateNestedOneWithoutQualificationFlowPhasesInput
  documentationPlan?: Prisma.DocumentationPlanCreateNestedOneWithoutQualificationFlowPhasesInput
  gatePlan?: Prisma.GatePlanCreateNestedOneWithoutQualificationFlowPhasesInput
}

export type QualificationFlowPhaseUncheckedCreateWithoutQualificationPhasesInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseCreateOrConnectWithoutQualificationPhasesInput = {
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationPhasesInput>
}

export type QualificationFlowPhaseUpsertWithoutQualificationPhasesInput = {
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQualificationPhasesInput>
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedCreateWithoutQualificationPhasesInput>
  where?: Prisma.QualificationFlowPhaseWhereInput
}

export type QualificationFlowPhaseUpdateToOneWithWhereWithoutQualificationPhasesInput = {
  where?: Prisma.QualificationFlowPhaseWhereInput
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateWithoutQualificationPhasesInput, Prisma.QualificationFlowPhaseUncheckedUpdateWithoutQualificationPhasesInput>
}

export type QualificationFlowPhaseUpdateWithoutQualificationPhasesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutQualificationPhasesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseCreateManyTenantInput = {
  id?: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseCreateManyDocumentationPlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateWithoutDocumentationPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutDocumentationPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutDocumentationPlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseCreateManyQuestionnairePlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateWithoutQuestionnairePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutQuestionnairePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutQuestionnairePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseCreateManyGatePlanInput = {
  id?: string
  tenantId: string
  qualificationFlowId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateWithoutGatePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  qualificationFlow?: Prisma.QualificationFlowUpdateOneRequiredWithoutPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutGatePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutGatePlanInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  qualificationFlowId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QualificationFlowPhaseCreateManyQualificationFlowInput = {
  id?: string
  tenantId: string
  questionnairePlanId?: string | null
  documentationPlanId?: string | null
  gatePlanId?: string | null
  name: string
  description?: string | null
  phaseCategory: $Enums.PhaseCategory
  phaseType: $Enums.PhaseType
  order: number
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type QualificationFlowPhaseUpdateWithoutQualificationFlowInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutQualificationFlowPhasesNestedInput
  questionnairePlan?: Prisma.QuestionnairePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  documentationPlan?: Prisma.DocumentationPlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  gatePlan?: Prisma.GatePlanUpdateOneWithoutQualificationFlowPhasesNestedInput
  qualificationPhases?: Prisma.QualificationPhaseUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateWithoutQualificationFlowInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  qualificationPhases?: Prisma.QualificationPhaseUncheckedUpdateManyWithoutPhaseTemplateNestedInput
}

export type QualificationFlowPhaseUncheckedUpdateManyWithoutQualificationFlowInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  questionnairePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  documentationPlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  gatePlanId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  name?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  phaseCategory?: Prisma.EnumPhaseCategoryFieldUpdateOperationsInput | $Enums.PhaseCategory
  phaseType?: Prisma.EnumPhaseTypeFieldUpdateOperationsInput | $Enums.PhaseType
  order?: Prisma.IntFieldUpdateOperationsInput | number
  requiresPreviousPhaseCompletion?: Prisma.BoolFieldUpdateOperationsInput | boolean
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type QualificationFlowPhaseCountOutputType
 */

export type QualificationFlowPhaseCountOutputType = {
  qualificationPhases: number
}

export type QualificationFlowPhaseCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  qualificationPhases?: boolean | QualificationFlowPhaseCountOutputTypeCountQualificationPhasesArgs
}

/**
 * QualificationFlowPhaseCountOutputType without action
 */
export type QualificationFlowPhaseCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhaseCountOutputType
   */
  select?: Prisma.QualificationFlowPhaseCountOutputTypeSelect<ExtArgs> | null
}

/**
 * QualificationFlowPhaseCountOutputType without action
 */
export type QualificationFlowPhaseCountOutputTypeCountQualificationPhasesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.QualificationPhaseWhereInput
}


export type QualificationFlowPhaseSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  qualificationFlowId?: boolean
  questionnairePlanId?: boolean
  documentationPlanId?: boolean
  gatePlanId?: boolean
  name?: boolean
  description?: boolean
  phaseCategory?: boolean
  phaseType?: boolean
  order?: boolean
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  qualificationFlow?: boolean | Prisma.QualificationFlowDefaultArgs<ExtArgs>
  questionnairePlan?: boolean | Prisma.QualificationFlowPhase$questionnairePlanArgs<ExtArgs>
  documentationPlan?: boolean | Prisma.QualificationFlowPhase$documentationPlanArgs<ExtArgs>
  gatePlan?: boolean | Prisma.QualificationFlowPhase$gatePlanArgs<ExtArgs>
  qualificationPhases?: boolean | Prisma.QualificationFlowPhase$qualificationPhasesArgs<ExtArgs>
  _count?: boolean | Prisma.QualificationFlowPhaseCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["qualificationFlowPhase"]>



export type QualificationFlowPhaseSelectScalar = {
  id?: boolean
  tenantId?: boolean
  qualificationFlowId?: boolean
  questionnairePlanId?: boolean
  documentationPlanId?: boolean
  gatePlanId?: boolean
  name?: boolean
  description?: boolean
  phaseCategory?: boolean
  phaseType?: boolean
  order?: boolean
  requiresPreviousPhaseCompletion?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type QualificationFlowPhaseOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "tenantId" | "qualificationFlowId" | "questionnairePlanId" | "documentationPlanId" | "gatePlanId" | "name" | "description" | "phaseCategory" | "phaseType" | "order" | "requiresPreviousPhaseCompletion" | "createdAt" | "updatedAt", ExtArgs["result"]["qualificationFlowPhase"]>
export type QualificationFlowPhaseInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  qualificationFlow?: boolean | Prisma.QualificationFlowDefaultArgs<ExtArgs>
  questionnairePlan?: boolean | Prisma.QualificationFlowPhase$questionnairePlanArgs<ExtArgs>
  documentationPlan?: boolean | Prisma.QualificationFlowPhase$documentationPlanArgs<ExtArgs>
  gatePlan?: boolean | Prisma.QualificationFlowPhase$gatePlanArgs<ExtArgs>
  qualificationPhases?: boolean | Prisma.QualificationFlowPhase$qualificationPhasesArgs<ExtArgs>
  _count?: boolean | Prisma.QualificationFlowPhaseCountOutputTypeDefaultArgs<ExtArgs>
}

export type $QualificationFlowPhasePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "QualificationFlowPhase"
  objects: {
    tenant: Prisma.$TenantPayload<ExtArgs>
    qualificationFlow: Prisma.$QualificationFlowPayload<ExtArgs>
    questionnairePlan: Prisma.$QuestionnairePlanPayload<ExtArgs> | null
    documentationPlan: Prisma.$DocumentationPlanPayload<ExtArgs> | null
    gatePlan: Prisma.$GatePlanPayload<ExtArgs> | null
    qualificationPhases: Prisma.$QualificationPhasePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    tenantId: string
    qualificationFlowId: string
    questionnairePlanId: string | null
    documentationPlanId: string | null
    gatePlanId: string | null
    name: string
    description: string | null
    phaseCategory: $Enums.PhaseCategory
    phaseType: $Enums.PhaseType
    order: number
    requiresPreviousPhaseCompletion: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["qualificationFlowPhase"]>
  composites: {}
}

export type QualificationFlowPhaseGetPayload<S extends boolean | null | undefined | QualificationFlowPhaseDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload, S>

export type QualificationFlowPhaseCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<QualificationFlowPhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: QualificationFlowPhaseCountAggregateInputType | true
  }

export interface QualificationFlowPhaseDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualificationFlowPhase'], meta: { name: 'QualificationFlowPhase' } }
  /**
   * Find zero or one QualificationFlowPhase that matches the filter.
   * @param {QualificationFlowPhaseFindUniqueArgs} args - Arguments to find a QualificationFlowPhase
   * @example
   * // Get one QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends QualificationFlowPhaseFindUniqueArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseFindUniqueArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one QualificationFlowPhase that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {QualificationFlowPhaseFindUniqueOrThrowArgs} args - Arguments to find a QualificationFlowPhase
   * @example
   * // Get one QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends QualificationFlowPhaseFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first QualificationFlowPhase that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseFindFirstArgs} args - Arguments to find a QualificationFlowPhase
   * @example
   * // Get one QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends QualificationFlowPhaseFindFirstArgs>(args?: Prisma.SelectSubset<T, QualificationFlowPhaseFindFirstArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first QualificationFlowPhase that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseFindFirstOrThrowArgs} args - Arguments to find a QualificationFlowPhase
   * @example
   * // Get one QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends QualificationFlowPhaseFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, QualificationFlowPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more QualificationFlowPhases that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all QualificationFlowPhases
   * const qualificationFlowPhases = await prisma.qualificationFlowPhase.findMany()
   * 
   * // Get first 10 QualificationFlowPhases
   * const qualificationFlowPhases = await prisma.qualificationFlowPhase.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const qualificationFlowPhaseWithIdOnly = await prisma.qualificationFlowPhase.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends QualificationFlowPhaseFindManyArgs>(args?: Prisma.SelectSubset<T, QualificationFlowPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a QualificationFlowPhase.
   * @param {QualificationFlowPhaseCreateArgs} args - Arguments to create a QualificationFlowPhase.
   * @example
   * // Create one QualificationFlowPhase
   * const QualificationFlowPhase = await prisma.qualificationFlowPhase.create({
   *   data: {
   *     // ... data to create a QualificationFlowPhase
   *   }
   * })
   * 
   */
  create<T extends QualificationFlowPhaseCreateArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseCreateArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many QualificationFlowPhases.
   * @param {QualificationFlowPhaseCreateManyArgs} args - Arguments to create many QualificationFlowPhases.
   * @example
   * // Create many QualificationFlowPhases
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends QualificationFlowPhaseCreateManyArgs>(args?: Prisma.SelectSubset<T, QualificationFlowPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a QualificationFlowPhase.
   * @param {QualificationFlowPhaseDeleteArgs} args - Arguments to delete one QualificationFlowPhase.
   * @example
   * // Delete one QualificationFlowPhase
   * const QualificationFlowPhase = await prisma.qualificationFlowPhase.delete({
   *   where: {
   *     // ... filter to delete one QualificationFlowPhase
   *   }
   * })
   * 
   */
  delete<T extends QualificationFlowPhaseDeleteArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseDeleteArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one QualificationFlowPhase.
   * @param {QualificationFlowPhaseUpdateArgs} args - Arguments to update one QualificationFlowPhase.
   * @example
   * // Update one QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends QualificationFlowPhaseUpdateArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseUpdateArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more QualificationFlowPhases.
   * @param {QualificationFlowPhaseDeleteManyArgs} args - Arguments to filter QualificationFlowPhases to delete.
   * @example
   * // Delete a few QualificationFlowPhases
   * const { count } = await prisma.qualificationFlowPhase.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends QualificationFlowPhaseDeleteManyArgs>(args?: Prisma.SelectSubset<T, QualificationFlowPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more QualificationFlowPhases.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many QualificationFlowPhases
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends QualificationFlowPhaseUpdateManyArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one QualificationFlowPhase.
   * @param {QualificationFlowPhaseUpsertArgs} args - Arguments to update or create a QualificationFlowPhase.
   * @example
   * // Update or create a QualificationFlowPhase
   * const qualificationFlowPhase = await prisma.qualificationFlowPhase.upsert({
   *   create: {
   *     // ... data to create a QualificationFlowPhase
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the QualificationFlowPhase we want to update
   *   }
   * })
   */
  upsert<T extends QualificationFlowPhaseUpsertArgs>(args: Prisma.SelectSubset<T, QualificationFlowPhaseUpsertArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowPhaseClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of QualificationFlowPhases.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseCountArgs} args - Arguments to filter QualificationFlowPhases to count.
   * @example
   * // Count the number of QualificationFlowPhases
   * const count = await prisma.qualificationFlowPhase.count({
   *   where: {
   *     // ... the filter for the QualificationFlowPhases we want to count
   *   }
   * })
  **/
  count<T extends QualificationFlowPhaseCountArgs>(
    args?: Prisma.Subset<T, QualificationFlowPhaseCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], QualificationFlowPhaseCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a QualificationFlowPhase.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends QualificationFlowPhaseAggregateArgs>(args: Prisma.Subset<T, QualificationFlowPhaseAggregateArgs>): Prisma.PrismaPromise<GetQualificationFlowPhaseAggregateType<T>>

  /**
   * Group by QualificationFlowPhase.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QualificationFlowPhaseGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends QualificationFlowPhaseGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: QualificationFlowPhaseGroupByArgs['orderBy'] }
      : { orderBy?: QualificationFlowPhaseGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, QualificationFlowPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualificationFlowPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the QualificationFlowPhase model
 */
readonly fields: QualificationFlowPhaseFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for QualificationFlowPhase.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__QualificationFlowPhaseClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  tenant<T extends Prisma.TenantDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TenantDefaultArgs<ExtArgs>>): Prisma.Prisma__TenantClient<runtime.Types.Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  qualificationFlow<T extends Prisma.QualificationFlowDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QualificationFlowDefaultArgs<ExtArgs>>): Prisma.Prisma__QualificationFlowClient<runtime.Types.Result.GetResult<Prisma.$QualificationFlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  questionnairePlan<T extends Prisma.QualificationFlowPhase$questionnairePlanArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QualificationFlowPhase$questionnairePlanArgs<ExtArgs>>): Prisma.Prisma__QuestionnairePlanClient<runtime.Types.Result.GetResult<Prisma.$QuestionnairePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  documentationPlan<T extends Prisma.QualificationFlowPhase$documentationPlanArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QualificationFlowPhase$documentationPlanArgs<ExtArgs>>): Prisma.Prisma__DocumentationPlanClient<runtime.Types.Result.GetResult<Prisma.$DocumentationPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  gatePlan<T extends Prisma.QualificationFlowPhase$gatePlanArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QualificationFlowPhase$gatePlanArgs<ExtArgs>>): Prisma.Prisma__GatePlanClient<runtime.Types.Result.GetResult<Prisma.$GatePlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  qualificationPhases<T extends Prisma.QualificationFlowPhase$qualificationPhasesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QualificationFlowPhase$qualificationPhasesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$QualificationPhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the QualificationFlowPhase model
 */
export interface QualificationFlowPhaseFieldRefs {
  readonly id: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly tenantId: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly qualificationFlowId: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly questionnairePlanId: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly documentationPlanId: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly gatePlanId: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly name: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly description: Prisma.FieldRef<"QualificationFlowPhase", 'String'>
  readonly phaseCategory: Prisma.FieldRef<"QualificationFlowPhase", 'PhaseCategory'>
  readonly phaseType: Prisma.FieldRef<"QualificationFlowPhase", 'PhaseType'>
  readonly order: Prisma.FieldRef<"QualificationFlowPhase", 'Int'>
  readonly requiresPreviousPhaseCompletion: Prisma.FieldRef<"QualificationFlowPhase", 'Boolean'>
  readonly createdAt: Prisma.FieldRef<"QualificationFlowPhase", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"QualificationFlowPhase", 'DateTime'>
}
    

// Custom InputTypes
/**
 * QualificationFlowPhase findUnique
 */
export type QualificationFlowPhaseFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter, which QualificationFlowPhase to fetch.
   */
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
}

/**
 * QualificationFlowPhase findUniqueOrThrow
 */
export type QualificationFlowPhaseFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter, which QualificationFlowPhase to fetch.
   */
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
}

/**
 * QualificationFlowPhase findFirst
 */
export type QualificationFlowPhaseFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter, which QualificationFlowPhase to fetch.
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QualificationFlowPhases to fetch.
   */
  orderBy?: Prisma.QualificationFlowPhaseOrderByWithRelationInput | Prisma.QualificationFlowPhaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for QualificationFlowPhases.
   */
  cursor?: Prisma.QualificationFlowPhaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QualificationFlowPhases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QualificationFlowPhases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of QualificationFlowPhases.
   */
  distinct?: Prisma.QualificationFlowPhaseScalarFieldEnum | Prisma.QualificationFlowPhaseScalarFieldEnum[]
}

/**
 * QualificationFlowPhase findFirstOrThrow
 */
export type QualificationFlowPhaseFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter, which QualificationFlowPhase to fetch.
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QualificationFlowPhases to fetch.
   */
  orderBy?: Prisma.QualificationFlowPhaseOrderByWithRelationInput | Prisma.QualificationFlowPhaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for QualificationFlowPhases.
   */
  cursor?: Prisma.QualificationFlowPhaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QualificationFlowPhases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QualificationFlowPhases.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of QualificationFlowPhases.
   */
  distinct?: Prisma.QualificationFlowPhaseScalarFieldEnum | Prisma.QualificationFlowPhaseScalarFieldEnum[]
}

/**
 * QualificationFlowPhase findMany
 */
export type QualificationFlowPhaseFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter, which QualificationFlowPhases to fetch.
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QualificationFlowPhases to fetch.
   */
  orderBy?: Prisma.QualificationFlowPhaseOrderByWithRelationInput | Prisma.QualificationFlowPhaseOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing QualificationFlowPhases.
   */
  cursor?: Prisma.QualificationFlowPhaseWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QualificationFlowPhases from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QualificationFlowPhases.
   */
  skip?: number
  distinct?: Prisma.QualificationFlowPhaseScalarFieldEnum | Prisma.QualificationFlowPhaseScalarFieldEnum[]
}

/**
 * QualificationFlowPhase create
 */
export type QualificationFlowPhaseCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * The data needed to create a QualificationFlowPhase.
   */
  data: Prisma.XOR<Prisma.QualificationFlowPhaseCreateInput, Prisma.QualificationFlowPhaseUncheckedCreateInput>
}

/**
 * QualificationFlowPhase createMany
 */
export type QualificationFlowPhaseCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many QualificationFlowPhases.
   */
  data: Prisma.QualificationFlowPhaseCreateManyInput | Prisma.QualificationFlowPhaseCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * QualificationFlowPhase update
 */
export type QualificationFlowPhaseUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * The data needed to update a QualificationFlowPhase.
   */
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateInput, Prisma.QualificationFlowPhaseUncheckedUpdateInput>
  /**
   * Choose, which QualificationFlowPhase to update.
   */
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
}

/**
 * QualificationFlowPhase updateMany
 */
export type QualificationFlowPhaseUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update QualificationFlowPhases.
   */
  data: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateManyMutationInput, Prisma.QualificationFlowPhaseUncheckedUpdateManyInput>
  /**
   * Filter which QualificationFlowPhases to update
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * Limit how many QualificationFlowPhases to update.
   */
  limit?: number
}

/**
 * QualificationFlowPhase upsert
 */
export type QualificationFlowPhaseUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * The filter to search for the QualificationFlowPhase to update in case it exists.
   */
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
  /**
   * In case the QualificationFlowPhase found by the `where` argument doesn't exist, create a new QualificationFlowPhase with this data.
   */
  create: Prisma.XOR<Prisma.QualificationFlowPhaseCreateInput, Prisma.QualificationFlowPhaseUncheckedCreateInput>
  /**
   * In case the QualificationFlowPhase was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.QualificationFlowPhaseUpdateInput, Prisma.QualificationFlowPhaseUncheckedUpdateInput>
}

/**
 * QualificationFlowPhase delete
 */
export type QualificationFlowPhaseDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
  /**
   * Filter which QualificationFlowPhase to delete.
   */
  where: Prisma.QualificationFlowPhaseWhereUniqueInput
}

/**
 * QualificationFlowPhase deleteMany
 */
export type QualificationFlowPhaseDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which QualificationFlowPhases to delete
   */
  where?: Prisma.QualificationFlowPhaseWhereInput
  /**
   * Limit how many QualificationFlowPhases to delete.
   */
  limit?: number
}

/**
 * QualificationFlowPhase.questionnairePlan
 */
export type QualificationFlowPhase$questionnairePlanArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionnairePlan
   */
  select?: Prisma.QuestionnairePlanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionnairePlan
   */
  omit?: Prisma.QuestionnairePlanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionnairePlanInclude<ExtArgs> | null
  where?: Prisma.QuestionnairePlanWhereInput
}

/**
 * QualificationFlowPhase.documentationPlan
 */
export type QualificationFlowPhase$documentationPlanArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the DocumentationPlan
   */
  select?: Prisma.DocumentationPlanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the DocumentationPlan
   */
  omit?: Prisma.DocumentationPlanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DocumentationPlanInclude<ExtArgs> | null
  where?: Prisma.DocumentationPlanWhereInput
}

/**
 * QualificationFlowPhase.gatePlan
 */
export type QualificationFlowPhase$gatePlanArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GatePlan
   */
  select?: Prisma.GatePlanSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GatePlan
   */
  omit?: Prisma.GatePlanOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GatePlanInclude<ExtArgs> | null
  where?: Prisma.GatePlanWhereInput
}

/**
 * QualificationFlowPhase.qualificationPhases
 */
export type QualificationFlowPhase$qualificationPhasesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationPhase
   */
  select?: Prisma.QualificationPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationPhase
   */
  omit?: Prisma.QualificationPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationPhaseInclude<ExtArgs> | null
  where?: Prisma.QualificationPhaseWhereInput
  orderBy?: Prisma.QualificationPhaseOrderByWithRelationInput | Prisma.QualificationPhaseOrderByWithRelationInput[]
  cursor?: Prisma.QualificationPhaseWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.QualificationPhaseScalarFieldEnum | Prisma.QualificationPhaseScalarFieldEnum[]
}

/**
 * QualificationFlowPhase without action
 */
export type QualificationFlowPhaseDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QualificationFlowPhase
   */
  select?: Prisma.QualificationFlowPhaseSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QualificationFlowPhase
   */
  omit?: Prisma.QualificationFlowPhaseOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QualificationFlowPhaseInclude<ExtArgs> | null
}
