
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.4.1
 * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.4.1",
  engine: "55ae170b1ced7fc6ed07a15f110549408c501bb3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  OrganizationType: 'OrganizationType',
  OrganizationTypeAssignment: 'OrganizationTypeAssignment',
  User: 'User',
  Role: 'Role',
  Permission: 'Permission',
  RolePermission: 'RolePermission',
  TenantMembership: 'TenantMembership',
  Organization: 'Organization',
  OrganizationMember: 'OrganizationMember',
  OrganizationInvitation: 'OrganizationInvitation',
  OnboardingFlow: 'OnboardingFlow',
  OnboardingFlowPhase: 'OnboardingFlowPhase',
  OrganizationOnboarding: 'OrganizationOnboarding',
  OnboardingPhase: 'OnboardingPhase',
  BankDocumentRequirement: 'BankDocumentRequirement',
  Tenant: 'Tenant',
  ApiKey: 'ApiKey',
  RefreshToken: 'RefreshToken',
  PasswordReset: 'PasswordReset',
  UserSuspension: 'UserSuspension',
  EmailPreference: 'EmailPreference',
  DeviceEndpoint: 'DeviceEndpoint',
  Social: 'Social',
  OAuthState: 'OAuthState',
  Wallet: 'Wallet',
  Transaction: 'Transaction',
  Settings: 'Settings',
  Property: 'Property',
  PropertyMedia: 'PropertyMedia',
  PropertyDocument: 'PropertyDocument',
  Amenity: 'Amenity',
  PropertyVariant: 'PropertyVariant',
  PropertyVariantAmenity: 'PropertyVariantAmenity',
  PropertyVariantMedia: 'PropertyVariantMedia',
  PropertyUnit: 'PropertyUnit',
  PropertyAmenity: 'PropertyAmenity',
  DocumentationPlan: 'DocumentationPlan',
  DocumentDefinition: 'DocumentDefinition',
  ApprovalStage: 'ApprovalStage',
  QuestionnairePlan: 'QuestionnairePlan',
  QuestionnairePlanQuestion: 'QuestionnairePlanQuestion',
  GatePlan: 'GatePlan',
  PaymentPlan: 'PaymentPlan',
  PropertyPaymentMethod: 'PropertyPaymentMethod',
  PropertyPaymentMethodLink: 'PropertyPaymentMethodLink',
  PropertyPaymentMethodPhase: 'PropertyPaymentMethodPhase',
  PhaseEventAttachment: 'PhaseEventAttachment',
  Application: 'Application',
  CoApplicant: 'CoApplicant',
  ApplicationOrganization: 'ApplicationOrganization',
  ApplicationRefund: 'ApplicationRefund',
  ApplicationPhase: 'ApplicationPhase',
  QuestionnairePhase: 'QuestionnairePhase',
  QuestionnairePhaseReview: 'QuestionnairePhaseReview',
  GatePhase: 'GatePhase',
  GatePhaseReview: 'GatePhaseReview',
  DocumentationPhase: 'DocumentationPhase',
  PaymentPhase: 'PaymentPhase',
  QuestionnaireField: 'QuestionnaireField',
  ApplicationEvent: 'ApplicationEvent',
  PaymentInstallment: 'PaymentInstallment',
  ApplicationPayment: 'ApplicationPayment',
  ApplicationDocument: 'ApplicationDocument',
  DocumentReview: 'DocumentReview',
  ApprovalStageProgress: 'ApprovalStageProgress',
  DocumentApproval: 'DocumentApproval',
  DocumentTemplate: 'DocumentTemplate',
  OfferLetter: 'OfferLetter',
  ApplicationTermination: 'ApplicationTermination',
  PaymentMethodChangeRequest: 'PaymentMethodChangeRequest',
  DocumentRequirementRule: 'DocumentRequirementRule',
  EventChannel: 'EventChannel',
  EventType: 'EventType',
  EventHandler: 'EventHandler',
  DomainEvent: 'DomainEvent',
  PropertyTransferRequest: 'PropertyTransferRequest',
  ApprovalRequest: 'ApprovalRequest',
  WorkflowBlocker: 'WorkflowBlocker',
  ScheduledJob: 'ScheduledJob',
  DocumentExpiryWarning: 'DocumentExpiryWarning',
  QualificationFlow: 'QualificationFlow',
  QualificationFlowPhase: 'QualificationFlowPhase',
  OrganizationPaymentMethod: 'OrganizationPaymentMethod',
  PaymentMethodQualification: 'PaymentMethodQualification',
  QualificationPhase: 'QualificationPhase',
  PaymentMethodQualificationConfig: 'PaymentMethodQualificationConfig',
  OrganizationDocumentWaiver: 'OrganizationDocumentWaiver',
  AsyncJob: 'AsyncJob'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "organizationType" | "organizationTypeAssignment" | "user" | "role" | "permission" | "rolePermission" | "tenantMembership" | "organization" | "organizationMember" | "organizationInvitation" | "onboardingFlow" | "onboardingFlowPhase" | "organizationOnboarding" | "onboardingPhase" | "bankDocumentRequirement" | "tenant" | "apiKey" | "refreshToken" | "passwordReset" | "userSuspension" | "emailPreference" | "deviceEndpoint" | "social" | "oAuthState" | "wallet" | "transaction" | "settings" | "property" | "propertyMedia" | "propertyDocument" | "amenity" | "propertyVariant" | "propertyVariantAmenity" | "propertyVariantMedia" | "propertyUnit" | "propertyAmenity" | "documentationPlan" | "documentDefinition" | "approvalStage" | "questionnairePlan" | "questionnairePlanQuestion" | "gatePlan" | "paymentPlan" | "propertyPaymentMethod" | "propertyPaymentMethodLink" | "propertyPaymentMethodPhase" | "phaseEventAttachment" | "application" | "coApplicant" | "applicationOrganization" | "applicationRefund" | "applicationPhase" | "questionnairePhase" | "questionnairePhaseReview" | "gatePhase" | "gatePhaseReview" | "documentationPhase" | "paymentPhase" | "questionnaireField" | "applicationEvent" | "paymentInstallment" | "applicationPayment" | "applicationDocument" | "documentReview" | "approvalStageProgress" | "documentApproval" | "documentTemplate" | "offerLetter" | "applicationTermination" | "paymentMethodChangeRequest" | "documentRequirementRule" | "eventChannel" | "eventType" | "eventHandler" | "domainEvent" | "propertyTransferRequest" | "approvalRequest" | "workflowBlocker" | "scheduledJob" | "documentExpiryWarning" | "qualificationFlow" | "qualificationFlowPhase" | "organizationPaymentMethod" | "paymentMethodQualification" | "qualificationPhase" | "paymentMethodQualificationConfig" | "organizationDocumentWaiver" | "asyncJob"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    OrganizationType: {
      payload: Prisma.$OrganizationTypePayload<ExtArgs>
      fields: Prisma.OrganizationTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        findFirst: {
          args: Prisma.OrganizationTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        findMany: {
          args: Prisma.OrganizationTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>[]
        }
        create: {
          args: Prisma.OrganizationTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        createMany: {
          args: Prisma.OrganizationTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        update: {
          args: Prisma.OrganizationTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        deleteMany: {
          args: Prisma.OrganizationTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypePayload>
        }
        aggregate: {
          args: Prisma.OrganizationTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationType>
        }
        groupBy: {
          args: Prisma.OrganizationTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationTypeCountAggregateOutputType> | number
        }
      }
    }
    OrganizationTypeAssignment: {
      payload: Prisma.$OrganizationTypeAssignmentPayload<ExtArgs>
      fields: Prisma.OrganizationTypeAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationTypeAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationTypeAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        findFirst: {
          args: Prisma.OrganizationTypeAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationTypeAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        findMany: {
          args: Prisma.OrganizationTypeAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>[]
        }
        create: {
          args: Prisma.OrganizationTypeAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        createMany: {
          args: Prisma.OrganizationTypeAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationTypeAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        update: {
          args: Prisma.OrganizationTypeAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationTypeAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationTypeAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationTypeAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationTypeAssignmentPayload>
        }
        aggregate: {
          args: Prisma.OrganizationTypeAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationTypeAssignment>
        }
        groupBy: {
          args: Prisma.OrganizationTypeAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationTypeAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationTypeAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationTypeAssignmentCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    Permission: {
      payload: Prisma.$PermissionPayload<ExtArgs>
      fields: Prisma.PermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        update: {
          args: Prisma.PermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    TenantMembership: {
      payload: Prisma.$TenantMembershipPayload<ExtArgs>
      fields: Prisma.TenantMembershipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantMembershipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantMembershipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        findFirst: {
          args: Prisma.TenantMembershipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantMembershipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        findMany: {
          args: Prisma.TenantMembershipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>[]
        }
        create: {
          args: Prisma.TenantMembershipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        createMany: {
          args: Prisma.TenantMembershipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.TenantMembershipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        update: {
          args: Prisma.TenantMembershipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        deleteMany: {
          args: Prisma.TenantMembershipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantMembershipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.TenantMembershipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
        }
        aggregate: {
          args: Prisma.TenantMembershipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantMembership>
        }
        groupBy: {
          args: Prisma.TenantMembershipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMembershipGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantMembershipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMembershipCountAggregateOutputType> | number
        }
      }
    }
    Organization: {
      payload: Prisma.$OrganizationPayload<ExtArgs>
      fields: Prisma.OrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        findMany: {
          args: Prisma.OrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
        }
        create: {
          args: Prisma.OrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        createMany: {
          args: Prisma.OrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        update: {
          args: Prisma.OrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganization>
        }
        groupBy: {
          args: Prisma.OrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationCountAggregateOutputType> | number
        }
      }
    }
    OrganizationMember: {
      payload: Prisma.$OrganizationMemberPayload<ExtArgs>
      fields: Prisma.OrganizationMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        findFirst: {
          args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        findMany: {
          args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
        }
        create: {
          args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        createMany: {
          args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        update: {
          args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
        }
        aggregate: {
          args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationMember>
        }
        groupBy: {
          args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationMemberCountAggregateOutputType> | number
        }
      }
    }
    OrganizationInvitation: {
      payload: Prisma.$OrganizationInvitationPayload<ExtArgs>
      fields: Prisma.OrganizationInvitationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationInvitationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        findFirst: {
          args: Prisma.OrganizationInvitationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationInvitationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        findMany: {
          args: Prisma.OrganizationInvitationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
        }
        create: {
          args: Prisma.OrganizationInvitationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        createMany: {
          args: Prisma.OrganizationInvitationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationInvitationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        update: {
          args: Prisma.OrganizationInvitationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationInvitationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationInvitationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationInvitationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
        }
        aggregate: {
          args: Prisma.OrganizationInvitationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationInvitation>
        }
        groupBy: {
          args: Prisma.OrganizationInvitationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationInvitationGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationInvitationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationInvitationCountAggregateOutputType> | number
        }
      }
    }
    OnboardingFlow: {
      payload: Prisma.$OnboardingFlowPayload<ExtArgs>
      fields: Prisma.OnboardingFlowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingFlowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingFlowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        findFirst: {
          args: Prisma.OnboardingFlowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingFlowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        findMany: {
          args: Prisma.OnboardingFlowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>[]
        }
        create: {
          args: Prisma.OnboardingFlowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        createMany: {
          args: Prisma.OnboardingFlowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OnboardingFlowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        update: {
          args: Prisma.OnboardingFlowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        deleteMany: {
          args: Prisma.OnboardingFlowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingFlowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OnboardingFlowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPayload>
        }
        aggregate: {
          args: Prisma.OnboardingFlowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingFlow>
        }
        groupBy: {
          args: Prisma.OnboardingFlowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingFlowGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingFlowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingFlowCountAggregateOutputType> | number
        }
      }
    }
    OnboardingFlowPhase: {
      payload: Prisma.$OnboardingFlowPhasePayload<ExtArgs>
      fields: Prisma.OnboardingFlowPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingFlowPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingFlowPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        findFirst: {
          args: Prisma.OnboardingFlowPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingFlowPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        findMany: {
          args: Prisma.OnboardingFlowPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>[]
        }
        create: {
          args: Prisma.OnboardingFlowPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        createMany: {
          args: Prisma.OnboardingFlowPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OnboardingFlowPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        update: {
          args: Prisma.OnboardingFlowPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        deleteMany: {
          args: Prisma.OnboardingFlowPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingFlowPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OnboardingFlowPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingFlowPhasePayload>
        }
        aggregate: {
          args: Prisma.OnboardingFlowPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingFlowPhase>
        }
        groupBy: {
          args: Prisma.OnboardingFlowPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingFlowPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingFlowPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingFlowPhaseCountAggregateOutputType> | number
        }
      }
    }
    OrganizationOnboarding: {
      payload: Prisma.$OrganizationOnboardingPayload<ExtArgs>
      fields: Prisma.OrganizationOnboardingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationOnboardingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationOnboardingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        findFirst: {
          args: Prisma.OrganizationOnboardingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationOnboardingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        findMany: {
          args: Prisma.OrganizationOnboardingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>[]
        }
        create: {
          args: Prisma.OrganizationOnboardingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        createMany: {
          args: Prisma.OrganizationOnboardingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationOnboardingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        update: {
          args: Prisma.OrganizationOnboardingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationOnboardingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationOnboardingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationOnboardingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationOnboardingPayload>
        }
        aggregate: {
          args: Prisma.OrganizationOnboardingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationOnboarding>
        }
        groupBy: {
          args: Prisma.OrganizationOnboardingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationOnboardingGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationOnboardingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationOnboardingCountAggregateOutputType> | number
        }
      }
    }
    OnboardingPhase: {
      payload: Prisma.$OnboardingPhasePayload<ExtArgs>
      fields: Prisma.OnboardingPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OnboardingPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OnboardingPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        findFirst: {
          args: Prisma.OnboardingPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OnboardingPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        findMany: {
          args: Prisma.OnboardingPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>[]
        }
        create: {
          args: Prisma.OnboardingPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        createMany: {
          args: Prisma.OnboardingPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OnboardingPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        update: {
          args: Prisma.OnboardingPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        deleteMany: {
          args: Prisma.OnboardingPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OnboardingPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OnboardingPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OnboardingPhasePayload>
        }
        aggregate: {
          args: Prisma.OnboardingPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOnboardingPhase>
        }
        groupBy: {
          args: Prisma.OnboardingPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.OnboardingPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OnboardingPhaseCountAggregateOutputType> | number
        }
      }
    }
    BankDocumentRequirement: {
      payload: Prisma.$BankDocumentRequirementPayload<ExtArgs>
      fields: Prisma.BankDocumentRequirementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankDocumentRequirementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankDocumentRequirementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        findFirst: {
          args: Prisma.BankDocumentRequirementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankDocumentRequirementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        findMany: {
          args: Prisma.BankDocumentRequirementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>[]
        }
        create: {
          args: Prisma.BankDocumentRequirementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        createMany: {
          args: Prisma.BankDocumentRequirementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.BankDocumentRequirementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        update: {
          args: Prisma.BankDocumentRequirementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        deleteMany: {
          args: Prisma.BankDocumentRequirementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankDocumentRequirementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.BankDocumentRequirementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankDocumentRequirementPayload>
        }
        aggregate: {
          args: Prisma.BankDocumentRequirementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankDocumentRequirement>
        }
        groupBy: {
          args: Prisma.BankDocumentRequirementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankDocumentRequirementGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankDocumentRequirementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankDocumentRequirementCountAggregateOutputType> | number
        }
      }
    }
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    ApiKey: {
      payload: Prisma.$ApiKeyPayload<ExtArgs>
      fields: Prisma.ApiKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findFirst: {
          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findMany: {
          args: Prisma.ApiKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        create: {
          args: Prisma.ApiKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        createMany: {
          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApiKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        update: {
          args: Prisma.ApiKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        deleteMany: {
          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApiKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        aggregate: {
          args: Prisma.ApiKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>
        }
        groupBy: {
          args: Prisma.ApiKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApiKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number
        }
      }
    }
    RefreshToken: {
      payload: Prisma.$RefreshTokenPayload<ExtArgs>
      fields: Prisma.RefreshTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findFirst: {
          args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findMany: {
          args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        create: {
          args: Prisma.RefreshTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        createMany: {
          args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        update: {
          args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        deleteMany: {
          args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        aggregate: {
          args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefreshToken>
        }
        groupBy: {
          args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefreshTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenCountAggregateOutputType> | number
        }
      }
    }
    PasswordReset: {
      payload: Prisma.$PasswordResetPayload<ExtArgs>
      fields: Prisma.PasswordResetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        findFirst: {
          args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        findMany: {
          args: Prisma.PasswordResetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
        }
        create: {
          args: Prisma.PasswordResetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        createMany: {
          args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PasswordResetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        update: {
          args: Prisma.PasswordResetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        deleteMany: {
          args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PasswordResetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PasswordResetPayload>
        }
        aggregate: {
          args: Prisma.PasswordResetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePasswordReset>
        }
        groupBy: {
          args: Prisma.PasswordResetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetGroupByOutputType>[]
        }
        count: {
          args: Prisma.PasswordResetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PasswordResetCountAggregateOutputType> | number
        }
      }
    }
    UserSuspension: {
      payload: Prisma.$UserSuspensionPayload<ExtArgs>
      fields: Prisma.UserSuspensionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSuspensionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSuspensionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        findFirst: {
          args: Prisma.UserSuspensionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSuspensionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        findMany: {
          args: Prisma.UserSuspensionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>[]
        }
        create: {
          args: Prisma.UserSuspensionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        createMany: {
          args: Prisma.UserSuspensionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.UserSuspensionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        update: {
          args: Prisma.UserSuspensionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        deleteMany: {
          args: Prisma.UserSuspensionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSuspensionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.UserSuspensionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSuspensionPayload>
        }
        aggregate: {
          args: Prisma.UserSuspensionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSuspension>
        }
        groupBy: {
          args: Prisma.UserSuspensionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSuspensionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSuspensionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSuspensionCountAggregateOutputType> | number
        }
      }
    }
    EmailPreference: {
      payload: Prisma.$EmailPreferencePayload<ExtArgs>
      fields: Prisma.EmailPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        findFirst: {
          args: Prisma.EmailPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        findMany: {
          args: Prisma.EmailPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>[]
        }
        create: {
          args: Prisma.EmailPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        createMany: {
          args: Prisma.EmailPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EmailPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        update: {
          args: Prisma.EmailPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        deleteMany: {
          args: Prisma.EmailPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EmailPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailPreferencePayload>
        }
        aggregate: {
          args: Prisma.EmailPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailPreference>
        }
        groupBy: {
          args: Prisma.EmailPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailPreferenceCountAggregateOutputType> | number
        }
      }
    }
    DeviceEndpoint: {
      payload: Prisma.$DeviceEndpointPayload<ExtArgs>
      fields: Prisma.DeviceEndpointFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeviceEndpointFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeviceEndpointFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        findFirst: {
          args: Prisma.DeviceEndpointFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeviceEndpointFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        findMany: {
          args: Prisma.DeviceEndpointFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>[]
        }
        create: {
          args: Prisma.DeviceEndpointCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        createMany: {
          args: Prisma.DeviceEndpointCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DeviceEndpointDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        update: {
          args: Prisma.DeviceEndpointUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        deleteMany: {
          args: Prisma.DeviceEndpointDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeviceEndpointUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DeviceEndpointUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceEndpointPayload>
        }
        aggregate: {
          args: Prisma.DeviceEndpointAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeviceEndpoint>
        }
        groupBy: {
          args: Prisma.DeviceEndpointGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceEndpointGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeviceEndpointCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceEndpointCountAggregateOutputType> | number
        }
      }
    }
    Social: {
      payload: Prisma.$SocialPayload<ExtArgs>
      fields: Prisma.SocialFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SocialFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SocialFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        findFirst: {
          args: Prisma.SocialFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SocialFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        findMany: {
          args: Prisma.SocialFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>[]
        }
        create: {
          args: Prisma.SocialCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        createMany: {
          args: Prisma.SocialCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SocialDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        update: {
          args: Prisma.SocialUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        deleteMany: {
          args: Prisma.SocialDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SocialUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SocialUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialPayload>
        }
        aggregate: {
          args: Prisma.SocialAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSocial>
        }
        groupBy: {
          args: Prisma.SocialGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialGroupByOutputType>[]
        }
        count: {
          args: Prisma.SocialCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialCountAggregateOutputType> | number
        }
      }
    }
    OAuthState: {
      payload: Prisma.$OAuthStatePayload<ExtArgs>
      fields: Prisma.OAuthStateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OAuthStateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OAuthStateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        findFirst: {
          args: Prisma.OAuthStateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OAuthStateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        findMany: {
          args: Prisma.OAuthStateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>[]
        }
        create: {
          args: Prisma.OAuthStateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        createMany: {
          args: Prisma.OAuthStateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OAuthStateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        update: {
          args: Prisma.OAuthStateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        deleteMany: {
          args: Prisma.OAuthStateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OAuthStateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OAuthStateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OAuthStatePayload>
        }
        aggregate: {
          args: Prisma.OAuthStateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOAuthState>
        }
        groupBy: {
          args: Prisma.OAuthStateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthStateGroupByOutputType>[]
        }
        count: {
          args: Prisma.OAuthStateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OAuthStateCountAggregateOutputType> | number
        }
      }
    }
    Wallet: {
      payload: Prisma.$WalletPayload<ExtArgs>
      fields: Prisma.WalletFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WalletFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findFirst: {
          args: Prisma.WalletFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        findMany: {
          args: Prisma.WalletFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>[]
        }
        create: {
          args: Prisma.WalletCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        createMany: {
          args: Prisma.WalletCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.WalletDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        update: {
          args: Prisma.WalletUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        deleteMany: {
          args: Prisma.WalletDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WalletUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.WalletUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WalletPayload>
        }
        aggregate: {
          args: Prisma.WalletAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWallet>
        }
        groupBy: {
          args: Prisma.WalletGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletGroupByOutputType>[]
        }
        count: {
          args: Prisma.WalletCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WalletCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    Settings: {
      payload: Prisma.$SettingsPayload<ExtArgs>
      fields: Prisma.SettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        findFirst: {
          args: Prisma.SettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        findMany: {
          args: Prisma.SettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>[]
        }
        create: {
          args: Prisma.SettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        createMany: {
          args: Prisma.SettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.SettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        update: {
          args: Prisma.SettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        deleteMany: {
          args: Prisma.SettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.SettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SettingsPayload>
        }
        aggregate: {
          args: Prisma.SettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSettings>
        }
        groupBy: {
          args: Prisma.SettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SettingsCountAggregateOutputType> | number
        }
      }
    }
    Property: {
      payload: Prisma.$PropertyPayload<ExtArgs>
      fields: Prisma.PropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findFirst: {
          args: Prisma.PropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findMany: {
          args: Prisma.PropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        create: {
          args: Prisma.PropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        createMany: {
          args: Prisma.PropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        update: {
          args: Prisma.PropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        deleteMany: {
          args: Prisma.PropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        aggregate: {
          args: Prisma.PropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty>
        }
        groupBy: {
          args: Prisma.PropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCountAggregateOutputType> | number
        }
      }
    }
    PropertyMedia: {
      payload: Prisma.$PropertyMediaPayload<ExtArgs>
      fields: Prisma.PropertyMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        findFirst: {
          args: Prisma.PropertyMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        findMany: {
          args: Prisma.PropertyMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>[]
        }
        create: {
          args: Prisma.PropertyMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        createMany: {
          args: Prisma.PropertyMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        update: {
          args: Prisma.PropertyMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        deleteMany: {
          args: Prisma.PropertyMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyMediaPayload>
        }
        aggregate: {
          args: Prisma.PropertyMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyMedia>
        }
        groupBy: {
          args: Prisma.PropertyMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyMediaCountAggregateOutputType> | number
        }
      }
    }
    PropertyDocument: {
      payload: Prisma.$PropertyDocumentPayload<ExtArgs>
      fields: Prisma.PropertyDocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyDocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyDocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        findFirst: {
          args: Prisma.PropertyDocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyDocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        findMany: {
          args: Prisma.PropertyDocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>[]
        }
        create: {
          args: Prisma.PropertyDocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        createMany: {
          args: Prisma.PropertyDocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyDocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        update: {
          args: Prisma.PropertyDocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        deleteMany: {
          args: Prisma.PropertyDocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyDocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyDocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyDocumentPayload>
        }
        aggregate: {
          args: Prisma.PropertyDocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyDocument>
        }
        groupBy: {
          args: Prisma.PropertyDocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyDocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyDocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyDocumentCountAggregateOutputType> | number
        }
      }
    }
    Amenity: {
      payload: Prisma.$AmenityPayload<ExtArgs>
      fields: Prisma.AmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findFirst: {
          args: Prisma.AmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findMany: {
          args: Prisma.AmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        create: {
          args: Prisma.AmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        createMany: {
          args: Prisma.AmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.AmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        update: {
          args: Prisma.AmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        deleteMany: {
          args: Prisma.AmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.AmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        aggregate: {
          args: Prisma.AmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAmenity>
        }
        groupBy: {
          args: Prisma.AmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.AmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityCountAggregateOutputType> | number
        }
      }
    }
    PropertyVariant: {
      payload: Prisma.$PropertyVariantPayload<ExtArgs>
      fields: Prisma.PropertyVariantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyVariantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyVariantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        findFirst: {
          args: Prisma.PropertyVariantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyVariantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        findMany: {
          args: Prisma.PropertyVariantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>[]
        }
        create: {
          args: Prisma.PropertyVariantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        createMany: {
          args: Prisma.PropertyVariantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyVariantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        update: {
          args: Prisma.PropertyVariantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        deleteMany: {
          args: Prisma.PropertyVariantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyVariantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyVariantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantPayload>
        }
        aggregate: {
          args: Prisma.PropertyVariantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyVariant>
        }
        groupBy: {
          args: Prisma.PropertyVariantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyVariantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantCountAggregateOutputType> | number
        }
      }
    }
    PropertyVariantAmenity: {
      payload: Prisma.$PropertyVariantAmenityPayload<ExtArgs>
      fields: Prisma.PropertyVariantAmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyVariantAmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyVariantAmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        findFirst: {
          args: Prisma.PropertyVariantAmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyVariantAmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        findMany: {
          args: Prisma.PropertyVariantAmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>[]
        }
        create: {
          args: Prisma.PropertyVariantAmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        createMany: {
          args: Prisma.PropertyVariantAmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyVariantAmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        update: {
          args: Prisma.PropertyVariantAmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        deleteMany: {
          args: Prisma.PropertyVariantAmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyVariantAmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyVariantAmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantAmenityPayload>
        }
        aggregate: {
          args: Prisma.PropertyVariantAmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyVariantAmenity>
        }
        groupBy: {
          args: Prisma.PropertyVariantAmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantAmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyVariantAmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantAmenityCountAggregateOutputType> | number
        }
      }
    }
    PropertyVariantMedia: {
      payload: Prisma.$PropertyVariantMediaPayload<ExtArgs>
      fields: Prisma.PropertyVariantMediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyVariantMediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyVariantMediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        findFirst: {
          args: Prisma.PropertyVariantMediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyVariantMediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        findMany: {
          args: Prisma.PropertyVariantMediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>[]
        }
        create: {
          args: Prisma.PropertyVariantMediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        createMany: {
          args: Prisma.PropertyVariantMediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyVariantMediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        update: {
          args: Prisma.PropertyVariantMediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        deleteMany: {
          args: Prisma.PropertyVariantMediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyVariantMediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyVariantMediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyVariantMediaPayload>
        }
        aggregate: {
          args: Prisma.PropertyVariantMediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyVariantMedia>
        }
        groupBy: {
          args: Prisma.PropertyVariantMediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantMediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyVariantMediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyVariantMediaCountAggregateOutputType> | number
        }
      }
    }
    PropertyUnit: {
      payload: Prisma.$PropertyUnitPayload<ExtArgs>
      fields: Prisma.PropertyUnitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyUnitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyUnitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        findFirst: {
          args: Prisma.PropertyUnitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyUnitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        findMany: {
          args: Prisma.PropertyUnitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>[]
        }
        create: {
          args: Prisma.PropertyUnitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        createMany: {
          args: Prisma.PropertyUnitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyUnitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        update: {
          args: Prisma.PropertyUnitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        deleteMany: {
          args: Prisma.PropertyUnitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyUnitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyUnitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyUnitPayload>
        }
        aggregate: {
          args: Prisma.PropertyUnitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyUnit>
        }
        groupBy: {
          args: Prisma.PropertyUnitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyUnitGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyUnitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyUnitCountAggregateOutputType> | number
        }
      }
    }
    PropertyAmenity: {
      payload: Prisma.$PropertyAmenityPayload<ExtArgs>
      fields: Prisma.PropertyAmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyAmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyAmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        findFirst: {
          args: Prisma.PropertyAmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyAmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        findMany: {
          args: Prisma.PropertyAmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>[]
        }
        create: {
          args: Prisma.PropertyAmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        createMany: {
          args: Prisma.PropertyAmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyAmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        update: {
          args: Prisma.PropertyAmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        deleteMany: {
          args: Prisma.PropertyAmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyAmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyAmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
        }
        aggregate: {
          args: Prisma.PropertyAmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyAmenity>
        }
        groupBy: {
          args: Prisma.PropertyAmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyAmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyAmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyAmenityCountAggregateOutputType> | number
        }
      }
    }
    DocumentationPlan: {
      payload: Prisma.$DocumentationPlanPayload<ExtArgs>
      fields: Prisma.DocumentationPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentationPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentationPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        findFirst: {
          args: Prisma.DocumentationPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentationPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        findMany: {
          args: Prisma.DocumentationPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>[]
        }
        create: {
          args: Prisma.DocumentationPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        createMany: {
          args: Prisma.DocumentationPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentationPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        update: {
          args: Prisma.DocumentationPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        deleteMany: {
          args: Prisma.DocumentationPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentationPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentationPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPlanPayload>
        }
        aggregate: {
          args: Prisma.DocumentationPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentationPlan>
        }
        groupBy: {
          args: Prisma.DocumentationPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentationPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentationPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentationPlanCountAggregateOutputType> | number
        }
      }
    }
    DocumentDefinition: {
      payload: Prisma.$DocumentDefinitionPayload<ExtArgs>
      fields: Prisma.DocumentDefinitionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentDefinitionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentDefinitionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        findFirst: {
          args: Prisma.DocumentDefinitionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentDefinitionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        findMany: {
          args: Prisma.DocumentDefinitionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>[]
        }
        create: {
          args: Prisma.DocumentDefinitionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        createMany: {
          args: Prisma.DocumentDefinitionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentDefinitionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        update: {
          args: Prisma.DocumentDefinitionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDefinitionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentDefinitionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentDefinitionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentDefinitionPayload>
        }
        aggregate: {
          args: Prisma.DocumentDefinitionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentDefinition>
        }
        groupBy: {
          args: Prisma.DocumentDefinitionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDefinitionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentDefinitionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentDefinitionCountAggregateOutputType> | number
        }
      }
    }
    ApprovalStage: {
      payload: Prisma.$ApprovalStagePayload<ExtArgs>
      fields: Prisma.ApprovalStageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApprovalStageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApprovalStageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        findFirst: {
          args: Prisma.ApprovalStageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApprovalStageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        findMany: {
          args: Prisma.ApprovalStageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>[]
        }
        create: {
          args: Prisma.ApprovalStageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        createMany: {
          args: Prisma.ApprovalStageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApprovalStageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        update: {
          args: Prisma.ApprovalStageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        deleteMany: {
          args: Prisma.ApprovalStageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApprovalStageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApprovalStageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStagePayload>
        }
        aggregate: {
          args: Prisma.ApprovalStageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApprovalStage>
        }
        groupBy: {
          args: Prisma.ApprovalStageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalStageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApprovalStageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalStageCountAggregateOutputType> | number
        }
      }
    }
    QuestionnairePlan: {
      payload: Prisma.$QuestionnairePlanPayload<ExtArgs>
      fields: Prisma.QuestionnairePlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionnairePlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionnairePlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        findFirst: {
          args: Prisma.QuestionnairePlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionnairePlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        findMany: {
          args: Prisma.QuestionnairePlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>[]
        }
        create: {
          args: Prisma.QuestionnairePlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        createMany: {
          args: Prisma.QuestionnairePlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QuestionnairePlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        update: {
          args: Prisma.QuestionnairePlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        deleteMany: {
          args: Prisma.QuestionnairePlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionnairePlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QuestionnairePlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanPayload>
        }
        aggregate: {
          args: Prisma.QuestionnairePlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionnairePlan>
        }
        groupBy: {
          args: Prisma.QuestionnairePlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionnairePlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePlanCountAggregateOutputType> | number
        }
      }
    }
    QuestionnairePlanQuestion: {
      payload: Prisma.$QuestionnairePlanQuestionPayload<ExtArgs>
      fields: Prisma.QuestionnairePlanQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionnairePlanQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionnairePlanQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        findFirst: {
          args: Prisma.QuestionnairePlanQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionnairePlanQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        findMany: {
          args: Prisma.QuestionnairePlanQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>[]
        }
        create: {
          args: Prisma.QuestionnairePlanQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        createMany: {
          args: Prisma.QuestionnairePlanQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QuestionnairePlanQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        update: {
          args: Prisma.QuestionnairePlanQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        deleteMany: {
          args: Prisma.QuestionnairePlanQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionnairePlanQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QuestionnairePlanQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePlanQuestionPayload>
        }
        aggregate: {
          args: Prisma.QuestionnairePlanQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionnairePlanQuestion>
        }
        groupBy: {
          args: Prisma.QuestionnairePlanQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePlanQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionnairePlanQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePlanQuestionCountAggregateOutputType> | number
        }
      }
    }
    GatePlan: {
      payload: Prisma.$GatePlanPayload<ExtArgs>
      fields: Prisma.GatePlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GatePlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GatePlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        findFirst: {
          args: Prisma.GatePlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GatePlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        findMany: {
          args: Prisma.GatePlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>[]
        }
        create: {
          args: Prisma.GatePlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        createMany: {
          args: Prisma.GatePlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.GatePlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        update: {
          args: Prisma.GatePlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        deleteMany: {
          args: Prisma.GatePlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GatePlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.GatePlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePlanPayload>
        }
        aggregate: {
          args: Prisma.GatePlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGatePlan>
        }
        groupBy: {
          args: Prisma.GatePlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.GatePlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePlanCountAggregateOutputType> | number
        }
      }
    }
    PaymentPlan: {
      payload: Prisma.$PaymentPlanPayload<ExtArgs>
      fields: Prisma.PaymentPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        findFirst: {
          args: Prisma.PaymentPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        findMany: {
          args: Prisma.PaymentPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
        }
        create: {
          args: Prisma.PaymentPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        createMany: {
          args: Prisma.PaymentPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        update: {
          args: Prisma.PaymentPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        deleteMany: {
          args: Prisma.PaymentPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        aggregate: {
          args: Prisma.PaymentPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentPlan>
        }
        groupBy: {
          args: Prisma.PaymentPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPlanCountAggregateOutputType> | number
        }
      }
    }
    PropertyPaymentMethod: {
      payload: Prisma.$PropertyPaymentMethodPayload<ExtArgs>
      fields: Prisma.PropertyPaymentMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyPaymentMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        findFirst: {
          args: Prisma.PropertyPaymentMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyPaymentMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        findMany: {
          args: Prisma.PropertyPaymentMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>[]
        }
        create: {
          args: Prisma.PropertyPaymentMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        createMany: {
          args: Prisma.PropertyPaymentMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyPaymentMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        update: {
          args: Prisma.PropertyPaymentMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        deleteMany: {
          args: Prisma.PropertyPaymentMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyPaymentMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyPaymentMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPayload>
        }
        aggregate: {
          args: Prisma.PropertyPaymentMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyPaymentMethod>
        }
        groupBy: {
          args: Prisma.PropertyPaymentMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyPaymentMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodCountAggregateOutputType> | number
        }
      }
    }
    PropertyPaymentMethodLink: {
      payload: Prisma.$PropertyPaymentMethodLinkPayload<ExtArgs>
      fields: Prisma.PropertyPaymentMethodLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyPaymentMethodLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyPaymentMethodLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        findFirst: {
          args: Prisma.PropertyPaymentMethodLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyPaymentMethodLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        findMany: {
          args: Prisma.PropertyPaymentMethodLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>[]
        }
        create: {
          args: Prisma.PropertyPaymentMethodLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        createMany: {
          args: Prisma.PropertyPaymentMethodLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyPaymentMethodLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        update: {
          args: Prisma.PropertyPaymentMethodLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        deleteMany: {
          args: Prisma.PropertyPaymentMethodLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyPaymentMethodLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyPaymentMethodLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodLinkPayload>
        }
        aggregate: {
          args: Prisma.PropertyPaymentMethodLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyPaymentMethodLink>
        }
        groupBy: {
          args: Prisma.PropertyPaymentMethodLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyPaymentMethodLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodLinkCountAggregateOutputType> | number
        }
      }
    }
    PropertyPaymentMethodPhase: {
      payload: Prisma.$PropertyPaymentMethodPhasePayload<ExtArgs>
      fields: Prisma.PropertyPaymentMethodPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyPaymentMethodPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyPaymentMethodPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        findFirst: {
          args: Prisma.PropertyPaymentMethodPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyPaymentMethodPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        findMany: {
          args: Prisma.PropertyPaymentMethodPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>[]
        }
        create: {
          args: Prisma.PropertyPaymentMethodPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        createMany: {
          args: Prisma.PropertyPaymentMethodPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyPaymentMethodPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        update: {
          args: Prisma.PropertyPaymentMethodPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        deleteMany: {
          args: Prisma.PropertyPaymentMethodPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyPaymentMethodPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyPaymentMethodPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPaymentMethodPhasePayload>
        }
        aggregate: {
          args: Prisma.PropertyPaymentMethodPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyPaymentMethodPhase>
        }
        groupBy: {
          args: Prisma.PropertyPaymentMethodPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyPaymentMethodPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyPaymentMethodPhaseCountAggregateOutputType> | number
        }
      }
    }
    PhaseEventAttachment: {
      payload: Prisma.$PhaseEventAttachmentPayload<ExtArgs>
      fields: Prisma.PhaseEventAttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PhaseEventAttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PhaseEventAttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        findFirst: {
          args: Prisma.PhaseEventAttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PhaseEventAttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        findMany: {
          args: Prisma.PhaseEventAttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>[]
        }
        create: {
          args: Prisma.PhaseEventAttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        createMany: {
          args: Prisma.PhaseEventAttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PhaseEventAttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        update: {
          args: Prisma.PhaseEventAttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        deleteMany: {
          args: Prisma.PhaseEventAttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PhaseEventAttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PhaseEventAttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PhaseEventAttachmentPayload>
        }
        aggregate: {
          args: Prisma.PhaseEventAttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePhaseEventAttachment>
        }
        groupBy: {
          args: Prisma.PhaseEventAttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PhaseEventAttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PhaseEventAttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PhaseEventAttachmentCountAggregateOutputType> | number
        }
      }
    }
    Application: {
      payload: Prisma.$ApplicationPayload<ExtArgs>
      fields: Prisma.ApplicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        findFirst: {
          args: Prisma.ApplicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        findMany: {
          args: Prisma.ApplicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
        }
        create: {
          args: Prisma.ApplicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        createMany: {
          args: Prisma.ApplicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        update: {
          args: Prisma.ApplicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPayload>
        }
        aggregate: {
          args: Prisma.ApplicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplication>
        }
        groupBy: {
          args: Prisma.ApplicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationCountAggregateOutputType> | number
        }
      }
    }
    CoApplicant: {
      payload: Prisma.$CoApplicantPayload<ExtArgs>
      fields: Prisma.CoApplicantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CoApplicantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CoApplicantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        findFirst: {
          args: Prisma.CoApplicantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CoApplicantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        findMany: {
          args: Prisma.CoApplicantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>[]
        }
        create: {
          args: Prisma.CoApplicantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        createMany: {
          args: Prisma.CoApplicantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.CoApplicantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        update: {
          args: Prisma.CoApplicantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        deleteMany: {
          args: Prisma.CoApplicantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CoApplicantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.CoApplicantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CoApplicantPayload>
        }
        aggregate: {
          args: Prisma.CoApplicantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCoApplicant>
        }
        groupBy: {
          args: Prisma.CoApplicantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CoApplicantGroupByOutputType>[]
        }
        count: {
          args: Prisma.CoApplicantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CoApplicantCountAggregateOutputType> | number
        }
      }
    }
    ApplicationOrganization: {
      payload: Prisma.$ApplicationOrganizationPayload<ExtArgs>
      fields: Prisma.ApplicationOrganizationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationOrganizationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationOrganizationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        findFirst: {
          args: Prisma.ApplicationOrganizationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationOrganizationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        findMany: {
          args: Prisma.ApplicationOrganizationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>[]
        }
        create: {
          args: Prisma.ApplicationOrganizationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        createMany: {
          args: Prisma.ApplicationOrganizationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationOrganizationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        update: {
          args: Prisma.ApplicationOrganizationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationOrganizationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationOrganizationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationOrganizationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationOrganizationPayload>
        }
        aggregate: {
          args: Prisma.ApplicationOrganizationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationOrganization>
        }
        groupBy: {
          args: Prisma.ApplicationOrganizationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationOrganizationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationOrganizationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationOrganizationCountAggregateOutputType> | number
        }
      }
    }
    ApplicationRefund: {
      payload: Prisma.$ApplicationRefundPayload<ExtArgs>
      fields: Prisma.ApplicationRefundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationRefundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationRefundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        findFirst: {
          args: Prisma.ApplicationRefundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationRefundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        findMany: {
          args: Prisma.ApplicationRefundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>[]
        }
        create: {
          args: Prisma.ApplicationRefundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        createMany: {
          args: Prisma.ApplicationRefundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationRefundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        update: {
          args: Prisma.ApplicationRefundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationRefundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationRefundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationRefundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationRefundPayload>
        }
        aggregate: {
          args: Prisma.ApplicationRefundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationRefund>
        }
        groupBy: {
          args: Prisma.ApplicationRefundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationRefundGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationRefundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationRefundCountAggregateOutputType> | number
        }
      }
    }
    ApplicationPhase: {
      payload: Prisma.$ApplicationPhasePayload<ExtArgs>
      fields: Prisma.ApplicationPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        findFirst: {
          args: Prisma.ApplicationPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        findMany: {
          args: Prisma.ApplicationPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>[]
        }
        create: {
          args: Prisma.ApplicationPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        createMany: {
          args: Prisma.ApplicationPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        update: {
          args: Prisma.ApplicationPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        deleteMany: {
          args: Prisma.ApplicationPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPhasePayload>
        }
        aggregate: {
          args: Prisma.ApplicationPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationPhase>
        }
        groupBy: {
          args: Prisma.ApplicationPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationPhaseCountAggregateOutputType> | number
        }
      }
    }
    QuestionnairePhase: {
      payload: Prisma.$QuestionnairePhasePayload<ExtArgs>
      fields: Prisma.QuestionnairePhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionnairePhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionnairePhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        findFirst: {
          args: Prisma.QuestionnairePhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionnairePhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        findMany: {
          args: Prisma.QuestionnairePhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>[]
        }
        create: {
          args: Prisma.QuestionnairePhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        createMany: {
          args: Prisma.QuestionnairePhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QuestionnairePhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        update: {
          args: Prisma.QuestionnairePhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        deleteMany: {
          args: Prisma.QuestionnairePhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionnairePhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QuestionnairePhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhasePayload>
        }
        aggregate: {
          args: Prisma.QuestionnairePhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionnairePhase>
        }
        groupBy: {
          args: Prisma.QuestionnairePhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionnairePhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePhaseCountAggregateOutputType> | number
        }
      }
    }
    QuestionnairePhaseReview: {
      payload: Prisma.$QuestionnairePhaseReviewPayload<ExtArgs>
      fields: Prisma.QuestionnairePhaseReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionnairePhaseReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionnairePhaseReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        findFirst: {
          args: Prisma.QuestionnairePhaseReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionnairePhaseReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        findMany: {
          args: Prisma.QuestionnairePhaseReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>[]
        }
        create: {
          args: Prisma.QuestionnairePhaseReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        createMany: {
          args: Prisma.QuestionnairePhaseReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QuestionnairePhaseReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        update: {
          args: Prisma.QuestionnairePhaseReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        deleteMany: {
          args: Prisma.QuestionnairePhaseReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionnairePhaseReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QuestionnairePhaseReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnairePhaseReviewPayload>
        }
        aggregate: {
          args: Prisma.QuestionnairePhaseReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionnairePhaseReview>
        }
        groupBy: {
          args: Prisma.QuestionnairePhaseReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePhaseReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionnairePhaseReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnairePhaseReviewCountAggregateOutputType> | number
        }
      }
    }
    GatePhase: {
      payload: Prisma.$GatePhasePayload<ExtArgs>
      fields: Prisma.GatePhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GatePhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GatePhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        findFirst: {
          args: Prisma.GatePhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GatePhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        findMany: {
          args: Prisma.GatePhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>[]
        }
        create: {
          args: Prisma.GatePhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        createMany: {
          args: Prisma.GatePhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.GatePhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        update: {
          args: Prisma.GatePhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        deleteMany: {
          args: Prisma.GatePhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GatePhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.GatePhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhasePayload>
        }
        aggregate: {
          args: Prisma.GatePhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGatePhase>
        }
        groupBy: {
          args: Prisma.GatePhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.GatePhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePhaseCountAggregateOutputType> | number
        }
      }
    }
    GatePhaseReview: {
      payload: Prisma.$GatePhaseReviewPayload<ExtArgs>
      fields: Prisma.GatePhaseReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GatePhaseReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GatePhaseReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        findFirst: {
          args: Prisma.GatePhaseReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GatePhaseReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        findMany: {
          args: Prisma.GatePhaseReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>[]
        }
        create: {
          args: Prisma.GatePhaseReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        createMany: {
          args: Prisma.GatePhaseReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.GatePhaseReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        update: {
          args: Prisma.GatePhaseReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        deleteMany: {
          args: Prisma.GatePhaseReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GatePhaseReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.GatePhaseReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GatePhaseReviewPayload>
        }
        aggregate: {
          args: Prisma.GatePhaseReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGatePhaseReview>
        }
        groupBy: {
          args: Prisma.GatePhaseReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePhaseReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.GatePhaseReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GatePhaseReviewCountAggregateOutputType> | number
        }
      }
    }
    DocumentationPhase: {
      payload: Prisma.$DocumentationPhasePayload<ExtArgs>
      fields: Prisma.DocumentationPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentationPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentationPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        findFirst: {
          args: Prisma.DocumentationPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentationPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        findMany: {
          args: Prisma.DocumentationPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>[]
        }
        create: {
          args: Prisma.DocumentationPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        createMany: {
          args: Prisma.DocumentationPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentationPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        update: {
          args: Prisma.DocumentationPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        deleteMany: {
          args: Prisma.DocumentationPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentationPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentationPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentationPhasePayload>
        }
        aggregate: {
          args: Prisma.DocumentationPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentationPhase>
        }
        groupBy: {
          args: Prisma.DocumentationPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentationPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentationPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentationPhaseCountAggregateOutputType> | number
        }
      }
    }
    PaymentPhase: {
      payload: Prisma.$PaymentPhasePayload<ExtArgs>
      fields: Prisma.PaymentPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        findFirst: {
          args: Prisma.PaymentPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        findMany: {
          args: Prisma.PaymentPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>[]
        }
        create: {
          args: Prisma.PaymentPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        createMany: {
          args: Prisma.PaymentPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        update: {
          args: Prisma.PaymentPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        deleteMany: {
          args: Prisma.PaymentPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPhasePayload>
        }
        aggregate: {
          args: Prisma.PaymentPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentPhase>
        }
        groupBy: {
          args: Prisma.PaymentPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPhaseCountAggregateOutputType> | number
        }
      }
    }
    QuestionnaireField: {
      payload: Prisma.$QuestionnaireFieldPayload<ExtArgs>
      fields: Prisma.QuestionnaireFieldFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuestionnaireFieldFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuestionnaireFieldFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        findFirst: {
          args: Prisma.QuestionnaireFieldFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuestionnaireFieldFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        findMany: {
          args: Prisma.QuestionnaireFieldFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>[]
        }
        create: {
          args: Prisma.QuestionnaireFieldCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        createMany: {
          args: Prisma.QuestionnaireFieldCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QuestionnaireFieldDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        update: {
          args: Prisma.QuestionnaireFieldUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        deleteMany: {
          args: Prisma.QuestionnaireFieldDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuestionnaireFieldUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QuestionnaireFieldUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuestionnaireFieldPayload>
        }
        aggregate: {
          args: Prisma.QuestionnaireFieldAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuestionnaireField>
        }
        groupBy: {
          args: Prisma.QuestionnaireFieldGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnaireFieldGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuestionnaireFieldCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuestionnaireFieldCountAggregateOutputType> | number
        }
      }
    }
    ApplicationEvent: {
      payload: Prisma.$ApplicationEventPayload<ExtArgs>
      fields: Prisma.ApplicationEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        findFirst: {
          args: Prisma.ApplicationEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        findMany: {
          args: Prisma.ApplicationEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>[]
        }
        create: {
          args: Prisma.ApplicationEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        createMany: {
          args: Prisma.ApplicationEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        update: {
          args: Prisma.ApplicationEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationEventPayload>
        }
        aggregate: {
          args: Prisma.ApplicationEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationEvent>
        }
        groupBy: {
          args: Prisma.ApplicationEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationEventCountAggregateOutputType> | number
        }
      }
    }
    PaymentInstallment: {
      payload: Prisma.$PaymentInstallmentPayload<ExtArgs>
      fields: Prisma.PaymentInstallmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentInstallmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentInstallmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        findFirst: {
          args: Prisma.PaymentInstallmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentInstallmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        findMany: {
          args: Prisma.PaymentInstallmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>[]
        }
        create: {
          args: Prisma.PaymentInstallmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        createMany: {
          args: Prisma.PaymentInstallmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentInstallmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        update: {
          args: Prisma.PaymentInstallmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentInstallmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentInstallmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentInstallmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentInstallmentPayload>
        }
        aggregate: {
          args: Prisma.PaymentInstallmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentInstallment>
        }
        groupBy: {
          args: Prisma.PaymentInstallmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentInstallmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentInstallmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentInstallmentCountAggregateOutputType> | number
        }
      }
    }
    ApplicationPayment: {
      payload: Prisma.$ApplicationPaymentPayload<ExtArgs>
      fields: Prisma.ApplicationPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        findFirst: {
          args: Prisma.ApplicationPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        findMany: {
          args: Prisma.ApplicationPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>[]
        }
        create: {
          args: Prisma.ApplicationPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        createMany: {
          args: Prisma.ApplicationPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        update: {
          args: Prisma.ApplicationPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationPaymentPayload>
        }
        aggregate: {
          args: Prisma.ApplicationPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationPayment>
        }
        groupBy: {
          args: Prisma.ApplicationPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationPaymentCountAggregateOutputType> | number
        }
      }
    }
    ApplicationDocument: {
      payload: Prisma.$ApplicationDocumentPayload<ExtArgs>
      fields: Prisma.ApplicationDocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationDocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationDocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        findFirst: {
          args: Prisma.ApplicationDocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationDocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        findMany: {
          args: Prisma.ApplicationDocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>[]
        }
        create: {
          args: Prisma.ApplicationDocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        createMany: {
          args: Prisma.ApplicationDocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationDocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        update: {
          args: Prisma.ApplicationDocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationDocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationDocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationDocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationDocumentPayload>
        }
        aggregate: {
          args: Prisma.ApplicationDocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationDocument>
        }
        groupBy: {
          args: Prisma.ApplicationDocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationDocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationDocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationDocumentCountAggregateOutputType> | number
        }
      }
    }
    DocumentReview: {
      payload: Prisma.$DocumentReviewPayload<ExtArgs>
      fields: Prisma.DocumentReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        findFirst: {
          args: Prisma.DocumentReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        findMany: {
          args: Prisma.DocumentReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>[]
        }
        create: {
          args: Prisma.DocumentReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        createMany: {
          args: Prisma.DocumentReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        update: {
          args: Prisma.DocumentReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        deleteMany: {
          args: Prisma.DocumentReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentReviewPayload>
        }
        aggregate: {
          args: Prisma.DocumentReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentReview>
        }
        groupBy: {
          args: Prisma.DocumentReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentReviewCountAggregateOutputType> | number
        }
      }
    }
    ApprovalStageProgress: {
      payload: Prisma.$ApprovalStageProgressPayload<ExtArgs>
      fields: Prisma.ApprovalStageProgressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApprovalStageProgressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApprovalStageProgressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        findFirst: {
          args: Prisma.ApprovalStageProgressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApprovalStageProgressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        findMany: {
          args: Prisma.ApprovalStageProgressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>[]
        }
        create: {
          args: Prisma.ApprovalStageProgressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        createMany: {
          args: Prisma.ApprovalStageProgressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApprovalStageProgressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        update: {
          args: Prisma.ApprovalStageProgressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        deleteMany: {
          args: Prisma.ApprovalStageProgressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApprovalStageProgressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApprovalStageProgressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalStageProgressPayload>
        }
        aggregate: {
          args: Prisma.ApprovalStageProgressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApprovalStageProgress>
        }
        groupBy: {
          args: Prisma.ApprovalStageProgressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalStageProgressGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApprovalStageProgressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalStageProgressCountAggregateOutputType> | number
        }
      }
    }
    DocumentApproval: {
      payload: Prisma.$DocumentApprovalPayload<ExtArgs>
      fields: Prisma.DocumentApprovalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentApprovalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentApprovalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        findFirst: {
          args: Prisma.DocumentApprovalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentApprovalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        findMany: {
          args: Prisma.DocumentApprovalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>[]
        }
        create: {
          args: Prisma.DocumentApprovalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        createMany: {
          args: Prisma.DocumentApprovalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentApprovalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        update: {
          args: Prisma.DocumentApprovalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        deleteMany: {
          args: Prisma.DocumentApprovalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentApprovalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentApprovalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentApprovalPayload>
        }
        aggregate: {
          args: Prisma.DocumentApprovalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentApproval>
        }
        groupBy: {
          args: Prisma.DocumentApprovalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentApprovalGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentApprovalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentApprovalCountAggregateOutputType> | number
        }
      }
    }
    DocumentTemplate: {
      payload: Prisma.$DocumentTemplatePayload<ExtArgs>
      fields: Prisma.DocumentTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        findFirst: {
          args: Prisma.DocumentTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        findMany: {
          args: Prisma.DocumentTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>[]
        }
        create: {
          args: Prisma.DocumentTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        createMany: {
          args: Prisma.DocumentTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        update: {
          args: Prisma.DocumentTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        deleteMany: {
          args: Prisma.DocumentTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTemplatePayload>
        }
        aggregate: {
          args: Prisma.DocumentTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentTemplate>
        }
        groupBy: {
          args: Prisma.DocumentTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTemplateCountAggregateOutputType> | number
        }
      }
    }
    OfferLetter: {
      payload: Prisma.$OfferLetterPayload<ExtArgs>
      fields: Prisma.OfferLetterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OfferLetterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OfferLetterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        findFirst: {
          args: Prisma.OfferLetterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OfferLetterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        findMany: {
          args: Prisma.OfferLetterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>[]
        }
        create: {
          args: Prisma.OfferLetterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        createMany: {
          args: Prisma.OfferLetterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OfferLetterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        update: {
          args: Prisma.OfferLetterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        deleteMany: {
          args: Prisma.OfferLetterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OfferLetterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OfferLetterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OfferLetterPayload>
        }
        aggregate: {
          args: Prisma.OfferLetterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOfferLetter>
        }
        groupBy: {
          args: Prisma.OfferLetterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferLetterGroupByOutputType>[]
        }
        count: {
          args: Prisma.OfferLetterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OfferLetterCountAggregateOutputType> | number
        }
      }
    }
    ApplicationTermination: {
      payload: Prisma.$ApplicationTerminationPayload<ExtArgs>
      fields: Prisma.ApplicationTerminationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApplicationTerminationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApplicationTerminationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        findFirst: {
          args: Prisma.ApplicationTerminationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApplicationTerminationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        findMany: {
          args: Prisma.ApplicationTerminationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>[]
        }
        create: {
          args: Prisma.ApplicationTerminationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        createMany: {
          args: Prisma.ApplicationTerminationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApplicationTerminationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        update: {
          args: Prisma.ApplicationTerminationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        deleteMany: {
          args: Prisma.ApplicationTerminationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApplicationTerminationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApplicationTerminationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApplicationTerminationPayload>
        }
        aggregate: {
          args: Prisma.ApplicationTerminationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApplicationTermination>
        }
        groupBy: {
          args: Prisma.ApplicationTerminationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationTerminationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApplicationTerminationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApplicationTerminationCountAggregateOutputType> | number
        }
      }
    }
    PaymentMethodChangeRequest: {
      payload: Prisma.$PaymentMethodChangeRequestPayload<ExtArgs>
      fields: Prisma.PaymentMethodChangeRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentMethodChangeRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentMethodChangeRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        findFirst: {
          args: Prisma.PaymentMethodChangeRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentMethodChangeRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        findMany: {
          args: Prisma.PaymentMethodChangeRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>[]
        }
        create: {
          args: Prisma.PaymentMethodChangeRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        createMany: {
          args: Prisma.PaymentMethodChangeRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentMethodChangeRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        update: {
          args: Prisma.PaymentMethodChangeRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        deleteMany: {
          args: Prisma.PaymentMethodChangeRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentMethodChangeRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentMethodChangeRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodChangeRequestPayload>
        }
        aggregate: {
          args: Prisma.PaymentMethodChangeRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentMethodChangeRequest>
        }
        groupBy: {
          args: Prisma.PaymentMethodChangeRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodChangeRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentMethodChangeRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodChangeRequestCountAggregateOutputType> | number
        }
      }
    }
    DocumentRequirementRule: {
      payload: Prisma.$DocumentRequirementRulePayload<ExtArgs>
      fields: Prisma.DocumentRequirementRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentRequirementRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentRequirementRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        findFirst: {
          args: Prisma.DocumentRequirementRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentRequirementRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        findMany: {
          args: Prisma.DocumentRequirementRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>[]
        }
        create: {
          args: Prisma.DocumentRequirementRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        createMany: {
          args: Prisma.DocumentRequirementRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentRequirementRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        update: {
          args: Prisma.DocumentRequirementRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        deleteMany: {
          args: Prisma.DocumentRequirementRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentRequirementRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentRequirementRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentRequirementRulePayload>
        }
        aggregate: {
          args: Prisma.DocumentRequirementRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentRequirementRule>
        }
        groupBy: {
          args: Prisma.DocumentRequirementRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRequirementRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentRequirementRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentRequirementRuleCountAggregateOutputType> | number
        }
      }
    }
    EventChannel: {
      payload: Prisma.$EventChannelPayload<ExtArgs>
      fields: Prisma.EventChannelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventChannelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventChannelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        findFirst: {
          args: Prisma.EventChannelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventChannelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        findMany: {
          args: Prisma.EventChannelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>[]
        }
        create: {
          args: Prisma.EventChannelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        createMany: {
          args: Prisma.EventChannelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EventChannelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        update: {
          args: Prisma.EventChannelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        deleteMany: {
          args: Prisma.EventChannelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventChannelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EventChannelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChannelPayload>
        }
        aggregate: {
          args: Prisma.EventChannelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventChannel>
        }
        groupBy: {
          args: Prisma.EventChannelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChannelGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventChannelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChannelCountAggregateOutputType> | number
        }
      }
    }
    EventType: {
      payload: Prisma.$EventTypePayload<ExtArgs>
      fields: Prisma.EventTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        findFirst: {
          args: Prisma.EventTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        findMany: {
          args: Prisma.EventTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>[]
        }
        create: {
          args: Prisma.EventTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        createMany: {
          args: Prisma.EventTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EventTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        update: {
          args: Prisma.EventTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        deleteMany: {
          args: Prisma.EventTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EventTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventTypePayload>
        }
        aggregate: {
          args: Prisma.EventTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventType>
        }
        groupBy: {
          args: Prisma.EventTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventTypeCountAggregateOutputType> | number
        }
      }
    }
    EventHandler: {
      payload: Prisma.$EventHandlerPayload<ExtArgs>
      fields: Prisma.EventHandlerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventHandlerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventHandlerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        findFirst: {
          args: Prisma.EventHandlerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventHandlerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        findMany: {
          args: Prisma.EventHandlerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>[]
        }
        create: {
          args: Prisma.EventHandlerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        createMany: {
          args: Prisma.EventHandlerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.EventHandlerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        update: {
          args: Prisma.EventHandlerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        deleteMany: {
          args: Prisma.EventHandlerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventHandlerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.EventHandlerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventHandlerPayload>
        }
        aggregate: {
          args: Prisma.EventHandlerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventHandler>
        }
        groupBy: {
          args: Prisma.EventHandlerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventHandlerGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventHandlerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventHandlerCountAggregateOutputType> | number
        }
      }
    }
    DomainEvent: {
      payload: Prisma.$DomainEventPayload<ExtArgs>
      fields: Prisma.DomainEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DomainEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DomainEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        findFirst: {
          args: Prisma.DomainEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DomainEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        findMany: {
          args: Prisma.DomainEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>[]
        }
        create: {
          args: Prisma.DomainEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        createMany: {
          args: Prisma.DomainEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DomainEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        update: {
          args: Prisma.DomainEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        deleteMany: {
          args: Prisma.DomainEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DomainEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DomainEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DomainEventPayload>
        }
        aggregate: {
          args: Prisma.DomainEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDomainEvent>
        }
        groupBy: {
          args: Prisma.DomainEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DomainEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.DomainEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DomainEventCountAggregateOutputType> | number
        }
      }
    }
    PropertyTransferRequest: {
      payload: Prisma.$PropertyTransferRequestPayload<ExtArgs>
      fields: Prisma.PropertyTransferRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyTransferRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyTransferRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        findFirst: {
          args: Prisma.PropertyTransferRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyTransferRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        findMany: {
          args: Prisma.PropertyTransferRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>[]
        }
        create: {
          args: Prisma.PropertyTransferRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        createMany: {
          args: Prisma.PropertyTransferRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PropertyTransferRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        update: {
          args: Prisma.PropertyTransferRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        deleteMany: {
          args: Prisma.PropertyTransferRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyTransferRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PropertyTransferRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyTransferRequestPayload>
        }
        aggregate: {
          args: Prisma.PropertyTransferRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyTransferRequest>
        }
        groupBy: {
          args: Prisma.PropertyTransferRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyTransferRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyTransferRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyTransferRequestCountAggregateOutputType> | number
        }
      }
    }
    ApprovalRequest: {
      payload: Prisma.$ApprovalRequestPayload<ExtArgs>
      fields: Prisma.ApprovalRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApprovalRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApprovalRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        findFirst: {
          args: Prisma.ApprovalRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApprovalRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        findMany: {
          args: Prisma.ApprovalRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>[]
        }
        create: {
          args: Prisma.ApprovalRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        createMany: {
          args: Prisma.ApprovalRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ApprovalRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        update: {
          args: Prisma.ApprovalRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        deleteMany: {
          args: Prisma.ApprovalRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApprovalRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ApprovalRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApprovalRequestPayload>
        }
        aggregate: {
          args: Prisma.ApprovalRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApprovalRequest>
        }
        groupBy: {
          args: Prisma.ApprovalRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApprovalRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApprovalRequestCountAggregateOutputType> | number
        }
      }
    }
    WorkflowBlocker: {
      payload: Prisma.$WorkflowBlockerPayload<ExtArgs>
      fields: Prisma.WorkflowBlockerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowBlockerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowBlockerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        findFirst: {
          args: Prisma.WorkflowBlockerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowBlockerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        findMany: {
          args: Prisma.WorkflowBlockerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>[]
        }
        create: {
          args: Prisma.WorkflowBlockerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        createMany: {
          args: Prisma.WorkflowBlockerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.WorkflowBlockerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        update: {
          args: Prisma.WorkflowBlockerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowBlockerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowBlockerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.WorkflowBlockerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowBlockerPayload>
        }
        aggregate: {
          args: Prisma.WorkflowBlockerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflowBlocker>
        }
        groupBy: {
          args: Prisma.WorkflowBlockerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowBlockerGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowBlockerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowBlockerCountAggregateOutputType> | number
        }
      }
    }
    ScheduledJob: {
      payload: Prisma.$ScheduledJobPayload<ExtArgs>
      fields: Prisma.ScheduledJobFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ScheduledJobFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ScheduledJobFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        findFirst: {
          args: Prisma.ScheduledJobFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ScheduledJobFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        findMany: {
          args: Prisma.ScheduledJobFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>[]
        }
        create: {
          args: Prisma.ScheduledJobCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        createMany: {
          args: Prisma.ScheduledJobCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.ScheduledJobDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        update: {
          args: Prisma.ScheduledJobUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        deleteMany: {
          args: Prisma.ScheduledJobDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ScheduledJobUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.ScheduledJobUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScheduledJobPayload>
        }
        aggregate: {
          args: Prisma.ScheduledJobAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScheduledJob>
        }
        groupBy: {
          args: Prisma.ScheduledJobGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledJobGroupByOutputType>[]
        }
        count: {
          args: Prisma.ScheduledJobCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScheduledJobCountAggregateOutputType> | number
        }
      }
    }
    DocumentExpiryWarning: {
      payload: Prisma.$DocumentExpiryWarningPayload<ExtArgs>
      fields: Prisma.DocumentExpiryWarningFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentExpiryWarningFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentExpiryWarningFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        findFirst: {
          args: Prisma.DocumentExpiryWarningFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentExpiryWarningFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        findMany: {
          args: Prisma.DocumentExpiryWarningFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>[]
        }
        create: {
          args: Prisma.DocumentExpiryWarningCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        createMany: {
          args: Prisma.DocumentExpiryWarningCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.DocumentExpiryWarningDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        update: {
          args: Prisma.DocumentExpiryWarningUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        deleteMany: {
          args: Prisma.DocumentExpiryWarningDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentExpiryWarningUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.DocumentExpiryWarningUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentExpiryWarningPayload>
        }
        aggregate: {
          args: Prisma.DocumentExpiryWarningAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentExpiryWarning>
        }
        groupBy: {
          args: Prisma.DocumentExpiryWarningGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentExpiryWarningGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentExpiryWarningCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentExpiryWarningCountAggregateOutputType> | number
        }
      }
    }
    QualificationFlow: {
      payload: Prisma.$QualificationFlowPayload<ExtArgs>
      fields: Prisma.QualificationFlowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QualificationFlowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QualificationFlowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        findFirst: {
          args: Prisma.QualificationFlowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QualificationFlowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        findMany: {
          args: Prisma.QualificationFlowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>[]
        }
        create: {
          args: Prisma.QualificationFlowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        createMany: {
          args: Prisma.QualificationFlowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QualificationFlowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        update: {
          args: Prisma.QualificationFlowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        deleteMany: {
          args: Prisma.QualificationFlowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QualificationFlowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QualificationFlowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPayload>
        }
        aggregate: {
          args: Prisma.QualificationFlowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQualificationFlow>
        }
        groupBy: {
          args: Prisma.QualificationFlowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationFlowGroupByOutputType>[]
        }
        count: {
          args: Prisma.QualificationFlowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationFlowCountAggregateOutputType> | number
        }
      }
    }
    QualificationFlowPhase: {
      payload: Prisma.$QualificationFlowPhasePayload<ExtArgs>
      fields: Prisma.QualificationFlowPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QualificationFlowPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QualificationFlowPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        findFirst: {
          args: Prisma.QualificationFlowPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QualificationFlowPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        findMany: {
          args: Prisma.QualificationFlowPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>[]
        }
        create: {
          args: Prisma.QualificationFlowPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        createMany: {
          args: Prisma.QualificationFlowPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QualificationFlowPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        update: {
          args: Prisma.QualificationFlowPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        deleteMany: {
          args: Prisma.QualificationFlowPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QualificationFlowPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QualificationFlowPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationFlowPhasePayload>
        }
        aggregate: {
          args: Prisma.QualificationFlowPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQualificationFlowPhase>
        }
        groupBy: {
          args: Prisma.QualificationFlowPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationFlowPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.QualificationFlowPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationFlowPhaseCountAggregateOutputType> | number
        }
      }
    }
    OrganizationPaymentMethod: {
      payload: Prisma.$OrganizationPaymentMethodPayload<ExtArgs>
      fields: Prisma.OrganizationPaymentMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationPaymentMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        findFirst: {
          args: Prisma.OrganizationPaymentMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationPaymentMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        findMany: {
          args: Prisma.OrganizationPaymentMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>[]
        }
        create: {
          args: Prisma.OrganizationPaymentMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        createMany: {
          args: Prisma.OrganizationPaymentMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationPaymentMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        update: {
          args: Prisma.OrganizationPaymentMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationPaymentMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationPaymentMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationPaymentMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationPaymentMethodPayload>
        }
        aggregate: {
          args: Prisma.OrganizationPaymentMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationPaymentMethod>
        }
        groupBy: {
          args: Prisma.OrganizationPaymentMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationPaymentMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationPaymentMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationPaymentMethodCountAggregateOutputType> | number
        }
      }
    }
    PaymentMethodQualification: {
      payload: Prisma.$PaymentMethodQualificationPayload<ExtArgs>
      fields: Prisma.PaymentMethodQualificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentMethodQualificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentMethodQualificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        findFirst: {
          args: Prisma.PaymentMethodQualificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentMethodQualificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        findMany: {
          args: Prisma.PaymentMethodQualificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>[]
        }
        create: {
          args: Prisma.PaymentMethodQualificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        createMany: {
          args: Prisma.PaymentMethodQualificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentMethodQualificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        update: {
          args: Prisma.PaymentMethodQualificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        deleteMany: {
          args: Prisma.PaymentMethodQualificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentMethodQualificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentMethodQualificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationPayload>
        }
        aggregate: {
          args: Prisma.PaymentMethodQualificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentMethodQualification>
        }
        groupBy: {
          args: Prisma.PaymentMethodQualificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodQualificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentMethodQualificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodQualificationCountAggregateOutputType> | number
        }
      }
    }
    QualificationPhase: {
      payload: Prisma.$QualificationPhasePayload<ExtArgs>
      fields: Prisma.QualificationPhaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QualificationPhaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QualificationPhaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        findFirst: {
          args: Prisma.QualificationPhaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QualificationPhaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        findMany: {
          args: Prisma.QualificationPhaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>[]
        }
        create: {
          args: Prisma.QualificationPhaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        createMany: {
          args: Prisma.QualificationPhaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.QualificationPhaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        update: {
          args: Prisma.QualificationPhaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        deleteMany: {
          args: Prisma.QualificationPhaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QualificationPhaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.QualificationPhaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QualificationPhasePayload>
        }
        aggregate: {
          args: Prisma.QualificationPhaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQualificationPhase>
        }
        groupBy: {
          args: Prisma.QualificationPhaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationPhaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.QualificationPhaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QualificationPhaseCountAggregateOutputType> | number
        }
      }
    }
    PaymentMethodQualificationConfig: {
      payload: Prisma.$PaymentMethodQualificationConfigPayload<ExtArgs>
      fields: Prisma.PaymentMethodQualificationConfigFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentMethodQualificationConfigFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentMethodQualificationConfigFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        findFirst: {
          args: Prisma.PaymentMethodQualificationConfigFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentMethodQualificationConfigFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        findMany: {
          args: Prisma.PaymentMethodQualificationConfigFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>[]
        }
        create: {
          args: Prisma.PaymentMethodQualificationConfigCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        createMany: {
          args: Prisma.PaymentMethodQualificationConfigCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.PaymentMethodQualificationConfigDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        update: {
          args: Prisma.PaymentMethodQualificationConfigUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        deleteMany: {
          args: Prisma.PaymentMethodQualificationConfigDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentMethodQualificationConfigUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.PaymentMethodQualificationConfigUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodQualificationConfigPayload>
        }
        aggregate: {
          args: Prisma.PaymentMethodQualificationConfigAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentMethodQualificationConfig>
        }
        groupBy: {
          args: Prisma.PaymentMethodQualificationConfigGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodQualificationConfigGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentMethodQualificationConfigCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodQualificationConfigCountAggregateOutputType> | number
        }
      }
    }
    OrganizationDocumentWaiver: {
      payload: Prisma.$OrganizationDocumentWaiverPayload<ExtArgs>
      fields: Prisma.OrganizationDocumentWaiverFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrganizationDocumentWaiverFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrganizationDocumentWaiverFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        findFirst: {
          args: Prisma.OrganizationDocumentWaiverFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrganizationDocumentWaiverFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        findMany: {
          args: Prisma.OrganizationDocumentWaiverFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>[]
        }
        create: {
          args: Prisma.OrganizationDocumentWaiverCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        createMany: {
          args: Prisma.OrganizationDocumentWaiverCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.OrganizationDocumentWaiverDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        update: {
          args: Prisma.OrganizationDocumentWaiverUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        deleteMany: {
          args: Prisma.OrganizationDocumentWaiverDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrganizationDocumentWaiverUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.OrganizationDocumentWaiverUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrganizationDocumentWaiverPayload>
        }
        aggregate: {
          args: Prisma.OrganizationDocumentWaiverAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrganizationDocumentWaiver>
        }
        groupBy: {
          args: Prisma.OrganizationDocumentWaiverGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationDocumentWaiverGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrganizationDocumentWaiverCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrganizationDocumentWaiverCountAggregateOutputType> | number
        }
      }
    }
    AsyncJob: {
      payload: Prisma.$AsyncJobPayload<ExtArgs>
      fields: Prisma.AsyncJobFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AsyncJobFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AsyncJobFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        findFirst: {
          args: Prisma.AsyncJobFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AsyncJobFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        findMany: {
          args: Prisma.AsyncJobFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>[]
        }
        create: {
          args: Prisma.AsyncJobCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        createMany: {
          args: Prisma.AsyncJobCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.AsyncJobDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        update: {
          args: Prisma.AsyncJobUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        deleteMany: {
          args: Prisma.AsyncJobDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AsyncJobUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.AsyncJobUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AsyncJobPayload>
        }
        aggregate: {
          args: Prisma.AsyncJobAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAsyncJob>
        }
        groupBy: {
          args: Prisma.AsyncJobGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AsyncJobGroupByOutputType>[]
        }
        count: {
          args: Prisma.AsyncJobCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AsyncJobCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const OrganizationTypeScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  code: 'code',
  name: 'name',
  description: 'description',
  isSystemType: 'isSystemType',
  onboardingFlowId: 'onboardingFlowId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationTypeScalarFieldEnum = (typeof OrganizationTypeScalarFieldEnum)[keyof typeof OrganizationTypeScalarFieldEnum]


export const OrganizationTypeAssignmentScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  typeId: 'typeId',
  isPrimary: 'isPrimary',
  createdAt: 'createdAt'
} as const

export type OrganizationTypeAssignmentScalarFieldEnum = (typeof OrganizationTypeAssignmentScalarFieldEnum)[keyof typeof OrganizationTypeAssignmentScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  password: 'password',
  phone: 'phone',
  firstName: 'firstName',
  lastName: 'lastName',
  isActive: 'isActive',
  isEmailVerified: 'isEmailVerified',
  googleId: 'googleId',
  avatar: 'avatar',
  tenantId: 'tenantId',
  walletId: 'walletId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  emailVerifiedAt: 'emailVerifiedAt',
  emailVerificationToken: 'emailVerificationToken',
  lastLoginAt: 'lastLoginAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  tenantId: 'tenantId',
  isSystem: 'isSystem',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const PermissionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  path: 'path',
  methods: 'methods',
  effect: 'effect',
  tenantId: 'tenantId',
  isSystem: 'isSystem',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  roleId: 'roleId',
  permissionId: 'permissionId',
  createdAt: 'createdAt'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const TenantMembershipScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  tenantId: 'tenantId',
  roleId: 'roleId',
  isActive: 'isActive',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantMembershipScalarFieldEnum = (typeof TenantMembershipScalarFieldEnum)[keyof typeof TenantMembershipScalarFieldEnum]


export const OrganizationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  status: 'status',
  isPlatformOrg: 'isPlatformOrg',
  email: 'email',
  phone: 'phone',
  address: 'address',
  city: 'city',
  state: 'state',
  country: 'country',
  website: 'website',
  logoUrl: 'logoUrl',
  description: 'description',
  bankCode: 'bankCode',
  bankLicenseNo: 'bankLicenseNo',
  swiftCode: 'swiftCode',
  sortCode: 'sortCode',
  cacNumber: 'cacNumber',
  cacCertificateUrl: 'cacCertificateUrl',
  taxId: 'taxId',
  approvedAt: 'approvedAt',
  approvedById: 'approvedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


export const OrganizationMemberScalarFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  userId: 'userId',
  title: 'title',
  department: 'department',
  employeeId: 'employeeId',
  isActive: 'isActive',
  invitedAt: 'invitedAt',
  acceptedAt: 'acceptedAt',
  invitedBy: 'invitedBy',
  joinedAt: 'joinedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


export const OrganizationInvitationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  roleId: 'roleId',
  title: 'title',
  department: 'department',
  isOnboarder: 'isOnboarder',
  token: 'token',
  expiresAt: 'expiresAt',
  status: 'status',
  invitedById: 'invitedById',
  acceptedAt: 'acceptedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationInvitationScalarFieldEnum = (typeof OrganizationInvitationScalarFieldEnum)[keyof typeof OrganizationInvitationScalarFieldEnum]


export const OnboardingFlowScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  autoActivatePhases: 'autoActivatePhases',
  expiresInDays: 'expiresInDays',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingFlowScalarFieldEnum = (typeof OnboardingFlowScalarFieldEnum)[keyof typeof OnboardingFlowScalarFieldEnum]


export const OnboardingFlowPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  onboardingFlowId: 'onboardingFlowId',
  questionnairePlanId: 'questionnairePlanId',
  documentationPlanId: 'documentationPlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingFlowPhaseScalarFieldEnum = (typeof OnboardingFlowPhaseScalarFieldEnum)[keyof typeof OnboardingFlowPhaseScalarFieldEnum]


export const OrganizationOnboardingScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  onboardingFlowId: 'onboardingFlowId',
  templateSnapshot: 'templateSnapshot',
  assigneeId: 'assigneeId',
  status: 'status',
  currentPhaseId: 'currentPhaseId',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  expiresAt: 'expiresAt',
  approvedAt: 'approvedAt',
  approvedById: 'approvedById',
  rejectionReason: 'rejectionReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationOnboardingScalarFieldEnum = (typeof OrganizationOnboardingScalarFieldEnum)[keyof typeof OrganizationOnboardingScalarFieldEnum]


export const OnboardingPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  onboardingId: 'onboardingId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  status: 'status',
  activatedAt: 'activatedAt',
  completedAt: 'completedAt',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OnboardingPhaseScalarFieldEnum = (typeof OnboardingPhaseScalarFieldEnum)[keyof typeof OnboardingPhaseScalarFieldEnum]


export const BankDocumentRequirementScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  phaseId: 'phaseId',
  documentType: 'documentType',
  documentName: 'documentName',
  modifier: 'modifier',
  description: 'description',
  expiryDays: 'expiryDays',
  minFiles: 'minFiles',
  maxFiles: 'maxFiles',
  allowedMimeTypes: 'allowedMimeTypes',
  validationRules: 'validationRules',
  priority: 'priority',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BankDocumentRequirementScalarFieldEnum = (typeof BankDocumentRequirementScalarFieldEnum)[keyof typeof BankDocumentRequirementScalarFieldEnum]


export const TenantScalarFieldEnum = {
  id: 'id',
  name: 'name',
  subdomain: 'subdomain',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const ApiKeyScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  provider: 'provider',
  secretRef: 'secretRef',
  scopes: 'scopes',
  enabled: 'enabled',
  expiresAt: 'expiresAt',
  lastUsedAt: 'lastUsedAt',
  revokedAt: 'revokedAt',
  revokedBy: 'revokedBy',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


export const RefreshTokenScalarFieldEnum = {
  id: 'id',
  jti: 'jti',
  token: 'token',
  userId: 'userId',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


export const PasswordResetScalarFieldEnum = {
  id: 'id',
  token: 'token',
  userId: 'userId',
  expiresAt: 'expiresAt',
  usedAt: 'usedAt',
  createdAt: 'createdAt'
} as const

export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


export const UserSuspensionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  reason: 'reason',
  suspendedAt: 'suspendedAt',
  expiresAt: 'expiresAt',
  liftedAt: 'liftedAt'
} as const

export type UserSuspensionScalarFieldEnum = (typeof UserSuspensionScalarFieldEnum)[keyof typeof UserSuspensionScalarFieldEnum]


export const EmailPreferenceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  marketingEmails: 'marketingEmails',
  transactionalEmails: 'transactionalEmails',
  propertyAlerts: 'propertyAlerts',
  paymentReminders: 'paymentReminders',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EmailPreferenceScalarFieldEnum = (typeof EmailPreferenceScalarFieldEnum)[keyof typeof EmailPreferenceScalarFieldEnum]


export const DeviceEndpointScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  endpoint: 'endpoint',
  platform: 'platform',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DeviceEndpointScalarFieldEnum = (typeof DeviceEndpointScalarFieldEnum)[keyof typeof DeviceEndpointScalarFieldEnum]


export const SocialScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  provider: 'provider',
  socialId: 'socialId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SocialScalarFieldEnum = (typeof SocialScalarFieldEnum)[keyof typeof SocialScalarFieldEnum]


export const OAuthStateScalarFieldEnum = {
  id: 'id',
  state: 'state',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type OAuthStateScalarFieldEnum = (typeof OAuthStateScalarFieldEnum)[keyof typeof OAuthStateScalarFieldEnum]


export const WalletScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  balance: 'balance',
  currency: 'currency',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  walletId: 'walletId',
  amount: 'amount',
  type: 'type',
  status: 'status',
  reference: 'reference',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const SettingsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  key: 'key',
  value: 'value',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


export const PropertyScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  organizationId: 'organizationId',
  title: 'title',
  category: 'category',
  propertyType: 'propertyType',
  country: 'country',
  currency: 'currency',
  city: 'city',
  district: 'district',
  zipCode: 'zipCode',
  streetAddress: 'streetAddress',
  longitude: 'longitude',
  latitude: 'latitude',
  status: 'status',
  description: 'description',
  displayImageId: 'displayImageId',
  publishedAt: 'publishedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const PropertyMediaScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  url: 'url',
  type: 'type',
  caption: 'caption',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyMediaScalarFieldEnum = (typeof PropertyMediaScalarFieldEnum)[keyof typeof PropertyMediaScalarFieldEnum]


export const PropertyDocumentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  name: 'name',
  url: 'url',
  type: 'type',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyDocumentScalarFieldEnum = (typeof PropertyDocumentScalarFieldEnum)[keyof typeof PropertyDocumentScalarFieldEnum]


export const AmenityScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  category: 'category',
  icon: 'icon',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


export const PropertyVariantScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  name: 'name',
  description: 'description',
  nBedrooms: 'nBedrooms',
  nBathrooms: 'nBathrooms',
  nParkingSpots: 'nParkingSpots',
  area: 'area',
  price: 'price',
  pricePerSqm: 'pricePerSqm',
  totalUnits: 'totalUnits',
  availableUnits: 'availableUnits',
  reservedUnits: 'reservedUnits',
  soldUnits: 'soldUnits',
  status: 'status',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyVariantScalarFieldEnum = (typeof PropertyVariantScalarFieldEnum)[keyof typeof PropertyVariantScalarFieldEnum]


export const PropertyVariantAmenityScalarFieldEnum = {
  tenantId: 'tenantId',
  variantId: 'variantId',
  amenityId: 'amenityId',
  createdAt: 'createdAt'
} as const

export type PropertyVariantAmenityScalarFieldEnum = (typeof PropertyVariantAmenityScalarFieldEnum)[keyof typeof PropertyVariantAmenityScalarFieldEnum]


export const PropertyVariantMediaScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  variantId: 'variantId',
  url: 'url',
  type: 'type',
  caption: 'caption',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyVariantMediaScalarFieldEnum = (typeof PropertyVariantMediaScalarFieldEnum)[keyof typeof PropertyVariantMediaScalarFieldEnum]


export const PropertyUnitScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  variantId: 'variantId',
  unitNumber: 'unitNumber',
  floorNumber: 'floorNumber',
  blockName: 'blockName',
  priceOverride: 'priceOverride',
  areaOverride: 'areaOverride',
  notes: 'notes',
  status: 'status',
  reservedAt: 'reservedAt',
  reservedUntil: 'reservedUntil',
  reservedById: 'reservedById',
  ownerId: 'ownerId',
  version: 'version',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyUnitScalarFieldEnum = (typeof PropertyUnitScalarFieldEnum)[keyof typeof PropertyUnitScalarFieldEnum]


export const PropertyAmenityScalarFieldEnum = {
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  amenityId: 'amenityId',
  createdAt: 'createdAt'
} as const

export type PropertyAmenityScalarFieldEnum = (typeof PropertyAmenityScalarFieldEnum)[keyof typeof PropertyAmenityScalarFieldEnum]


export const DocumentationPlanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentationPlanScalarFieldEnum = (typeof DocumentationPlanScalarFieldEnum)[keyof typeof DocumentationPlanScalarFieldEnum]


export const DocumentDefinitionScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  documentType: 'documentType',
  documentName: 'documentName',
  uploadedBy: 'uploadedBy',
  autoApprove: 'autoApprove',
  order: 'order',
  isRequired: 'isRequired',
  description: 'description',
  maxSizeBytes: 'maxSizeBytes',
  allowedMimeTypes: 'allowedMimeTypes',
  expiryDays: 'expiryDays',
  minFiles: 'minFiles',
  maxFiles: 'maxFiles',
  condition: 'condition',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentDefinitionScalarFieldEnum = (typeof DocumentDefinitionScalarFieldEnum)[keyof typeof DocumentDefinitionScalarFieldEnum]


export const ApprovalStageScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  name: 'name',
  order: 'order',
  organizationTypeId: 'organizationTypeId',
  autoTransition: 'autoTransition',
  waitForAllDocuments: 'waitForAllDocuments',
  allowEarlyVisibility: 'allowEarlyVisibility',
  onRejection: 'onRejection',
  restartFromStageOrder: 'restartFromStageOrder',
  slaHours: 'slaHours',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApprovalStageScalarFieldEnum = (typeof ApprovalStageScalarFieldEnum)[keyof typeof ApprovalStageScalarFieldEnum]


export const QuestionnairePlanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  version: 'version',
  isActive: 'isActive',
  passingScore: 'passingScore',
  scoringStrategy: 'scoringStrategy',
  autoDecisionEnabled: 'autoDecisionEnabled',
  estimatedMinutes: 'estimatedMinutes',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuestionnairePlanScalarFieldEnum = (typeof QuestionnairePlanScalarFieldEnum)[keyof typeof QuestionnairePlanScalarFieldEnum]


export const QuestionnairePlanQuestionScalarFieldEnum = {
  id: 'id',
  questionnairePlanId: 'questionnairePlanId',
  questionKey: 'questionKey',
  questionText: 'questionText',
  helpText: 'helpText',
  questionType: 'questionType',
  order: 'order',
  isRequired: 'isRequired',
  validationRules: 'validationRules',
  options: 'options',
  scoreWeight: 'scoreWeight',
  scoringRules: 'scoringRules',
  showIf: 'showIf',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuestionnairePlanQuestionScalarFieldEnum = (typeof QuestionnairePlanQuestionScalarFieldEnum)[keyof typeof QuestionnairePlanQuestionScalarFieldEnum]


export const GatePlanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  requiredApprovals: 'requiredApprovals',
  reviewerOrganizationTypeId: 'reviewerOrganizationTypeId',
  reviewerInstructions: 'reviewerInstructions',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GatePlanScalarFieldEnum = (typeof GatePlanScalarFieldEnum)[keyof typeof GatePlanScalarFieldEnum]


export const PaymentPlanScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  paymentFrequency: 'paymentFrequency',
  frequencyMultiplier: 'frequencyMultiplier',
  customFrequencyDays: 'customFrequencyDays',
  numberOfInstallments: 'numberOfInstallments',
  calculateInterestDaily: 'calculateInterestDaily',
  gracePeriodDays: 'gracePeriodDays',
  allowFlexibleTerm: 'allowFlexibleTerm',
  minTermMonths: 'minTermMonths',
  maxTermMonths: 'maxTermMonths',
  termStepMonths: 'termStepMonths',
  maxAgeAtMaturity: 'maxAgeAtMaturity',
  collectFunds: 'collectFunds',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentPlanScalarFieldEnum = (typeof PaymentPlanScalarFieldEnum)[keyof typeof PaymentPlanScalarFieldEnum]


export const PropertyPaymentMethodScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  allowEarlyPayoff: 'allowEarlyPayoff',
  earlyPayoffPenaltyRate: 'earlyPayoffPenaltyRate',
  autoActivatePhases: 'autoActivatePhases',
  requiresManualApproval: 'requiresManualApproval',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyPaymentMethodScalarFieldEnum = (typeof PropertyPaymentMethodScalarFieldEnum)[keyof typeof PropertyPaymentMethodScalarFieldEnum]


export const PropertyPaymentMethodLinkScalarFieldEnum = {
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  paymentMethodId: 'paymentMethodId',
  isDefault: 'isDefault',
  isActive: 'isActive',
  createdAt: 'createdAt'
} as const

export type PropertyPaymentMethodLinkScalarFieldEnum = (typeof PropertyPaymentMethodLinkScalarFieldEnum)[keyof typeof PropertyPaymentMethodLinkScalarFieldEnum]


export const PropertyPaymentMethodPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentMethodId: 'paymentMethodId',
  paymentPlanId: 'paymentPlanId',
  documentationPlanId: 'documentationPlanId',
  questionnairePlanId: 'questionnairePlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  interestRate: 'interestRate',
  percentOfPrice: 'percentOfPrice',
  collectFunds: 'collectFunds',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  minimumCompletionPercentage: 'minimumCompletionPercentage',
  completionCriterion: 'completionCriterion',
  lockUnitOnComplete: 'lockUnitOnComplete',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyPaymentMethodPhaseScalarFieldEnum = (typeof PropertyPaymentMethodPhaseScalarFieldEnum)[keyof typeof PropertyPaymentMethodPhaseScalarFieldEnum]


export const PhaseEventAttachmentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  trigger: 'trigger',
  handlerId: 'handlerId',
  priority: 'priority',
  enabled: 'enabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PhaseEventAttachmentScalarFieldEnum = (typeof PhaseEventAttachmentScalarFieldEnum)[keyof typeof PhaseEventAttachmentScalarFieldEnum]


export const ApplicationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyUnitId: 'propertyUnitId',
  buyerId: 'buyerId',
  sellerId: 'sellerId',
  paymentMethodId: 'paymentMethodId',
  paymentMethodSnapshot: 'paymentMethodSnapshot',
  paymentMethodSnapshotAt: 'paymentMethodSnapshotAt',
  paymentMethodSnapshotHash: 'paymentMethodSnapshotHash',
  applicationNumber: 'applicationNumber',
  title: 'title',
  description: 'description',
  applicationType: 'applicationType',
  totalAmount: 'totalAmount',
  status: 'status',
  currentPhaseId: 'currentPhaseId',
  nextPaymentDueDate: 'nextPaymentDueDate',
  lastReminderSentAt: 'lastReminderSentAt',
  startDate: 'startDate',
  endDate: 'endDate',
  signedAt: 'signedAt',
  terminatedAt: 'terminatedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  transferredFromId: 'transferredFromId',
  supersededById: 'supersededById',
  supersededAt: 'supersededAt'
} as const

export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


export const CoApplicantScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  userId: 'userId',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  relationship: 'relationship',
  monthlyIncome: 'monthlyIncome',
  employmentType: 'employmentType',
  inviteToken: 'inviteToken',
  inviteTokenExpiresAt: 'inviteTokenExpiresAt',
  status: 'status',
  invitedAt: 'invitedAt',
  acceptedAt: 'acceptedAt',
  removedAt: 'removedAt',
  removedById: 'removedById',
  removalReason: 'removalReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CoApplicantScalarFieldEnum = (typeof CoApplicantScalarFieldEnum)[keyof typeof CoApplicantScalarFieldEnum]


export const ApplicationOrganizationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  organizationId: 'organizationId',
  assignedAsTypeId: 'assignedAsTypeId',
  assignedStaffId: 'assignedStaffId',
  status: 'status',
  assignedById: 'assignedById',
  assignedAt: 'assignedAt',
  isPrimary: 'isPrimary',
  offeredTerms: 'offeredTerms',
  termsOfferedAt: 'termsOfferedAt',
  termsAcceptedAt: 'termsAcceptedAt',
  termsDeclinedAt: 'termsDeclinedAt',
  declineReason: 'declineReason',
  activatedAt: 'activatedAt',
  completedAt: 'completedAt',
  withdrawnAt: 'withdrawnAt',
  slaHours: 'slaHours',
  slaStartedAt: 'slaStartedAt',
  slaBreachedAt: 'slaBreachedAt',
  slaBreachNotified: 'slaBreachNotified',
  reminderCount: 'reminderCount',
  lastReminderSentAt: 'lastReminderSentAt',
  nextReminderAt: 'nextReminderAt',
  escalatedAt: 'escalatedAt',
  escalatedToUserId: 'escalatedToUserId',
  escalationNotes: 'escalationNotes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationOrganizationScalarFieldEnum = (typeof ApplicationOrganizationScalarFieldEnum)[keyof typeof ApplicationOrganizationScalarFieldEnum]


export const ApplicationRefundScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  amount: 'amount',
  reason: 'reason',
  status: 'status',
  requestedById: 'requestedById',
  approvedById: 'approvedById',
  processedById: 'processedById',
  paymentMethod: 'paymentMethod',
  referenceNumber: 'referenceNumber',
  recipientName: 'recipientName',
  recipientAccount: 'recipientAccount',
  recipientBank: 'recipientBank',
  requestedAt: 'requestedAt',
  approvedAt: 'approvedAt',
  rejectedAt: 'rejectedAt',
  processedAt: 'processedAt',
  approvalNotes: 'approvalNotes',
  rejectionNotes: 'rejectionNotes',
  processingNotes: 'processingNotes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationRefundScalarFieldEnum = (typeof ApplicationRefundScalarFieldEnum)[keyof typeof ApplicationRefundScalarFieldEnum]


export const ApplicationPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  status: 'status',
  dueDate: 'dueDate',
  startDate: 'startDate',
  endDate: 'endDate',
  activatedAt: 'activatedAt',
  completedAt: 'completedAt',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationPhaseScalarFieldEnum = (typeof ApplicationPhaseScalarFieldEnum)[keyof typeof ApplicationPhaseScalarFieldEnum]


export const QuestionnairePhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  questionnairePlanId: 'questionnairePlanId',
  completedFieldsCount: 'completedFieldsCount',
  totalFieldsCount: 'totalFieldsCount',
  totalScore: 'totalScore',
  passingScore: 'passingScore',
  passed: 'passed',
  scoredAt: 'scoredAt',
  underwritingScore: 'underwritingScore',
  debtToIncomeRatio: 'debtToIncomeRatio',
  underwritingDecision: 'underwritingDecision',
  underwritingNotes: 'underwritingNotes',
  fieldsSnapshot: 'fieldsSnapshot',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuestionnairePhaseScalarFieldEnum = (typeof QuestionnairePhaseScalarFieldEnum)[keyof typeof QuestionnairePhaseScalarFieldEnum]


export const QuestionnairePhaseReviewScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  questionnairePhaseId: 'questionnairePhaseId',
  reviewerId: 'reviewerId',
  decision: 'decision',
  notes: 'notes',
  scoreAtReview: 'scoreAtReview',
  passedAtReview: 'passedAtReview',
  createdAt: 'createdAt'
} as const

export type QuestionnairePhaseReviewScalarFieldEnum = (typeof QuestionnairePhaseReviewScalarFieldEnum)[keyof typeof QuestionnairePhaseReviewScalarFieldEnum]


export const GatePhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationPhaseId: 'applicationPhaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  gatePlanId: 'gatePlanId',
  requiredApprovals: 'requiredApprovals',
  reviewerOrganizationTypeId: 'reviewerOrganizationTypeId',
  reviewerInstructions: 'reviewerInstructions',
  approvalCount: 'approvalCount',
  rejectionCount: 'rejectionCount',
  rejectionReason: 'rejectionReason',
  gatePlanSnapshot: 'gatePlanSnapshot',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GatePhaseScalarFieldEnum = (typeof GatePhaseScalarFieldEnum)[keyof typeof GatePhaseScalarFieldEnum]


export const GatePhaseReviewScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  gatePhaseId: 'gatePhaseId',
  reviewerId: 'reviewerId',
  decision: 'decision',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type GatePhaseReviewScalarFieldEnum = (typeof GatePhaseReviewScalarFieldEnum)[keyof typeof GatePhaseReviewScalarFieldEnum]


export const DocumentationPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  documentationPlanId: 'documentationPlanId',
  sourceQuestionnairePhaseId: 'sourceQuestionnairePhaseId',
  currentStageOrder: 'currentStageOrder',
  approvedDocumentsCount: 'approvedDocumentsCount',
  requiredDocumentsCount: 'requiredDocumentsCount',
  documentDefinitionsSnapshot: 'documentDefinitionsSnapshot',
  approvalStagesSnapshot: 'approvalStagesSnapshot',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentationPhaseScalarFieldEnum = (typeof DocumentationPhaseScalarFieldEnum)[keyof typeof DocumentationPhaseScalarFieldEnum]


export const PaymentPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  paymentPlanId: 'paymentPlanId',
  totalAmount: 'totalAmount',
  paidAmount: 'paidAmount',
  interestRate: 'interestRate',
  selectedTermMonths: 'selectedTermMonths',
  numberOfInstallments: 'numberOfInstallments',
  collectFunds: 'collectFunds',
  minimumCompletionPercentage: 'minimumCompletionPercentage',
  paymentPlanSnapshot: 'paymentPlanSnapshot',
  version: 'version',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentPhaseScalarFieldEnum = (typeof PaymentPhaseScalarFieldEnum)[keyof typeof PaymentPhaseScalarFieldEnum]


export const QuestionnaireFieldScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  questionnairePhaseId: 'questionnairePhaseId',
  name: 'name',
  label: 'label',
  description: 'description',
  placeholder: 'placeholder',
  fieldType: 'fieldType',
  isRequired: 'isRequired',
  order: 'order',
  validation: 'validation',
  displayCondition: 'displayCondition',
  defaultValue: 'defaultValue',
  answer: 'answer',
  isValid: 'isValid',
  validationErrors: 'validationErrors',
  submittedAt: 'submittedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuestionnaireFieldScalarFieldEnum = (typeof QuestionnaireFieldScalarFieldEnum)[keyof typeof QuestionnaireFieldScalarFieldEnum]


export const ApplicationEventScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  eventType: 'eventType',
  eventGroup: 'eventGroup',
  fromState: 'fromState',
  toState: 'toState',
  trigger: 'trigger',
  data: 'data',
  actorId: 'actorId',
  actorType: 'actorType',
  occurredAt: 'occurredAt'
} as const

export type ApplicationEventScalarFieldEnum = (typeof ApplicationEventScalarFieldEnum)[keyof typeof ApplicationEventScalarFieldEnum]


export const PaymentInstallmentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentPhaseId: 'paymentPhaseId',
  installmentNumber: 'installmentNumber',
  amount: 'amount',
  principalAmount: 'principalAmount',
  interestAmount: 'interestAmount',
  dueDate: 'dueDate',
  status: 'status',
  paidAmount: 'paidAmount',
  paidDate: 'paidDate',
  lateFee: 'lateFee',
  lateFeeWaived: 'lateFeeWaived',
  gracePeriodDays: 'gracePeriodDays',
  gracePeriodEndDate: 'gracePeriodEndDate',
  version: 'version',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentInstallmentScalarFieldEnum = (typeof PaymentInstallmentScalarFieldEnum)[keyof typeof PaymentInstallmentScalarFieldEnum]


export const ApplicationPaymentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  installmentId: 'installmentId',
  payerId: 'payerId',
  amount: 'amount',
  principalAmount: 'principalAmount',
  interestAmount: 'interestAmount',
  lateFeeAmount: 'lateFeeAmount',
  paymentMethod: 'paymentMethod',
  status: 'status',
  reference: 'reference',
  gatewayResponse: 'gatewayResponse',
  processedAt: 'processedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationPaymentScalarFieldEnum = (typeof ApplicationPaymentScalarFieldEnum)[keyof typeof ApplicationPaymentScalarFieldEnum]


export const ApplicationDocumentScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  stepId: 'stepId',
  documentType: 'documentType',
  documentName: 'documentName',
  name: 'name',
  url: 'url',
  type: 'type',
  uploadedById: 'uploadedById',
  expectedUploader: 'expectedUploader',
  expectedOrganizationId: 'expectedOrganizationId',
  documentDate: 'documentDate',
  expiresAt: 'expiresAt',
  expiryDays: 'expiryDays',
  isExpired: 'isExpired',
  expiredAt: 'expiredAt',
  expiryWarningAt: 'expiryWarningAt',
  revalidatedAt: 'revalidatedAt',
  status: 'status',
  version: 'version',
  replacesDocumentId: 'replacesDocumentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationDocumentScalarFieldEnum = (typeof ApplicationDocumentScalarFieldEnum)[keyof typeof ApplicationDocumentScalarFieldEnum]


export const DocumentReviewScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  organizationId: 'organizationId',
  organizationTypeId: 'organizationTypeId',
  reviewerId: 'reviewerId',
  reviewerName: 'reviewerName',
  decision: 'decision',
  comments: 'comments',
  concerns: 'concerns',
  requestedAt: 'requestedAt',
  dueAt: 'dueAt',
  reviewedAt: 'reviewedAt',
  reviewOrder: 'reviewOrder',
  parentReviewId: 'parentReviewId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentReviewScalarFieldEnum = (typeof DocumentReviewScalarFieldEnum)[keyof typeof DocumentReviewScalarFieldEnum]


export const ApprovalStageProgressScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentationPhaseId: 'documentationPhaseId',
  approvalStageId: 'approvalStageId',
  name: 'name',
  order: 'order',
  organizationTypeId: 'organizationTypeId',
  autoTransition: 'autoTransition',
  waitForAllDocuments: 'waitForAllDocuments',
  allowEarlyVisibility: 'allowEarlyVisibility',
  onRejection: 'onRejection',
  restartFromStageOrder: 'restartFromStageOrder',
  status: 'status',
  activatedAt: 'activatedAt',
  completedAt: 'completedAt',
  completedById: 'completedById',
  transitionComment: 'transitionComment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApprovalStageProgressScalarFieldEnum = (typeof ApprovalStageProgressScalarFieldEnum)[keyof typeof ApprovalStageProgressScalarFieldEnum]


export const DocumentApprovalScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  stageProgressId: 'stageProgressId',
  reviewerId: 'reviewerId',
  organizationTypeId: 'organizationTypeId',
  decision: 'decision',
  comment: 'comment',
  reviewedAt: 'reviewedAt',
  createdAt: 'createdAt'
} as const

export type DocumentApprovalScalarFieldEnum = (typeof DocumentApprovalScalarFieldEnum)[keyof typeof DocumentApprovalScalarFieldEnum]


export const DocumentTemplateScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  code: 'code',
  description: 'description',
  version: 'version',
  htmlTemplate: 'htmlTemplate',
  cssStyles: 'cssStyles',
  mergeFields: 'mergeFields',
  isActive: 'isActive',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentTemplateScalarFieldEnum = (typeof DocumentTemplateScalarFieldEnum)[keyof typeof DocumentTemplateScalarFieldEnum]


export const OfferLetterScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  templateId: 'templateId',
  letterNumber: 'letterNumber',
  type: 'type',
  status: 'status',
  htmlContent: 'htmlContent',
  pdfUrl: 'pdfUrl',
  pdfKey: 'pdfKey',
  mergeData: 'mergeData',
  sentAt: 'sentAt',
  viewedAt: 'viewedAt',
  signedAt: 'signedAt',
  signatureIp: 'signatureIp',
  signatureData: 'signatureData',
  expiresAt: 'expiresAt',
  expiredAt: 'expiredAt',
  cancelledAt: 'cancelledAt',
  cancelReason: 'cancelReason',
  generatedById: 'generatedById',
  sentById: 'sentById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OfferLetterScalarFieldEnum = (typeof OfferLetterScalarFieldEnum)[keyof typeof OfferLetterScalarFieldEnum]


export const ApplicationTerminationScalarFieldEnum = {
  id: 'id',
  applicationId: 'applicationId',
  tenantId: 'tenantId',
  requestNumber: 'requestNumber',
  initiatedBy: 'initiatedBy',
  initiatorId: 'initiatorId',
  type: 'type',
  reason: 'reason',
  supportingDocs: 'supportingDocs',
  status: 'status',
  requiresApproval: 'requiresApproval',
  autoApproveEligible: 'autoApproveEligible',
  reviewedBy: 'reviewedBy',
  reviewedAt: 'reviewedAt',
  reviewNotes: 'reviewNotes',
  rejectionReason: 'rejectionReason',
  applicationSnapshot: 'applicationSnapshot',
  totalApplicationAmount: 'totalApplicationAmount',
  totalPaidToDate: 'totalPaidToDate',
  outstandingBalance: 'outstandingBalance',
  refundableAmount: 'refundableAmount',
  penaltyAmount: 'penaltyAmount',
  forfeitedAmount: 'forfeitedAmount',
  adminFeeAmount: 'adminFeeAmount',
  netRefundAmount: 'netRefundAmount',
  settlementNotes: 'settlementNotes',
  refundStatus: 'refundStatus',
  refundReference: 'refundReference',
  refundMethod: 'refundMethod',
  refundAccountDetails: 'refundAccountDetails',
  refundInitiatedAt: 'refundInitiatedAt',
  refundCompletedAt: 'refundCompletedAt',
  refundFailureReason: 'refundFailureReason',
  unitReleasedAt: 'unitReleasedAt',
  unitReservedForId: 'unitReservedForId',
  requestedAt: 'requestedAt',
  approvedAt: 'approvedAt',
  executedAt: 'executedAt',
  completedAt: 'completedAt',
  cancelledAt: 'cancelledAt',
  idempotencyKey: 'idempotencyKey',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApplicationTerminationScalarFieldEnum = (typeof ApplicationTerminationScalarFieldEnum)[keyof typeof ApplicationTerminationScalarFieldEnum]


export const PaymentMethodChangeRequestScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  fromPaymentMethodId: 'fromPaymentMethodId',
  toPaymentMethodId: 'toPaymentMethodId',
  requestorId: 'requestorId',
  reason: 'reason',
  requiredDocumentTypes: 'requiredDocumentTypes',
  submittedDocuments: 'submittedDocuments',
  currentOutstanding: 'currentOutstanding',
  newTermMonths: 'newTermMonths',
  newInterestRate: 'newInterestRate',
  newMonthlyPayment: 'newMonthlyPayment',
  penaltyAmount: 'penaltyAmount',
  financialImpactNotes: 'financialImpactNotes',
  status: 'status',
  reviewerId: 'reviewerId',
  reviewNotes: 'reviewNotes',
  reviewedAt: 'reviewedAt',
  executedAt: 'executedAt',
  previousPhaseData: 'previousPhaseData',
  newPhaseData: 'newPhaseData',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentMethodChangeRequestScalarFieldEnum = (typeof PaymentMethodChangeRequestScalarFieldEnum)[keyof typeof PaymentMethodChangeRequestScalarFieldEnum]


export const DocumentRequirementRuleScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  context: 'context',
  paymentMethodId: 'paymentMethodId',
  fromPaymentMethodId: 'fromPaymentMethodId',
  toPaymentMethodId: 'toPaymentMethodId',
  documentType: 'documentType',
  isRequired: 'isRequired',
  description: 'description',
  maxSizeBytes: 'maxSizeBytes',
  allowedMimeTypes: 'allowedMimeTypes',
  expiryDays: 'expiryDays',
  requiresManualReview: 'requiresManualReview',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentRequirementRuleScalarFieldEnum = (typeof DocumentRequirementRuleScalarFieldEnum)[keyof typeof DocumentRequirementRuleScalarFieldEnum]


export const EventChannelScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  code: 'code',
  name: 'name',
  description: 'description',
  enabled: 'enabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventChannelScalarFieldEnum = (typeof EventChannelScalarFieldEnum)[keyof typeof EventChannelScalarFieldEnum]


export const EventTypeScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  channelId: 'channelId',
  code: 'code',
  name: 'name',
  description: 'description',
  payloadSchema: 'payloadSchema',
  enabled: 'enabled',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventTypeScalarFieldEnum = (typeof EventTypeScalarFieldEnum)[keyof typeof EventTypeScalarFieldEnum]


export const EventHandlerScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  eventTypeId: 'eventTypeId',
  name: 'name',
  description: 'description',
  handlerType: 'handlerType',
  config: 'config',
  priority: 'priority',
  enabled: 'enabled',
  maxRetries: 'maxRetries',
  retryDelayMs: 'retryDelayMs',
  filterCondition: 'filterCondition',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventHandlerScalarFieldEnum = (typeof EventHandlerScalarFieldEnum)[keyof typeof EventHandlerScalarFieldEnum]


export const DomainEventScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  eventType: 'eventType',
  aggregateType: 'aggregateType',
  aggregateId: 'aggregateId',
  queueName: 'queueName',
  payload: 'payload',
  occurredAt: 'occurredAt',
  actorId: 'actorId',
  actorRole: 'actorRole',
  status: 'status',
  processedAt: 'processedAt',
  sentAt: 'sentAt',
  failureCount: 'failureCount',
  lastError: 'lastError',
  nextRetryAt: 'nextRetryAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DomainEventScalarFieldEnum = (typeof DomainEventScalarFieldEnum)[keyof typeof DomainEventScalarFieldEnum]


export const PropertyTransferRequestScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  sourceApplicationId: 'sourceApplicationId',
  targetPropertyUnitId: 'targetPropertyUnitId',
  requestedById: 'requestedById',
  reviewedById: 'reviewedById',
  status: 'status',
  reason: 'reason',
  reviewNotes: 'reviewNotes',
  priceAdjustmentHandling: 'priceAdjustmentHandling',
  sourceTotalAmount: 'sourceTotalAmount',
  targetTotalAmount: 'targetTotalAmount',
  priceAdjustment: 'priceAdjustment',
  refundedAmount: 'refundedAmount',
  refundTransactionId: 'refundTransactionId',
  refundedAt: 'refundedAt',
  targetApplicationId: 'targetApplicationId',
  createdAt: 'createdAt',
  reviewedAt: 'reviewedAt',
  completedAt: 'completedAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyTransferRequestScalarFieldEnum = (typeof PropertyTransferRequestScalarFieldEnum)[keyof typeof PropertyTransferRequestScalarFieldEnum]


export const ApprovalRequestScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  type: 'type',
  status: 'status',
  priority: 'priority',
  entityType: 'entityType',
  entityId: 'entityId',
  title: 'title',
  description: 'description',
  payload: 'payload',
  requestedById: 'requestedById',
  assigneeId: 'assigneeId',
  reviewedById: 'reviewedById',
  reviewNotes: 'reviewNotes',
  decision: 'decision',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  assignedAt: 'assignedAt',
  reviewedAt: 'reviewedAt',
  completedAt: 'completedAt',
  updatedAt: 'updatedAt'
} as const

export type ApprovalRequestScalarFieldEnum = (typeof ApprovalRequestScalarFieldEnum)[keyof typeof ApprovalRequestScalarFieldEnum]


export const WorkflowBlockerScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  stepId: 'stepId',
  blockerActor: 'blockerActor',
  blockerCategory: 'blockerCategory',
  urgency: 'urgency',
  actionRequired: 'actionRequired',
  context: 'context',
  expectedByDate: 'expectedByDate',
  isOverdue: 'isOverdue',
  overdueAt: 'overdueAt',
  startedAt: 'startedAt',
  resolvedAt: 'resolvedAt',
  durationMs: 'durationMs',
  resolvedByActor: 'resolvedByActor',
  resolutionTrigger: 'resolutionTrigger',
  reminderCount: 'reminderCount',
  lastReminderAt: 'lastReminderAt',
  nextReminderAt: 'nextReminderAt',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkflowBlockerScalarFieldEnum = (typeof WorkflowBlockerScalarFieldEnum)[keyof typeof WorkflowBlockerScalarFieldEnum]


export const ScheduledJobScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  jobType: 'jobType',
  status: 'status',
  scheduledAt: 'scheduledAt',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  durationMs: 'durationMs',
  parameters: 'parameters',
  itemsProcessed: 'itemsProcessed',
  itemsAffected: 'itemsAffected',
  errorCount: 'errorCount',
  errors: 'errors',
  summary: 'summary',
  attemptNumber: 'attemptNumber',
  maxAttempts: 'maxAttempts',
  nextRetryAt: 'nextRetryAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ScheduledJobScalarFieldEnum = (typeof ScheduledJobScalarFieldEnum)[keyof typeof ScheduledJobScalarFieldEnum]


export const DocumentExpiryWarningScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  expiresAt: 'expiresAt',
  daysUntil: 'daysUntil',
  warningSent: 'warningSent',
  notificationSent: 'notificationSent',
  notificationId: 'notificationId',
  resolved: 'resolved',
  resolvedAt: 'resolvedAt',
  resolvedBy: 'resolvedBy',
  newDocumentId: 'newDocumentId',
  createdAt: 'createdAt'
} as const

export type DocumentExpiryWarningScalarFieldEnum = (typeof DocumentExpiryWarningScalarFieldEnum)[keyof typeof DocumentExpiryWarningScalarFieldEnum]


export const QualificationFlowScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  autoActivatePhases: 'autoActivatePhases',
  expiresInDays: 'expiresInDays',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QualificationFlowScalarFieldEnum = (typeof QualificationFlowScalarFieldEnum)[keyof typeof QualificationFlowScalarFieldEnum]


export const QualificationFlowPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  qualificationFlowId: 'qualificationFlowId',
  questionnairePlanId: 'questionnairePlanId',
  documentationPlanId: 'documentationPlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QualificationFlowPhaseScalarFieldEnum = (typeof QualificationFlowPhaseScalarFieldEnum)[keyof typeof QualificationFlowPhaseScalarFieldEnum]


export const OrganizationPaymentMethodScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  paymentMethodId: 'paymentMethodId',
  preferredStaffId: 'preferredStaffId',
  status: 'status',
  appliedAt: 'appliedAt',
  qualifiedAt: 'qualifiedAt',
  suspendedAt: 'suspendedAt',
  expiresAt: 'expiresAt',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationPaymentMethodScalarFieldEnum = (typeof OrganizationPaymentMethodScalarFieldEnum)[keyof typeof OrganizationPaymentMethodScalarFieldEnum]


export const PaymentMethodQualificationScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationPaymentMethodId: 'organizationPaymentMethodId',
  qualificationFlowId: 'qualificationFlowId',
  templateSnapshot: 'templateSnapshot',
  assigneeId: 'assigneeId',
  status: 'status',
  currentPhaseId: 'currentPhaseId',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  expiresAt: 'expiresAt',
  approvedAt: 'approvedAt',
  approvedById: 'approvedById',
  rejectionReason: 'rejectionReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentMethodQualificationScalarFieldEnum = (typeof PaymentMethodQualificationScalarFieldEnum)[keyof typeof PaymentMethodQualificationScalarFieldEnum]


export const QualificationPhaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  qualificationId: 'qualificationId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description',
  phaseCategory: 'phaseCategory',
  order: 'order',
  status: 'status',
  activatedAt: 'activatedAt',
  completedAt: 'completedAt',
  requiresPreviousPhaseCompletion: 'requiresPreviousPhaseCompletion',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QualificationPhaseScalarFieldEnum = (typeof QualificationPhaseScalarFieldEnum)[keyof typeof QualificationPhaseScalarFieldEnum]


export const PaymentMethodQualificationConfigScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentMethodId: 'paymentMethodId',
  organizationTypeId: 'organizationTypeId',
  qualificationFlowId: 'qualificationFlowId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentMethodQualificationConfigScalarFieldEnum = (typeof PaymentMethodQualificationConfigScalarFieldEnum)[keyof typeof PaymentMethodQualificationConfigScalarFieldEnum]


export const OrganizationDocumentWaiverScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationPaymentMethodId: 'organizationPaymentMethodId',
  documentDefinitionId: 'documentDefinitionId',
  reason: 'reason',
  waivedById: 'waivedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OrganizationDocumentWaiverScalarFieldEnum = (typeof OrganizationDocumentWaiverScalarFieldEnum)[keyof typeof OrganizationDocumentWaiverScalarFieldEnum]


export const AsyncJobScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  jobType: 'jobType',
  status: 'status',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  result: 'result',
  error: 'error',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AsyncJobScalarFieldEnum = (typeof AsyncJobScalarFieldEnum)[keyof typeof AsyncJobScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const OrganizationTypeOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  code: 'code',
  name: 'name',
  description: 'description',
  onboardingFlowId: 'onboardingFlowId'
} as const

export type OrganizationTypeOrderByRelevanceFieldEnum = (typeof OrganizationTypeOrderByRelevanceFieldEnum)[keyof typeof OrganizationTypeOrderByRelevanceFieldEnum]


export const OrganizationTypeAssignmentOrderByRelevanceFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  typeId: 'typeId'
} as const

export type OrganizationTypeAssignmentOrderByRelevanceFieldEnum = (typeof OrganizationTypeAssignmentOrderByRelevanceFieldEnum)[keyof typeof OrganizationTypeAssignmentOrderByRelevanceFieldEnum]


export const UserOrderByRelevanceFieldEnum = {
  id: 'id',
  email: 'email',
  password: 'password',
  phone: 'phone',
  firstName: 'firstName',
  lastName: 'lastName',
  googleId: 'googleId',
  avatar: 'avatar',
  tenantId: 'tenantId',
  walletId: 'walletId',
  emailVerificationToken: 'emailVerificationToken'
} as const

export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


export const RoleOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  tenantId: 'tenantId'
} as const

export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const PermissionOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  path: 'path',
  tenantId: 'tenantId'
} as const

export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


export const RolePermissionOrderByRelevanceFieldEnum = {
  roleId: 'roleId',
  permissionId: 'permissionId'
} as const

export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


export const TenantMembershipOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  tenantId: 'tenantId',
  roleId: 'roleId'
} as const

export type TenantMembershipOrderByRelevanceFieldEnum = (typeof TenantMembershipOrderByRelevanceFieldEnum)[keyof typeof TenantMembershipOrderByRelevanceFieldEnum]


export const OrganizationOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  city: 'city',
  state: 'state',
  country: 'country',
  website: 'website',
  logoUrl: 'logoUrl',
  description: 'description',
  bankCode: 'bankCode',
  bankLicenseNo: 'bankLicenseNo',
  swiftCode: 'swiftCode',
  sortCode: 'sortCode',
  cacNumber: 'cacNumber',
  cacCertificateUrl: 'cacCertificateUrl',
  taxId: 'taxId',
  approvedById: 'approvedById'
} as const

export type OrganizationOrderByRelevanceFieldEnum = (typeof OrganizationOrderByRelevanceFieldEnum)[keyof typeof OrganizationOrderByRelevanceFieldEnum]


export const OrganizationMemberOrderByRelevanceFieldEnum = {
  id: 'id',
  organizationId: 'organizationId',
  userId: 'userId',
  title: 'title',
  department: 'department',
  employeeId: 'employeeId',
  invitedBy: 'invitedBy'
} as const

export type OrganizationMemberOrderByRelevanceFieldEnum = (typeof OrganizationMemberOrderByRelevanceFieldEnum)[keyof typeof OrganizationMemberOrderByRelevanceFieldEnum]


export const OrganizationInvitationOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  roleId: 'roleId',
  title: 'title',
  department: 'department',
  token: 'token',
  invitedById: 'invitedById'
} as const

export type OrganizationInvitationOrderByRelevanceFieldEnum = (typeof OrganizationInvitationOrderByRelevanceFieldEnum)[keyof typeof OrganizationInvitationOrderByRelevanceFieldEnum]


export const OnboardingFlowOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type OnboardingFlowOrderByRelevanceFieldEnum = (typeof OnboardingFlowOrderByRelevanceFieldEnum)[keyof typeof OnboardingFlowOrderByRelevanceFieldEnum]


export const OnboardingFlowPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  onboardingFlowId: 'onboardingFlowId',
  questionnairePlanId: 'questionnairePlanId',
  documentationPlanId: 'documentationPlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description'
} as const

export type OnboardingFlowPhaseOrderByRelevanceFieldEnum = (typeof OnboardingFlowPhaseOrderByRelevanceFieldEnum)[keyof typeof OnboardingFlowPhaseOrderByRelevanceFieldEnum]


export const OrganizationOnboardingOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  onboardingFlowId: 'onboardingFlowId',
  assigneeId: 'assigneeId',
  currentPhaseId: 'currentPhaseId',
  approvedById: 'approvedById',
  rejectionReason: 'rejectionReason'
} as const

export type OrganizationOnboardingOrderByRelevanceFieldEnum = (typeof OrganizationOnboardingOrderByRelevanceFieldEnum)[keyof typeof OrganizationOnboardingOrderByRelevanceFieldEnum]


export const OnboardingPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  onboardingId: 'onboardingId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description'
} as const

export type OnboardingPhaseOrderByRelevanceFieldEnum = (typeof OnboardingPhaseOrderByRelevanceFieldEnum)[keyof typeof OnboardingPhaseOrderByRelevanceFieldEnum]


export const BankDocumentRequirementOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  phaseId: 'phaseId',
  documentType: 'documentType',
  documentName: 'documentName',
  description: 'description',
  allowedMimeTypes: 'allowedMimeTypes'
} as const

export type BankDocumentRequirementOrderByRelevanceFieldEnum = (typeof BankDocumentRequirementOrderByRelevanceFieldEnum)[keyof typeof BankDocumentRequirementOrderByRelevanceFieldEnum]


export const TenantOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  subdomain: 'subdomain'
} as const

export type TenantOrderByRelevanceFieldEnum = (typeof TenantOrderByRelevanceFieldEnum)[keyof typeof TenantOrderByRelevanceFieldEnum]


export const ApiKeyOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  provider: 'provider',
  secretRef: 'secretRef',
  revokedBy: 'revokedBy',
  createdBy: 'createdBy'
} as const

export type ApiKeyOrderByRelevanceFieldEnum = (typeof ApiKeyOrderByRelevanceFieldEnum)[keyof typeof ApiKeyOrderByRelevanceFieldEnum]


export const RefreshTokenOrderByRelevanceFieldEnum = {
  id: 'id',
  jti: 'jti',
  token: 'token',
  userId: 'userId'
} as const

export type RefreshTokenOrderByRelevanceFieldEnum = (typeof RefreshTokenOrderByRelevanceFieldEnum)[keyof typeof RefreshTokenOrderByRelevanceFieldEnum]


export const PasswordResetOrderByRelevanceFieldEnum = {
  id: 'id',
  token: 'token',
  userId: 'userId'
} as const

export type PasswordResetOrderByRelevanceFieldEnum = (typeof PasswordResetOrderByRelevanceFieldEnum)[keyof typeof PasswordResetOrderByRelevanceFieldEnum]


export const UserSuspensionOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  reason: 'reason'
} as const

export type UserSuspensionOrderByRelevanceFieldEnum = (typeof UserSuspensionOrderByRelevanceFieldEnum)[keyof typeof UserSuspensionOrderByRelevanceFieldEnum]


export const EmailPreferenceOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId'
} as const

export type EmailPreferenceOrderByRelevanceFieldEnum = (typeof EmailPreferenceOrderByRelevanceFieldEnum)[keyof typeof EmailPreferenceOrderByRelevanceFieldEnum]


export const DeviceEndpointOrderByRelevanceFieldEnum = {
  id: 'id',
  userId: 'userId',
  endpoint: 'endpoint',
  platform: 'platform'
} as const

export type DeviceEndpointOrderByRelevanceFieldEnum = (typeof DeviceEndpointOrderByRelevanceFieldEnum)[keyof typeof DeviceEndpointOrderByRelevanceFieldEnum]


export const SocialOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  provider: 'provider',
  socialId: 'socialId'
} as const

export type SocialOrderByRelevanceFieldEnum = (typeof SocialOrderByRelevanceFieldEnum)[keyof typeof SocialOrderByRelevanceFieldEnum]


export const OAuthStateOrderByRelevanceFieldEnum = {
  id: 'id',
  state: 'state'
} as const

export type OAuthStateOrderByRelevanceFieldEnum = (typeof OAuthStateOrderByRelevanceFieldEnum)[keyof typeof OAuthStateOrderByRelevanceFieldEnum]


export const WalletOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  currency: 'currency'
} as const

export type WalletOrderByRelevanceFieldEnum = (typeof WalletOrderByRelevanceFieldEnum)[keyof typeof WalletOrderByRelevanceFieldEnum]


export const TransactionOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  walletId: 'walletId',
  reference: 'reference',
  description: 'description'
} as const

export type TransactionOrderByRelevanceFieldEnum = (typeof TransactionOrderByRelevanceFieldEnum)[keyof typeof TransactionOrderByRelevanceFieldEnum]


export const SettingsOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  key: 'key',
  value: 'value',
  category: 'category'
} as const

export type SettingsOrderByRelevanceFieldEnum = (typeof SettingsOrderByRelevanceFieldEnum)[keyof typeof SettingsOrderByRelevanceFieldEnum]


export const PropertyOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  userId: 'userId',
  organizationId: 'organizationId',
  title: 'title',
  category: 'category',
  propertyType: 'propertyType',
  country: 'country',
  currency: 'currency',
  city: 'city',
  district: 'district',
  zipCode: 'zipCode',
  streetAddress: 'streetAddress',
  description: 'description',
  displayImageId: 'displayImageId'
} as const

export type PropertyOrderByRelevanceFieldEnum = (typeof PropertyOrderByRelevanceFieldEnum)[keyof typeof PropertyOrderByRelevanceFieldEnum]


export const PropertyMediaOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  url: 'url',
  type: 'type',
  caption: 'caption'
} as const

export type PropertyMediaOrderByRelevanceFieldEnum = (typeof PropertyMediaOrderByRelevanceFieldEnum)[keyof typeof PropertyMediaOrderByRelevanceFieldEnum]


export const PropertyDocumentOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  name: 'name',
  url: 'url',
  type: 'type'
} as const

export type PropertyDocumentOrderByRelevanceFieldEnum = (typeof PropertyDocumentOrderByRelevanceFieldEnum)[keyof typeof PropertyDocumentOrderByRelevanceFieldEnum]


export const AmenityOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  category: 'category',
  icon: 'icon'
} as const

export type AmenityOrderByRelevanceFieldEnum = (typeof AmenityOrderByRelevanceFieldEnum)[keyof typeof AmenityOrderByRelevanceFieldEnum]


export const PropertyVariantOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  name: 'name',
  description: 'description',
  status: 'status'
} as const

export type PropertyVariantOrderByRelevanceFieldEnum = (typeof PropertyVariantOrderByRelevanceFieldEnum)[keyof typeof PropertyVariantOrderByRelevanceFieldEnum]


export const PropertyVariantAmenityOrderByRelevanceFieldEnum = {
  tenantId: 'tenantId',
  variantId: 'variantId',
  amenityId: 'amenityId'
} as const

export type PropertyVariantAmenityOrderByRelevanceFieldEnum = (typeof PropertyVariantAmenityOrderByRelevanceFieldEnum)[keyof typeof PropertyVariantAmenityOrderByRelevanceFieldEnum]


export const PropertyVariantMediaOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  variantId: 'variantId',
  url: 'url',
  type: 'type',
  caption: 'caption'
} as const

export type PropertyVariantMediaOrderByRelevanceFieldEnum = (typeof PropertyVariantMediaOrderByRelevanceFieldEnum)[keyof typeof PropertyVariantMediaOrderByRelevanceFieldEnum]


export const PropertyUnitOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  variantId: 'variantId',
  unitNumber: 'unitNumber',
  blockName: 'blockName',
  notes: 'notes',
  status: 'status',
  reservedById: 'reservedById',
  ownerId: 'ownerId'
} as const

export type PropertyUnitOrderByRelevanceFieldEnum = (typeof PropertyUnitOrderByRelevanceFieldEnum)[keyof typeof PropertyUnitOrderByRelevanceFieldEnum]


export const PropertyAmenityOrderByRelevanceFieldEnum = {
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  amenityId: 'amenityId'
} as const

export type PropertyAmenityOrderByRelevanceFieldEnum = (typeof PropertyAmenityOrderByRelevanceFieldEnum)[keyof typeof PropertyAmenityOrderByRelevanceFieldEnum]


export const DocumentationPlanOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type DocumentationPlanOrderByRelevanceFieldEnum = (typeof DocumentationPlanOrderByRelevanceFieldEnum)[keyof typeof DocumentationPlanOrderByRelevanceFieldEnum]


export const DocumentDefinitionOrderByRelevanceFieldEnum = {
  id: 'id',
  planId: 'planId',
  documentType: 'documentType',
  documentName: 'documentName',
  description: 'description',
  allowedMimeTypes: 'allowedMimeTypes'
} as const

export type DocumentDefinitionOrderByRelevanceFieldEnum = (typeof DocumentDefinitionOrderByRelevanceFieldEnum)[keyof typeof DocumentDefinitionOrderByRelevanceFieldEnum]


export const ApprovalStageOrderByRelevanceFieldEnum = {
  id: 'id',
  planId: 'planId',
  name: 'name',
  organizationTypeId: 'organizationTypeId',
  description: 'description'
} as const

export type ApprovalStageOrderByRelevanceFieldEnum = (typeof ApprovalStageOrderByRelevanceFieldEnum)[keyof typeof ApprovalStageOrderByRelevanceFieldEnum]


export const QuestionnairePlanOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type QuestionnairePlanOrderByRelevanceFieldEnum = (typeof QuestionnairePlanOrderByRelevanceFieldEnum)[keyof typeof QuestionnairePlanOrderByRelevanceFieldEnum]


export const QuestionnairePlanQuestionOrderByRelevanceFieldEnum = {
  id: 'id',
  questionnairePlanId: 'questionnairePlanId',
  questionKey: 'questionKey',
  questionText: 'questionText',
  helpText: 'helpText'
} as const

export type QuestionnairePlanQuestionOrderByRelevanceFieldEnum = (typeof QuestionnairePlanQuestionOrderByRelevanceFieldEnum)[keyof typeof QuestionnairePlanQuestionOrderByRelevanceFieldEnum]


export const GatePlanOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description',
  reviewerOrganizationTypeId: 'reviewerOrganizationTypeId',
  reviewerInstructions: 'reviewerInstructions'
} as const

export type GatePlanOrderByRelevanceFieldEnum = (typeof GatePlanOrderByRelevanceFieldEnum)[keyof typeof GatePlanOrderByRelevanceFieldEnum]


export const PaymentPlanOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type PaymentPlanOrderByRelevanceFieldEnum = (typeof PaymentPlanOrderByRelevanceFieldEnum)[keyof typeof PaymentPlanOrderByRelevanceFieldEnum]


export const PropertyPaymentMethodOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type PropertyPaymentMethodOrderByRelevanceFieldEnum = (typeof PropertyPaymentMethodOrderByRelevanceFieldEnum)[keyof typeof PropertyPaymentMethodOrderByRelevanceFieldEnum]


export const PropertyPaymentMethodLinkOrderByRelevanceFieldEnum = {
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  paymentMethodId: 'paymentMethodId'
} as const

export type PropertyPaymentMethodLinkOrderByRelevanceFieldEnum = (typeof PropertyPaymentMethodLinkOrderByRelevanceFieldEnum)[keyof typeof PropertyPaymentMethodLinkOrderByRelevanceFieldEnum]


export const PropertyPaymentMethodPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentMethodId: 'paymentMethodId',
  paymentPlanId: 'paymentPlanId',
  documentationPlanId: 'documentationPlanId',
  questionnairePlanId: 'questionnairePlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description'
} as const

export type PropertyPaymentMethodPhaseOrderByRelevanceFieldEnum = (typeof PropertyPaymentMethodPhaseOrderByRelevanceFieldEnum)[keyof typeof PropertyPaymentMethodPhaseOrderByRelevanceFieldEnum]


export const PhaseEventAttachmentOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  handlerId: 'handlerId'
} as const

export type PhaseEventAttachmentOrderByRelevanceFieldEnum = (typeof PhaseEventAttachmentOrderByRelevanceFieldEnum)[keyof typeof PhaseEventAttachmentOrderByRelevanceFieldEnum]


export const ApplicationOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  propertyUnitId: 'propertyUnitId',
  buyerId: 'buyerId',
  sellerId: 'sellerId',
  paymentMethodId: 'paymentMethodId',
  paymentMethodSnapshotHash: 'paymentMethodSnapshotHash',
  applicationNumber: 'applicationNumber',
  title: 'title',
  description: 'description',
  applicationType: 'applicationType',
  currentPhaseId: 'currentPhaseId',
  transferredFromId: 'transferredFromId',
  supersededById: 'supersededById'
} as const

export type ApplicationOrderByRelevanceFieldEnum = (typeof ApplicationOrderByRelevanceFieldEnum)[keyof typeof ApplicationOrderByRelevanceFieldEnum]


export const CoApplicantOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  userId: 'userId',
  email: 'email',
  firstName: 'firstName',
  lastName: 'lastName',
  relationship: 'relationship',
  employmentType: 'employmentType',
  inviteToken: 'inviteToken',
  removedById: 'removedById',
  removalReason: 'removalReason'
} as const

export type CoApplicantOrderByRelevanceFieldEnum = (typeof CoApplicantOrderByRelevanceFieldEnum)[keyof typeof CoApplicantOrderByRelevanceFieldEnum]


export const ApplicationOrganizationOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  organizationId: 'organizationId',
  assignedAsTypeId: 'assignedAsTypeId',
  assignedStaffId: 'assignedStaffId',
  assignedById: 'assignedById',
  declineReason: 'declineReason',
  escalatedToUserId: 'escalatedToUserId',
  escalationNotes: 'escalationNotes'
} as const

export type ApplicationOrganizationOrderByRelevanceFieldEnum = (typeof ApplicationOrganizationOrderByRelevanceFieldEnum)[keyof typeof ApplicationOrganizationOrderByRelevanceFieldEnum]


export const ApplicationRefundOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  reason: 'reason',
  requestedById: 'requestedById',
  approvedById: 'approvedById',
  processedById: 'processedById',
  paymentMethod: 'paymentMethod',
  referenceNumber: 'referenceNumber',
  recipientName: 'recipientName',
  recipientAccount: 'recipientAccount',
  recipientBank: 'recipientBank',
  approvalNotes: 'approvalNotes',
  rejectionNotes: 'rejectionNotes',
  processingNotes: 'processingNotes'
} as const

export type ApplicationRefundOrderByRelevanceFieldEnum = (typeof ApplicationRefundOrderByRelevanceFieldEnum)[keyof typeof ApplicationRefundOrderByRelevanceFieldEnum]


export const ApplicationPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description'
} as const

export type ApplicationPhaseOrderByRelevanceFieldEnum = (typeof ApplicationPhaseOrderByRelevanceFieldEnum)[keyof typeof ApplicationPhaseOrderByRelevanceFieldEnum]


export const QuestionnairePhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  questionnairePlanId: 'questionnairePlanId',
  underwritingDecision: 'underwritingDecision',
  underwritingNotes: 'underwritingNotes'
} as const

export type QuestionnairePhaseOrderByRelevanceFieldEnum = (typeof QuestionnairePhaseOrderByRelevanceFieldEnum)[keyof typeof QuestionnairePhaseOrderByRelevanceFieldEnum]


export const QuestionnairePhaseReviewOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  questionnairePhaseId: 'questionnairePhaseId',
  reviewerId: 'reviewerId',
  notes: 'notes'
} as const

export type QuestionnairePhaseReviewOrderByRelevanceFieldEnum = (typeof QuestionnairePhaseReviewOrderByRelevanceFieldEnum)[keyof typeof QuestionnairePhaseReviewOrderByRelevanceFieldEnum]


export const GatePhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationPhaseId: 'applicationPhaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  gatePlanId: 'gatePlanId',
  reviewerOrganizationTypeId: 'reviewerOrganizationTypeId',
  reviewerInstructions: 'reviewerInstructions',
  rejectionReason: 'rejectionReason'
} as const

export type GatePhaseOrderByRelevanceFieldEnum = (typeof GatePhaseOrderByRelevanceFieldEnum)[keyof typeof GatePhaseOrderByRelevanceFieldEnum]


export const GatePhaseReviewOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  gatePhaseId: 'gatePhaseId',
  reviewerId: 'reviewerId',
  notes: 'notes'
} as const

export type GatePhaseReviewOrderByRelevanceFieldEnum = (typeof GatePhaseReviewOrderByRelevanceFieldEnum)[keyof typeof GatePhaseReviewOrderByRelevanceFieldEnum]


export const DocumentationPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  onboardingPhaseId: 'onboardingPhaseId',
  qualificationPhaseId: 'qualificationPhaseId',
  documentationPlanId: 'documentationPlanId',
  sourceQuestionnairePhaseId: 'sourceQuestionnairePhaseId'
} as const

export type DocumentationPhaseOrderByRelevanceFieldEnum = (typeof DocumentationPhaseOrderByRelevanceFieldEnum)[keyof typeof DocumentationPhaseOrderByRelevanceFieldEnum]


export const PaymentPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  phaseId: 'phaseId',
  paymentPlanId: 'paymentPlanId'
} as const

export type PaymentPhaseOrderByRelevanceFieldEnum = (typeof PaymentPhaseOrderByRelevanceFieldEnum)[keyof typeof PaymentPhaseOrderByRelevanceFieldEnum]


export const QuestionnaireFieldOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  questionnairePhaseId: 'questionnairePhaseId',
  name: 'name',
  label: 'label',
  description: 'description',
  placeholder: 'placeholder'
} as const

export type QuestionnaireFieldOrderByRelevanceFieldEnum = (typeof QuestionnaireFieldOrderByRelevanceFieldEnum)[keyof typeof QuestionnaireFieldOrderByRelevanceFieldEnum]


export const ApplicationEventOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  fromState: 'fromState',
  toState: 'toState',
  trigger: 'trigger',
  actorId: 'actorId'
} as const

export type ApplicationEventOrderByRelevanceFieldEnum = (typeof ApplicationEventOrderByRelevanceFieldEnum)[keyof typeof ApplicationEventOrderByRelevanceFieldEnum]


export const PaymentInstallmentOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentPhaseId: 'paymentPhaseId'
} as const

export type PaymentInstallmentOrderByRelevanceFieldEnum = (typeof PaymentInstallmentOrderByRelevanceFieldEnum)[keyof typeof PaymentInstallmentOrderByRelevanceFieldEnum]


export const ApplicationPaymentOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  installmentId: 'installmentId',
  payerId: 'payerId',
  paymentMethod: 'paymentMethod',
  reference: 'reference',
  gatewayResponse: 'gatewayResponse'
} as const

export type ApplicationPaymentOrderByRelevanceFieldEnum = (typeof ApplicationPaymentOrderByRelevanceFieldEnum)[keyof typeof ApplicationPaymentOrderByRelevanceFieldEnum]


export const ApplicationDocumentOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  stepId: 'stepId',
  documentType: 'documentType',
  documentName: 'documentName',
  name: 'name',
  url: 'url',
  type: 'type',
  uploadedById: 'uploadedById',
  expectedOrganizationId: 'expectedOrganizationId',
  replacesDocumentId: 'replacesDocumentId'
} as const

export type ApplicationDocumentOrderByRelevanceFieldEnum = (typeof ApplicationDocumentOrderByRelevanceFieldEnum)[keyof typeof ApplicationDocumentOrderByRelevanceFieldEnum]


export const DocumentReviewOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  organizationId: 'organizationId',
  organizationTypeId: 'organizationTypeId',
  reviewerId: 'reviewerId',
  reviewerName: 'reviewerName',
  comments: 'comments',
  parentReviewId: 'parentReviewId'
} as const

export type DocumentReviewOrderByRelevanceFieldEnum = (typeof DocumentReviewOrderByRelevanceFieldEnum)[keyof typeof DocumentReviewOrderByRelevanceFieldEnum]


export const ApprovalStageProgressOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentationPhaseId: 'documentationPhaseId',
  approvalStageId: 'approvalStageId',
  name: 'name',
  organizationTypeId: 'organizationTypeId',
  completedById: 'completedById',
  transitionComment: 'transitionComment'
} as const

export type ApprovalStageProgressOrderByRelevanceFieldEnum = (typeof ApprovalStageProgressOrderByRelevanceFieldEnum)[keyof typeof ApprovalStageProgressOrderByRelevanceFieldEnum]


export const DocumentApprovalOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  stageProgressId: 'stageProgressId',
  reviewerId: 'reviewerId',
  organizationTypeId: 'organizationTypeId',
  comment: 'comment'
} as const

export type DocumentApprovalOrderByRelevanceFieldEnum = (typeof DocumentApprovalOrderByRelevanceFieldEnum)[keyof typeof DocumentApprovalOrderByRelevanceFieldEnum]


export const DocumentTemplateOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  code: 'code',
  description: 'description',
  htmlTemplate: 'htmlTemplate',
  cssStyles: 'cssStyles'
} as const

export type DocumentTemplateOrderByRelevanceFieldEnum = (typeof DocumentTemplateOrderByRelevanceFieldEnum)[keyof typeof DocumentTemplateOrderByRelevanceFieldEnum]


export const OfferLetterOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  templateId: 'templateId',
  letterNumber: 'letterNumber',
  htmlContent: 'htmlContent',
  pdfUrl: 'pdfUrl',
  pdfKey: 'pdfKey',
  signatureIp: 'signatureIp',
  cancelReason: 'cancelReason',
  generatedById: 'generatedById',
  sentById: 'sentById'
} as const

export type OfferLetterOrderByRelevanceFieldEnum = (typeof OfferLetterOrderByRelevanceFieldEnum)[keyof typeof OfferLetterOrderByRelevanceFieldEnum]


export const ApplicationTerminationOrderByRelevanceFieldEnum = {
  id: 'id',
  applicationId: 'applicationId',
  tenantId: 'tenantId',
  requestNumber: 'requestNumber',
  initiatorId: 'initiatorId',
  reason: 'reason',
  reviewedBy: 'reviewedBy',
  reviewNotes: 'reviewNotes',
  rejectionReason: 'rejectionReason',
  settlementNotes: 'settlementNotes',
  refundReference: 'refundReference',
  refundMethod: 'refundMethod',
  refundFailureReason: 'refundFailureReason',
  unitReservedForId: 'unitReservedForId',
  idempotencyKey: 'idempotencyKey'
} as const

export type ApplicationTerminationOrderByRelevanceFieldEnum = (typeof ApplicationTerminationOrderByRelevanceFieldEnum)[keyof typeof ApplicationTerminationOrderByRelevanceFieldEnum]


export const PaymentMethodChangeRequestOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  fromPaymentMethodId: 'fromPaymentMethodId',
  toPaymentMethodId: 'toPaymentMethodId',
  requestorId: 'requestorId',
  reason: 'reason',
  requiredDocumentTypes: 'requiredDocumentTypes',
  financialImpactNotes: 'financialImpactNotes',
  reviewerId: 'reviewerId',
  reviewNotes: 'reviewNotes'
} as const

export type PaymentMethodChangeRequestOrderByRelevanceFieldEnum = (typeof PaymentMethodChangeRequestOrderByRelevanceFieldEnum)[keyof typeof PaymentMethodChangeRequestOrderByRelevanceFieldEnum]


export const DocumentRequirementRuleOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentMethodId: 'paymentMethodId',
  fromPaymentMethodId: 'fromPaymentMethodId',
  toPaymentMethodId: 'toPaymentMethodId',
  documentType: 'documentType',
  description: 'description',
  allowedMimeTypes: 'allowedMimeTypes'
} as const

export type DocumentRequirementRuleOrderByRelevanceFieldEnum = (typeof DocumentRequirementRuleOrderByRelevanceFieldEnum)[keyof typeof DocumentRequirementRuleOrderByRelevanceFieldEnum]


export const EventChannelOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  code: 'code',
  name: 'name',
  description: 'description'
} as const

export type EventChannelOrderByRelevanceFieldEnum = (typeof EventChannelOrderByRelevanceFieldEnum)[keyof typeof EventChannelOrderByRelevanceFieldEnum]


export const EventTypeOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  channelId: 'channelId',
  code: 'code',
  name: 'name',
  description: 'description'
} as const

export type EventTypeOrderByRelevanceFieldEnum = (typeof EventTypeOrderByRelevanceFieldEnum)[keyof typeof EventTypeOrderByRelevanceFieldEnum]


export const EventHandlerOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  eventTypeId: 'eventTypeId',
  name: 'name',
  description: 'description',
  filterCondition: 'filterCondition'
} as const

export type EventHandlerOrderByRelevanceFieldEnum = (typeof EventHandlerOrderByRelevanceFieldEnum)[keyof typeof EventHandlerOrderByRelevanceFieldEnum]


export const DomainEventOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  eventType: 'eventType',
  aggregateType: 'aggregateType',
  aggregateId: 'aggregateId',
  queueName: 'queueName',
  payload: 'payload',
  actorId: 'actorId',
  actorRole: 'actorRole',
  status: 'status',
  lastError: 'lastError'
} as const

export type DomainEventOrderByRelevanceFieldEnum = (typeof DomainEventOrderByRelevanceFieldEnum)[keyof typeof DomainEventOrderByRelevanceFieldEnum]


export const PropertyTransferRequestOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  sourceApplicationId: 'sourceApplicationId',
  targetPropertyUnitId: 'targetPropertyUnitId',
  requestedById: 'requestedById',
  reviewedById: 'reviewedById',
  reason: 'reason',
  reviewNotes: 'reviewNotes',
  priceAdjustmentHandling: 'priceAdjustmentHandling',
  refundTransactionId: 'refundTransactionId',
  targetApplicationId: 'targetApplicationId'
} as const

export type PropertyTransferRequestOrderByRelevanceFieldEnum = (typeof PropertyTransferRequestOrderByRelevanceFieldEnum)[keyof typeof PropertyTransferRequestOrderByRelevanceFieldEnum]


export const ApprovalRequestOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  entityType: 'entityType',
  entityId: 'entityId',
  title: 'title',
  description: 'description',
  requestedById: 'requestedById',
  assigneeId: 'assigneeId',
  reviewedById: 'reviewedById',
  reviewNotes: 'reviewNotes'
} as const

export type ApprovalRequestOrderByRelevanceFieldEnum = (typeof ApprovalRequestOrderByRelevanceFieldEnum)[keyof typeof ApprovalRequestOrderByRelevanceFieldEnum]


export const WorkflowBlockerOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  applicationId: 'applicationId',
  phaseId: 'phaseId',
  stepId: 'stepId',
  actionRequired: 'actionRequired',
  context: 'context',
  resolvedByActor: 'resolvedByActor',
  resolutionTrigger: 'resolutionTrigger'
} as const

export type WorkflowBlockerOrderByRelevanceFieldEnum = (typeof WorkflowBlockerOrderByRelevanceFieldEnum)[keyof typeof WorkflowBlockerOrderByRelevanceFieldEnum]


export const ScheduledJobOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  summary: 'summary'
} as const

export type ScheduledJobOrderByRelevanceFieldEnum = (typeof ScheduledJobOrderByRelevanceFieldEnum)[keyof typeof ScheduledJobOrderByRelevanceFieldEnum]


export const DocumentExpiryWarningOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentId: 'documentId',
  notificationId: 'notificationId',
  resolvedBy: 'resolvedBy',
  newDocumentId: 'newDocumentId'
} as const

export type DocumentExpiryWarningOrderByRelevanceFieldEnum = (typeof DocumentExpiryWarningOrderByRelevanceFieldEnum)[keyof typeof DocumentExpiryWarningOrderByRelevanceFieldEnum]


export const QualificationFlowOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  name: 'name',
  description: 'description'
} as const

export type QualificationFlowOrderByRelevanceFieldEnum = (typeof QualificationFlowOrderByRelevanceFieldEnum)[keyof typeof QualificationFlowOrderByRelevanceFieldEnum]


export const QualificationFlowPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  qualificationFlowId: 'qualificationFlowId',
  questionnairePlanId: 'questionnairePlanId',
  documentationPlanId: 'documentationPlanId',
  gatePlanId: 'gatePlanId',
  name: 'name',
  description: 'description'
} as const

export type QualificationFlowPhaseOrderByRelevanceFieldEnum = (typeof QualificationFlowPhaseOrderByRelevanceFieldEnum)[keyof typeof QualificationFlowPhaseOrderByRelevanceFieldEnum]


export const OrganizationPaymentMethodOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationId: 'organizationId',
  paymentMethodId: 'paymentMethodId',
  preferredStaffId: 'preferredStaffId',
  notes: 'notes'
} as const

export type OrganizationPaymentMethodOrderByRelevanceFieldEnum = (typeof OrganizationPaymentMethodOrderByRelevanceFieldEnum)[keyof typeof OrganizationPaymentMethodOrderByRelevanceFieldEnum]


export const PaymentMethodQualificationOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationPaymentMethodId: 'organizationPaymentMethodId',
  qualificationFlowId: 'qualificationFlowId',
  assigneeId: 'assigneeId',
  currentPhaseId: 'currentPhaseId',
  approvedById: 'approvedById',
  rejectionReason: 'rejectionReason'
} as const

export type PaymentMethodQualificationOrderByRelevanceFieldEnum = (typeof PaymentMethodQualificationOrderByRelevanceFieldEnum)[keyof typeof PaymentMethodQualificationOrderByRelevanceFieldEnum]


export const QualificationPhaseOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  qualificationId: 'qualificationId',
  phaseTemplateId: 'phaseTemplateId',
  name: 'name',
  description: 'description'
} as const

export type QualificationPhaseOrderByRelevanceFieldEnum = (typeof QualificationPhaseOrderByRelevanceFieldEnum)[keyof typeof QualificationPhaseOrderByRelevanceFieldEnum]


export const PaymentMethodQualificationConfigOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  paymentMethodId: 'paymentMethodId',
  organizationTypeId: 'organizationTypeId',
  qualificationFlowId: 'qualificationFlowId'
} as const

export type PaymentMethodQualificationConfigOrderByRelevanceFieldEnum = (typeof PaymentMethodQualificationConfigOrderByRelevanceFieldEnum)[keyof typeof PaymentMethodQualificationConfigOrderByRelevanceFieldEnum]


export const OrganizationDocumentWaiverOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  organizationPaymentMethodId: 'organizationPaymentMethodId',
  documentDefinitionId: 'documentDefinitionId',
  reason: 'reason',
  waivedById: 'waivedById'
} as const

export type OrganizationDocumentWaiverOrderByRelevanceFieldEnum = (typeof OrganizationDocumentWaiverOrderByRelevanceFieldEnum)[keyof typeof OrganizationDocumentWaiverOrderByRelevanceFieldEnum]


export const AsyncJobOrderByRelevanceFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  jobType: 'jobType',
  error: 'error'
} as const

export type AsyncJobOrderByRelevanceFieldEnum = (typeof AsyncJobOrderByRelevanceFieldEnum)[keyof typeof AsyncJobOrderByRelevanceFieldEnum]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'PermissionEffect'
 */
export type EnumPermissionEffectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionEffect'>
    


/**
 * Reference to a field of type 'OrganizationStatus'
 */
export type EnumOrganizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationStatus'>
    


/**
 * Reference to a field of type 'InvitationStatus'
 */
export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'PhaseCategory'
 */
export type EnumPhaseCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhaseCategory'>
    


/**
 * Reference to a field of type 'OnboardingStatus'
 */
export type EnumOnboardingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OnboardingStatus'>
    


/**
 * Reference to a field of type 'PhaseStatus'
 */
export type EnumPhaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhaseStatus'>
    


/**
 * Reference to a field of type 'BankDocumentModifier'
 */
export type EnumBankDocumentModifierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BankDocumentModifier'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'TransactionType'
 */
export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


/**
 * Reference to a field of type 'TransactionStatus'
 */
export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


/**
 * Reference to a field of type 'PropertyStatus'
 */
export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


/**
 * Reference to a field of type 'UploadedBy'
 */
export type EnumUploadedByFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UploadedBy'>
    


/**
 * Reference to a field of type 'RejectionBehavior'
 */
export type EnumRejectionBehaviorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RejectionBehavior'>
    


/**
 * Reference to a field of type 'ScoringStrategy'
 */
export type EnumScoringStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoringStrategy'>
    


/**
 * Reference to a field of type 'QuestionnaireCategory'
 */
export type EnumQuestionnaireCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireCategory'>
    


/**
 * Reference to a field of type 'QuestionType'
 */
export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


/**
 * Reference to a field of type 'QuestionCategory'
 */
export type EnumQuestionCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionCategory'>
    


/**
 * Reference to a field of type 'PaymentFrequency'
 */
export type EnumPaymentFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentFrequency'>
    


/**
 * Reference to a field of type 'CompletionCriterion'
 */
export type EnumCompletionCriterionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletionCriterion'>
    


/**
 * Reference to a field of type 'PhaseTrigger'
 */
export type EnumPhaseTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhaseTrigger'>
    


/**
 * Reference to a field of type 'ApplicationStatus'
 */
export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


/**
 * Reference to a field of type 'CoApplicantStatus'
 */
export type EnumCoApplicantStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoApplicantStatus'>
    


/**
 * Reference to a field of type 'ApplicationOrganizationStatus'
 */
export type EnumApplicationOrganizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationOrganizationStatus'>
    


/**
 * Reference to a field of type 'RefundStatus'
 */
export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


/**
 * Reference to a field of type 'ReviewDecision'
 */
export type EnumReviewDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewDecision'>
    


/**
 * Reference to a field of type 'FieldType'
 */
export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


/**
 * Reference to a field of type 'ApplicationEventType'
 */
export type EnumApplicationEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationEventType'>
    


/**
 * Reference to a field of type 'ApplicationEventGroup'
 */
export type EnumApplicationEventGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationEventGroup'>
    


/**
 * Reference to a field of type 'EventActorType'
 */
export type EnumEventActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventActorType'>
    


/**
 * Reference to a field of type 'InstallmentStatus'
 */
export type EnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus'>
    


/**
 * Reference to a field of type 'PaymentStatus'
 */
export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


/**
 * Reference to a field of type 'DocumentStatus'
 */
export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


/**
 * Reference to a field of type 'StageStatus'
 */
export type EnumStageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StageStatus'>
    


/**
 * Reference to a field of type 'OfferLetterType'
 */
export type EnumOfferLetterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferLetterType'>
    


/**
 * Reference to a field of type 'OfferLetterStatus'
 */
export type EnumOfferLetterStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferLetterStatus'>
    


/**
 * Reference to a field of type 'TerminationInitiator'
 */
export type EnumTerminationInitiatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerminationInitiator'>
    


/**
 * Reference to a field of type 'TerminationType'
 */
export type EnumTerminationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerminationType'>
    


/**
 * Reference to a field of type 'TerminationStatus'
 */
export type EnumTerminationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerminationStatus'>
    


/**
 * Reference to a field of type 'PaymentMethodChangeStatus'
 */
export type EnumPaymentMethodChangeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodChangeStatus'>
    


/**
 * Reference to a field of type 'DocumentRequirementContext'
 */
export type EnumDocumentRequirementContextFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentRequirementContext'>
    


/**
 * Reference to a field of type 'EventHandlerType'
 */
export type EnumEventHandlerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventHandlerType'>
    


/**
 * Reference to a field of type 'TransferRequestStatus'
 */
export type EnumTransferRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferRequestStatus'>
    


/**
 * Reference to a field of type 'ApprovalRequestType'
 */
export type EnumApprovalRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalRequestType'>
    


/**
 * Reference to a field of type 'ApprovalRequestStatus'
 */
export type EnumApprovalRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalRequestStatus'>
    


/**
 * Reference to a field of type 'ApprovalRequestPriority'
 */
export type EnumApprovalRequestPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalRequestPriority'>
    


/**
 * Reference to a field of type 'ApprovalDecision'
 */
export type EnumApprovalDecisionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalDecision'>
    


/**
 * Reference to a field of type 'BlockerActor'
 */
export type EnumBlockerActorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockerActor'>
    


/**
 * Reference to a field of type 'BlockerCategory'
 */
export type EnumBlockerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockerCategory'>
    


/**
 * Reference to a field of type 'BlockerUrgency'
 */
export type EnumBlockerUrgencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BlockerUrgency'>
    


/**
 * Reference to a field of type 'ScheduledJobType'
 */
export type EnumScheduledJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledJobType'>
    


/**
 * Reference to a field of type 'ScheduledJobStatus'
 */
export type EnumScheduledJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledJobStatus'>
    


/**
 * Reference to a field of type 'QualificationStatus'
 */
export type EnumQualificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QualificationStatus'>
    


/**
 * Reference to a field of type 'AsyncJobStatus'
 */
export type EnumAsyncJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AsyncJobStatus'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  organizationType?: Prisma.OrganizationTypeOmit
  organizationTypeAssignment?: Prisma.OrganizationTypeAssignmentOmit
  user?: Prisma.UserOmit
  role?: Prisma.RoleOmit
  permission?: Prisma.PermissionOmit
  rolePermission?: Prisma.RolePermissionOmit
  tenantMembership?: Prisma.TenantMembershipOmit
  organization?: Prisma.OrganizationOmit
  organizationMember?: Prisma.OrganizationMemberOmit
  organizationInvitation?: Prisma.OrganizationInvitationOmit
  onboardingFlow?: Prisma.OnboardingFlowOmit
  onboardingFlowPhase?: Prisma.OnboardingFlowPhaseOmit
  organizationOnboarding?: Prisma.OrganizationOnboardingOmit
  onboardingPhase?: Prisma.OnboardingPhaseOmit
  bankDocumentRequirement?: Prisma.BankDocumentRequirementOmit
  tenant?: Prisma.TenantOmit
  apiKey?: Prisma.ApiKeyOmit
  refreshToken?: Prisma.RefreshTokenOmit
  passwordReset?: Prisma.PasswordResetOmit
  userSuspension?: Prisma.UserSuspensionOmit
  emailPreference?: Prisma.EmailPreferenceOmit
  deviceEndpoint?: Prisma.DeviceEndpointOmit
  social?: Prisma.SocialOmit
  oAuthState?: Prisma.OAuthStateOmit
  wallet?: Prisma.WalletOmit
  transaction?: Prisma.TransactionOmit
  settings?: Prisma.SettingsOmit
  property?: Prisma.PropertyOmit
  propertyMedia?: Prisma.PropertyMediaOmit
  propertyDocument?: Prisma.PropertyDocumentOmit
  amenity?: Prisma.AmenityOmit
  propertyVariant?: Prisma.PropertyVariantOmit
  propertyVariantAmenity?: Prisma.PropertyVariantAmenityOmit
  propertyVariantMedia?: Prisma.PropertyVariantMediaOmit
  propertyUnit?: Prisma.PropertyUnitOmit
  propertyAmenity?: Prisma.PropertyAmenityOmit
  documentationPlan?: Prisma.DocumentationPlanOmit
  documentDefinition?: Prisma.DocumentDefinitionOmit
  approvalStage?: Prisma.ApprovalStageOmit
  questionnairePlan?: Prisma.QuestionnairePlanOmit
  questionnairePlanQuestion?: Prisma.QuestionnairePlanQuestionOmit
  gatePlan?: Prisma.GatePlanOmit
  paymentPlan?: Prisma.PaymentPlanOmit
  propertyPaymentMethod?: Prisma.PropertyPaymentMethodOmit
  propertyPaymentMethodLink?: Prisma.PropertyPaymentMethodLinkOmit
  propertyPaymentMethodPhase?: Prisma.PropertyPaymentMethodPhaseOmit
  phaseEventAttachment?: Prisma.PhaseEventAttachmentOmit
  application?: Prisma.ApplicationOmit
  coApplicant?: Prisma.CoApplicantOmit
  applicationOrganization?: Prisma.ApplicationOrganizationOmit
  applicationRefund?: Prisma.ApplicationRefundOmit
  applicationPhase?: Prisma.ApplicationPhaseOmit
  questionnairePhase?: Prisma.QuestionnairePhaseOmit
  questionnairePhaseReview?: Prisma.QuestionnairePhaseReviewOmit
  gatePhase?: Prisma.GatePhaseOmit
  gatePhaseReview?: Prisma.GatePhaseReviewOmit
  documentationPhase?: Prisma.DocumentationPhaseOmit
  paymentPhase?: Prisma.PaymentPhaseOmit
  questionnaireField?: Prisma.QuestionnaireFieldOmit
  applicationEvent?: Prisma.ApplicationEventOmit
  paymentInstallment?: Prisma.PaymentInstallmentOmit
  applicationPayment?: Prisma.ApplicationPaymentOmit
  applicationDocument?: Prisma.ApplicationDocumentOmit
  documentReview?: Prisma.DocumentReviewOmit
  approvalStageProgress?: Prisma.ApprovalStageProgressOmit
  documentApproval?: Prisma.DocumentApprovalOmit
  documentTemplate?: Prisma.DocumentTemplateOmit
  offerLetter?: Prisma.OfferLetterOmit
  applicationTermination?: Prisma.ApplicationTerminationOmit
  paymentMethodChangeRequest?: Prisma.PaymentMethodChangeRequestOmit
  documentRequirementRule?: Prisma.DocumentRequirementRuleOmit
  eventChannel?: Prisma.EventChannelOmit
  eventType?: Prisma.EventTypeOmit
  eventHandler?: Prisma.EventHandlerOmit
  domainEvent?: Prisma.DomainEventOmit
  propertyTransferRequest?: Prisma.PropertyTransferRequestOmit
  approvalRequest?: Prisma.ApprovalRequestOmit
  workflowBlocker?: Prisma.WorkflowBlockerOmit
  scheduledJob?: Prisma.ScheduledJobOmit
  documentExpiryWarning?: Prisma.DocumentExpiryWarningOmit
  qualificationFlow?: Prisma.QualificationFlowOmit
  qualificationFlowPhase?: Prisma.QualificationFlowPhaseOmit
  organizationPaymentMethod?: Prisma.OrganizationPaymentMethodOmit
  paymentMethodQualification?: Prisma.PaymentMethodQualificationOmit
  qualificationPhase?: Prisma.QualificationPhaseOmit
  paymentMethodQualificationConfig?: Prisma.PaymentMethodQualificationConfigOmit
  organizationDocumentWaiver?: Prisma.OrganizationDocumentWaiverOmit
  asyncJob?: Prisma.AsyncJobOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

